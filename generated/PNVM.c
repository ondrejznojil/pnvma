/* Smalltalk from Squeak4.6 with VMMaker 4.12.3 translated as C source on 25 June 2016 3:47:46 pm */
/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker-dtl.319 uuid: d058d88c-331d-47ef-b178-fd26ca3de120
   from
	PNVM * SmallDEVS-PNVM-MM.11 uuid: f8490799-7849-4e98-9ee7-ad2070c4934d
 */
static char __buildInfo[] = "PNVM * SmallDEVS-PNVM-MM.11 uuid: f8490799-7849-4e98-9ee7-ad2070c4934d " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include "pnvm_types.h"
#include "pnvm_utils.h"

#include "sqMemoryAccess.h"


/*** Constants ***/
#define ErrorCalendarEmpty 54
#define ErrorCollectionFull 3
#define ErrorExecutionFirst 50
#define ErrorExecutionLast 58
#define ErrorExecutionUnhandledOperator 55
#define ErrorExecutionUnhandledSignature 56
#define ErrorExecutionUnhandledTransitionElement 57
#define ErrorExecutionUnspecified 50
#define ErrorGenericLast 4
#define ErrorIOFirst 100
#define ErrorIOLast 102
#define ErrorInitFailed 58
#define ErrorNoMemory 1
#define ErrorNoSuchPlace 37
#define ErrorNoSuchTemplate 53
#define ErrorNoSuchUplink 52
#define ErrorOutOfRange 2
#define ErrorOutputBufferEmpty 101
#define ErrorParsingCollection 32
#define ErrorParsingExpression 29
#define ErrorParsingFirst 20
#define ErrorParsingInit 24
#define ErrorParsingLast 37
#define ErrorParsingNames 22
#define ErrorParsingNetInst 34
#define ErrorParsingNetInstValue 36
#define ErrorParsingPlace 35
#define ErrorParsingString 33
#define ErrorParsingSymbol 30
#define ErrorParsingTemplate 20
#define ErrorParsingTemplateSymbols 21
#define ErrorParsingToken 31
#define ErrorParsingTransition 27
#define ErrorParsingTransitionCode 28
#define ErrorParsingTransitions 25
#define ErrorParsingUplink 26
#define ErrorParsingUplinks 23
#define ErrorSerializationFailed 102
#define ErrorSuccess 0
#define ErrorTemplatesDatabaseFull 51
#define ErrorUnspecified 4
#define HighestPin 16
#define LowestPin 0
#define MaxNetTemplates 10
#define NetTemplateCodeSize 10000
#define TokenTypeInteger 0
#define TokenTypeNetRef 2
#define TokenTypePointer 3
#define TypeSignArray 2
#define TypeSignEvent 6
#define TypeSignNetInst 4
#define TypeSignPlace 3
#define TypeSignString 0
#define TypeSignTemplate 5
#define TypeSignTuple 1

/*** Function Prototypes ***/
static void appendActiontoHistoryWith(PNVMTupleHead *a, PNVMArrayIter & o);
static sqInt appendNetTemplate(PNVMTemplate *tmpl);
static Error_t bindVariableswithParamsmappinghistory(PNVMTupleHead *vars, PNVMTupleHead const *params, PNVMTupleHead const *mapping, PNVMArrayIter & history);
static PNVMEvent * calFront(void);
static PNVMEvent * calPop(void);
static void calRemoveEvent(PNVMEvent *event);
static PNVMEvent * calScheduletimestoPlaceofInstat(PNVMToken & token, sqInt n, sqInt placeId, PNVMNetInstHead *netInst, Time_t time);
static void calendarEvent(void);
#pragma export on
EXPORT(bool) canAllocateBlock(void);
#pragma export off
static PNVMItemIterator changeBlockSizeOfto(PNVMHeaderBlock *block, unsigned int size);
static bool charisOneOf(sqInt c, char const *str);
static bool charIsBlank(sqInt c);
static PNVMArrayIter cleanLastAttemptsFromPos(PNVMArrayIter & i);
static void cleanupOMModule(void);
static PNVMArrayIter clearVariableAssignments(PNVMArrayIter & history);
static sqInt cmpPointerwith(PNVMHeaderBlock const *a, PNVMHeaderBlock const *b);
static sqInt cmpStringwith(PNVMStringHead const *a, PNVMStringHead const *b);
static sqInt cmpTokenwith(PNVMToken const & a, PNVMToken const & b);
static sqInt codeGetVariableCount(char const * & codeptr);
static void codeSeekSkipExpression(char const * & codeptr);
static void codeSeekSkipTransition(char const * & codeptr);
static void codeSeekSkipTransitionElement(char const * & codeptr);
static void codeSeekSkipTransitionElements(char const * & codeptr);
static void codeSeekSkipVariables(char const * & codeptr);
static sqInt codeStoreOffsettoRef(char const *codeptr, char const *& ref);
static sqInt copyValueItemsFromto(PNVMItemIterator & src, PNVMItemIterator & dest);
static sqInt copyValueNitemsFromto(sqInt n, PNVMItemIterator & src, PNVMItemIterator & dest);
static PNVMToken createNetInstanceFrom(PNVMTemplate *tmpl);
#pragma export on
EXPORT(PNVMStringHead *) cstrToString(char const *cstr);
#pragma export off
static bool evalAddto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalAndto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalAssignatCodewithVariablestohistory(PNVMToken const & tokenA, PNVMToken & tokenB, char const * & codeptr, PNVMTupleHead *vars, PNVMToken & result, PNVMArrayIter & history);
static bool evalConcatenateto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalDividedto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalGetto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalIsEqualToto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalIsGreaterThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalIsSmallerThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalMinusto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalModuloto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalOrto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalPushBacktohistory(PNVMToken & tokenA, PNVMToken & tokenB, PNVMToken & result, PNVMArrayIter & history);
static bool evalTimesto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalXorto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalCreateNetInstto(PNVMToken const & token, PNVMToken & result);
static bool evalDumpto(PNVMNetInstHead const *inst, PNVMToken & result);
static bool evalHeadto(PNVMToken const & token, PNVMToken & result);
static bool evalIsArrayto(PNVMToken const & token, PNVMToken & result);
static bool evalIsIntegerto(PNVMToken const & token, PNVMToken & result);
static bool evalIsNetRefto(PNVMToken const & token, PNVMToken & result);
static bool evalIsStringto(PNVMToken const & token, PNVMToken & result);
static bool evalIsTrue(PNVMToken const & token);
static bool evalIsTupleto(PNVMToken const & token, PNVMToken & result);
static bool evalIsValidto(PNVMToken const & token, PNVMToken & result);
static bool evalLoadNetInstto(PNVMToken const & token, PNVMToken & result);
static bool evalLoadTemplatetohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history);
static bool evalNewto(char elem, PNVMToken & result);
static bool evalNotto(PNVMToken const & token, PNVMToken & result);
static bool evalReadPinto(PNVMToken const & token, PNVMToken & result);
static bool evalSendtohistory(PNVMToken & token, PNVMToken & result, PNVMArrayIter & history);
static bool evalTailto(PNVMToken const & token, PNVMToken & result);
static bool evalUnloadtohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history);
static bool evalWriteAtValueto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evaluateExpressionAtontowithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMToken & result, PNVMTupleHead *vars, PNVMArrayIter & history);
static bool executeDownlinkonwithParameterslastAttempthistory(PNVMStringHead const *name, PNVMNetInstHead *inst, PNVMTupleHead *params, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executeDownlinkAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executeOneTransitionElementAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executePutTokenAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history);
static bool executeSchedulePutAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history);
static bool executeTakeTokenAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executeTransitionElementsAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
#pragma export on
EXPORT(bool) failed(void);
#pragma export off
static sqInt fillCodeHoles(void);
static PNVMTemplate * findNetTemplate(PNVMStringHead const *name);
static char const * findUplinkin(PNVMStringHead const *name, PNVMTemplate const *tmpl);
static char * getCodeIteratorAt(sqInt pos);
static CodeLength_t getCodeSize(void);
#pragma export on
EXPORT(Error_t) getError(void);
EXPORT(const char*) getModuleName(void);
#pragma export off
static PNVMToken getTokenForValueOnPosinTemplatewithVariables(char const * & codeptr, PNVMTemplate const *tmpl, PNVMTupleHead *vars);
static sqInt halt(void);
#pragma export on
EXPORT(void) initializeModule(void);
#pragma export off
static Error_t initializeNetInstance(PNVMNetInstHead *inst);
#pragma export on
EXPORT(void) initializeOMModule(void);
#pragma export off
static bool inputMessage(char const *message);
static Error_t inputOutput(void);
#pragma export on
EXPORT(bool) inputString(PNVMStringHead *message);
#pragma export off
static PNVMNetInstHead * instantiateTemplate(sqInt tmplId);
static sqInt loadNetTemplate(char const *  code);
static PNVMToken manageNetInstance(PNVMNetInstHead *inst);
static uint32_t memLoadLong(char const *mem);
static uint16_t memLoadShort(char const *mem);
static char * memStoreLongto(uint32_t value, char *mem);
static char * memStoreShortto(uint16_t value, char *mem);
static PNVMStringHead * outputPopMessage(void);
static void outputValue(PNVMToken const & token);
static PNVMArrayHead * parseArrayallowNetInst(PNVMStringIter & i, sqInt allowNetInst);
static PNVMStringHead * parseCString(char const * & str);
static sqInt parseCodeto(PNVMStringIter & i, char **outptr);
static sqInt parseCollectionstartingWithendingWithtoallowNetInst(PNVMStringIter & i, sqInt start, sqInt end, PNVMItemIterator & o, sqInt allowNetInst);
static sqInt parseExpCharfromto(sqInt character, PNVMStringIter & i, char **outptr);
static sqInt parseExpressionto(PNVMStringIter & i, char **outptr);
static sqInt parseInitto(PNVMStringIter & i, char **outptr);
static sqInt parseIntegerto(PNVMStringIter & i, char **outptr);
static sqInt parseLongIntegerto(PNVMStringIter & i, char **outptr);
static PNVMStringHead * parseName(PNVMStringIter & i);
static sqInt parseNameto(PNVMStringIter & i, char **outptr);
static PNVMTupleHead * parseNames(PNVMStringIter & i);
static sqInt parseNamesto(PNVMStringIter & i, char **outptr);
static PNVMToken parseNetInstValueofTemplate(PNVMStringIter & i, PNVMTemplate const *tmpl);
static PNVMNetInstHead * parseNetInstance(PNVMStringIter & i);
static PNVMTemplate * parseNetTemplate(PNVMStringIter & i);
static PNVMToken parseNumber(PNVMStringIter & i);
static PNVMPlaceHead * parsePlaceofTemplateto(PNVMStringIter & i, PNVMTemplate const *tmpl, PNVMNetInstIter & netInstIter);
static sqInt parsePosIntegerto(PNVMStringIter & i, char **outptr);
static void parseSkipBlanks(PNVMStringIter & iterator);
static sqInt parseSkipBlanksexpecting(PNVMStringIter & iterator, sqInt character);
static sqInt parseSkipBlanksuntil(PNVMStringIter & iterator, sqInt character);
static sqInt parseSkipBlanksuntilOneOf(PNVMStringIter & iterator, char const *string);
static sqInt parseSkipBlanksComma(PNVMStringIter & i);
static sqInt parseSkipBlanksLBto(PNVMStringIter & i, char **outptr);
static sqInt parseSkipBlanksRBto(PNVMStringIter & i, char **outptr);
static sqInt parseStoreOffsettoPtr(char *off, char **ptr);
static PNVMStringHead * parseString(PNVMStringIter & i);
static PNVMToken parseSymbolallowNetInst(PNVMStringIter & i, sqInt allowNetInst);
static PNVMTupleHead * parseSymbols(PNVMStringIter & i);
static PNVMToken parseToken(PNVMStringHead *str);
static sqInt parseTransitionto(PNVMStringIter & i, char **outptr);
static sqInt parseTransitionsto(PNVMStringIter & i, char **outptr);
static PNVMTupleHead * parseTupleallowNetInst(PNVMStringIter & i, sqInt allowNetInst);
static sqInt parseUplinkto(PNVMStringIter & i, char **outptr);
static sqInt parseUplinksto(PNVMStringIter & i, char **outptr);
static sqInt parseValueto(PNVMStringIter & i, char **outptr);
static sqInt placeIndexin(PNVMStringHead const *name, PNVMTemplate const *tmpl);
#pragma export on
EXPORT(PNVMEvent *) primitiveCalFront(void);
EXPORT(bool) primitiveCalIsEmpty(void);
EXPORT(void) primitiveCleanup(void);
EXPORT(void) primitiveCleanupModule(void);
EXPORT(char *) primitiveCodeIteratorAt(sqInt pos);
EXPORT(CodeLength_t) primitiveCodeSize(void);
EXPORT(Time_t) primitiveCurrentTime(void);
EXPORT(bool) primitiveFailed(void);
EXPORT(bool) primitiveInputCStr(char const *msg);
EXPORT(bool) primitiveInputString(PNVMStringHead *msg);
EXPORT(PNVMNetInstHead *) primitiveInstantiateTemplate(sqInt tmplId);
EXPORT(sqInt) primitiveLoadNetTemplate(char const *msg);
EXPORT(Error_t) primitiveMakePlatformTemplateplaceCountplacessymbolscodeLengthtransitions(char const *name, sqInt plcCount, char const * const *places, char const *symbols, CodeLength_t codeLength, CodeLength_t transitions);
EXPORT(PNVMTemplate *) primitiveNetTemplateAt(sqInt index);
EXPORT(sqInt) primitiveNothingChanged(void);
EXPORT(sqInt) primitiveNumberOfNetTemplates(void);
EXPORT(bool) primitiveOutputBufferEmpty(void);
EXPORT(char *) primitiveOutputPopCStr(void);
EXPORT(PNVMStringHead *) primitiveOutputPopMessage(void);
EXPORT(PNVMTemplate *) primitiveParseNetTemplate(PNVMStringHead *strBlock);
EXPORT(PNVMStringHead *) primitiveRenderAsString(PNVMStringHead const *value);
EXPORT(sqInt) primitiveSerializeTokento(PNVMToken const & token, PNVMStringIter & o);
EXPORT(sqInt) primitiveSerializeValueto(PNVMHeaderBlock const *value, PNVMStringIter & o);
EXPORT(sqInt) primitiveStep(void);
EXPORT(sqInt) primitiveStepsExecuted(void);
EXPORT(char *) primitiveStringToCStr(PNVMStringHead const *str);
#pragma export off
static Error_t processTemplateInstances(PNVMTemplate *tmpl);
static Error_t processTemplateInstancesonTransitionwithVariables(PNVMArrayHead *instances, char const *codeptr, PNVMTupleHead *vars);
static Error_t processTransitiononNetInstwithVariables(char const *codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars);
static sqInt putNtokenstoPlaceofNetInst(sqInt number, PNVMToken & token, sqInt placeId, PNVMNetInstHead *inst);
static void releaseHistory(PNVMArrayHead *history);
static void releaseItemAtPos(PNVMItemIterator & i);
static PNVMItemIterator releaseItemsFromPos(PNVMItemIterator & i);
static void releaseItemsWithBlocksFromPos(PNVMItemIterator & i);
static PNVMItemIterator removeItemFromBlockAt(PNVMItemIterator & i);
static sqInt removeNetTemplateonIndex(PNVMTemplate *tmpl, sqInt index);
static PNVMStringHead * renderAsString(PNVMStringHead const *str);
static sqInt renderAsStringto(PNVMStringHead const *str, PNVMStringIter & o);
static void restoreActionAssignwithVariables(PNVMTupleIter ai, PNVMTupleHead *vars);
static void restoreActionCreateInstance(PNVMTupleIter ai);
static void restoreActionLoadTemplate(PNVMTupleIter ai);
static void restoreActionPushBack(PNVMTupleIter ai);
static void restoreActionPut(PNVMTupleIter ai);
static void restoreActionSchedulePut(PNVMTupleIter ai);
static void restoreActionSend(PNVMTupleIter ai);
static void restoreActionTake(PNVMTupleIter ai);
static void restoreActionUnload(PNVMTupleIter ai);
static PNVMArrayIter restoreHistoryFromPoswithVariables(PNVMArrayIter & i, PNVMTupleHead *vars);
static void restoreTransactionActionwithVariables(PNVMTupleHead *a, PNVMTupleHead *vars);
static sqInt serializeNameto(PNVMStringHead const *name, PNVMStringIter & o);
static sqInt serializeNetInstto(PNVMNetInstHead const *inst, PNVMStringIter & o);
static sqInt serializeNetInstValueofTemplateto(PNVMToken const & token, PNVMTemplate *tmpl, PNVMStringIter & o);
static sqInt serializeNumberto(sqInt num, PNVMStringIter & o);
static sqInt serializeTokento(PNVMToken const & token, PNVMStringIter & o);
static sqInt serializeValueto(PNVMHeaderBlock const *block, PNVMStringIter & o);
#pragma export on
EXPORT(Error_t) setError(Error_t err);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
#pragma export off
static bool setInvalidResult(PNVMToken & result);
static void setValueItemat(void *item, PNVMItemIterator & i);
static Error_t step(void);
#pragma export on
EXPORT(char const *) strError(Error_t err);
#pragma export off
static char * stringToCStr(PNVMStringHead const *str);
static void swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(sqInt i1, void *b1, sqInt i2, void *b2, sqInt sig, sqInt isHead);
#pragma export on
EXPORT(void) unmanageNetInstance(PNVMNetInstHead *inst);
#pragma export off
static void updateTime(void);
static void writeValueItemat(void *item, PNVMItemIterator & i);
/*** Variables ***/
static PNVMEvent * calendarHead;
static PNVMEvent * calendarTail;
static bool codeWithHoles;
static Time_t currentTime;
static Error_t error;
static PNVMArrayHead * inputBuffer;
static char inputPins[16];

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"PNVM 25 June 2016 (i)"
#else
	"PNVM 25 June 2016 (e)"
#endif
;
static char netTemplateCode[NetTemplateCodeSize] = PLATFORM_CODE;
static PNVMTemplate * netTemplateTable[MaxNetTemplates];
static bool nothingChanged;
static sqInt numberOfNetTemplates;
static PNVMArrayHead * outputBuffer;
static char outputPins[16];
static sqInt stepCounter;



/*	
	History is an array of actions that modified state of arbitrary net instance, calendar
	or output buffer during execution of single transition on single instance.
	
	One transition element can generate zero o more such actions.
	
	In case that some transition element fails, we need to restore the state of all objects
	before the execution of transition element started.
	
	Action is stored as tuple having as the first element character, that determines type
	of action. This character is usually the same as the element kind or expression
	operation, that triggered the action. After this character follow parameters.
	
	:param o: iterator pointing at the end of history array
	 */

static void appendActiontoHistoryWith(PNVMTupleHead *a, PNVMArrayIter & o) {
	PNVMToken tmp;
	PNVMTupleIter i;

	assert(interpreterProxy->isKindOf(a,'PNVMTupleHead'));
	assert((pnvmValueItemCount(a)) > 0);
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	assert(pnvmIterAtEnd(o));
	assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(o)),'PNVMArrayHead'));
	i = pnvmValueIterator(a);
	assert((pnvmTokenType(pnvmIterValue(i))) == TokenTypeInteger);
	assert(charisOneOf(pnvmTokenInteger(pnvmIterValue(i)), "POYlicasu:"));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,(,(,(,(,("appending action ", dereference(a)), ", to history "), dereference(pnvmIterHeaderBlock(o))), " at index "), pnvmIterIndex(o)));
	tmp = pnvmNewPointer(PNVMToken, a);
	pnvmIterWrite(o, tmp);
	pnvmTokenMakeInvalid(tmp);
}


/*	
	netTemplateTable can contain holes. We iterate until we find empty place and we take it.
	Return index of template.
		-1 if there is no space left
	 */

static sqInt appendNetTemplate(PNVMTemplate *tmpl) {
	sqInt index;

	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	if (numberOfNetTemplates >= MaxNetTemplates) {
		setError(ErrorTemplatesDatabaseFull);
		return -1;
	}
	index = 0;
	while (!((netTemplateTable[index]) == null)) {
		index += 1;
	}
	netTemplateTable[index] = tmpl;
	numberOfNetTemplates += 1;
	return index;
}


/*	
	This assigns binded params from downlink execution to variables local to current
	transition according to mapping.
	
	:param params: Array of parameters passed to successful uplink call.
	:param mapping: is a tuple containing indexes to variables array for each uplink's parameter.
	:param history: will be filled with assignment actions for each newly binded variable.
	 */

static Error_t bindVariableswithParamsmappinghistory(PNVMTupleHead *vars, PNVMTupleHead const *params, PNVMTupleHead const *mapping, PNVMArrayIter & history) {
	PNVMToken tmp;
	PNVMTupleIter ai;
	PNVMTupleIter pi;
	PNVMTupleIter mi;
	PNVMTupleIter vi;
	PNVMTupleHead *action;

	assert(interpreterProxy->isKindOf(mapping,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(params,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	mi = pnvmValueIterator(((PNVMTupleHead *) mapping));
	vi = pnvmValueIterator(vars);
	pi = pnvmValueIterator(((PNVMTupleHead *) params));
	tmp = pnvmNewToken(PNVMToken);
	while (!((pnvmIterAtEnd(mi)) || (error != ErrorSuccess))) {
		if (pnvmTokenIsValid(pnvmIterValue(mi))) {
			pnvmIterSeek(vi, pnvmTokenInteger(pnvmIterNext(mi)));
			if (!(pnvmTokenIsValid(pnvmIterValue(vi)))) {

				/* first let's make a note in history */

				if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
					categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple for history action");
					return ErrorNoMemory;
				}
				ai = pnvmValueIterator(action);
				pnvmTokenSetInteger(tmp, ((sqInt)':'));
				pnvmIterWrite(ai, tmp);
				pnvmTokenSetInteger(tmp, pnvmIterIndex(vi));
				pnvmIterWrite(ai, tmp);
				appendActiontoHistoryWith(action, history);
				pnvmIterSetItem(vi, pnvmIterValue(pi));
			}
			pnvmIterNext(pi);
		}
	}
	return error;
}


/*	
	Return pointer to the first event in calendar.
	Does not modify calendar in any way.
	 */

static PNVMEvent * calFront(void) {
	unlessdieWithmsg(!(calendarHead == null), ErrorCalendarEmpty, "calendar is empty");
	return calendarHead;
}


/*	
	Removes first event from calendar and returns it.
	 */

static PNVMEvent * calPop(void) {
	PNVMEvent *event;

	unlessdieWithmsg(!(calendarHead == null), ErrorCalendarEmpty, "calendar is empty");
	event = calendarHead;
	if ((pnvmEventNext(event)) != null) {
		pnvmEventSetPrev(pnvmEventNext(event), null);
		calendarHead = pnvmEventNext(event);
	} else {
		calendarHead = null;
		calendarTail = null;
	}
	return event;
}


/*	
	Removes event at any position in calendar.
	Event must precisely match.
	 */

static void calRemoveEvent(PNVMEvent *event) {
	assert(interpreterProxy->isKindOf(event,'PNVMEvent'));
	unlessdieWithmsg(!(calendarHead == null), ErrorCalendarEmpty, "calendar is empty");
	if (calendarHead == event) {
		calendarHead = pnvmEventNext(event);
		if (!(calendarHead == null)) {
			pnvmEventSetPrev(calendarHead, null);
		}
	} else {
		pnvmEventSetNext(pnvmEventPrev(event), pnvmEventNext(event));
	}
	if (calendarTail == event) {
		calendarTail = pnvmEventPrev(event);
		if (!(calendarTail == null)) {
			pnvmEventSetNext(calendarTail, null);
		}
	} else {
		pnvmEventSetPrev(pnvmEventNext(event), pnvmEventPrev(event));
	}
}


/*	
	Create a new event and insert it into calendar sorted by time.
	
	:param time is absolute time in milliseconds
	
	Return created instance of Event.
	 */

static PNVMEvent * calScheduletimestoPlaceofInstat(PNVMToken & token, sqInt n, sqInt placeId, PNVMNetInstHead *netInst, Time_t time) {
	PNVMEvent *newEvent;
	PNVMEvent *ptr;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	assert(interpreterProxy->isKindOf(netInst,'PNVMNetInstHead'));
	if (((newEvent = pnvmEventNewtimestoPlaceofInstscheduledAt(PNVMEvent, token, n, placeId, netInst, time))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new event");
		return null;
	}
	if (calendarHead == null) {
		calendarHead = newEvent;
		calendarTail = newEvent;
	} else {
		ptr = calendarHead;
		while (((pnvmEventTime(ptr)) <= time) && ((pnvmEventNext(ptr)) != null)) {
			ptr = pnvmEventNext(ptr);
		}
		if ((pnvmEventTime(ptr)) <= time) {

			/* insert at the end */

			pnvmEventSetPrev(newEvent, ptr);
			pnvmEventSetNext(ptr, newEvent);
			calendarTail = newEvent;
		} else {

			/* insert before - in the middle */

			pnvmEventSetNext(newEvent, ptr);
			pnvmEventSetPrev(newEvent, pnvmEventPrev(ptr));
			if ((pnvmEventPrev(ptr)) == null) {
				calendarHead = newEvent;
			} else {
				pnvmEventSetNext(pnvmEventPrev(ptr), newEvent);
			}
			pnvmEventSetPrev(ptr, newEvent);
		}
	}
	return newEvent;
}


/*	
	Run all the events in calendar scheduled for current time.
	 */

static void calendarEvent(void) {
	PNVMEvent *event;

	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering calendarEvent");
	while ((!(calendarHead == null)) && ((pnvmEventTime(calFront())) <= currentTime)) {
		event = calPop();
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("running event ", dereference(event)));
		putNtokenstoPlaceofNetInst(pnvmEventNumber(event), pnvmEventToken(event), pnvmEventPlaceId(event), pnvmEventNetInstance(event));
		nothingChanged = 0;
		pnvmValueDelete(event);
	}
	if (calendarHead == null) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "calendar is empty");
	} else {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "calendar not empty");
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving calendarEvent");
}


/*	
	Make a check, whether there is a free block in pool of blocks.
	There can be up to MaxBlockCount blocks allocated at once.
	Smalltalk uses its own statistics defined as class variables of PNVMObjectMemory.
	C implementation uses memblock library for this purpose.
	 */

EXPORT(bool) canAllocateBlock(void) {
	sqInt res;

	
# ifdef USE_MEMBLOCK
	res = MEMBLOCK_GetFreeMem() >= AllocationBlockSize;
# else
	res = 1;
# endif  // USE_MEMBLOCK
	
	return res;
}


/*	
	In case the desired size is bigger, than current one, we initialize new items, append
	neccessary blocks and change the item count to size.
	
	In case the desired size is smaller, we release all items past the size boundary with
	all tail blocks, that are no longer needed.
	
	Returns valid iterator to the end of value.
	 */

static PNVMItemIterator changeBlockSizeOfto(PNVMHeaderBlock *block, unsigned int size) {
	PNVMPlaceHead *place;
	PNVMItemIterator iter;
	PNVMPlaceItem placeItem;
	PNVMToken token;
	sqInt sig;

	assert(interpreterProxy->isKindOf(block,'PNVMHeaderBlock'));
	;
	token = pnvmNewToken(PNVMToken);
	placeItem = pnvmPlaceItemNewof(PNVMPlaceItem, 0, pnvmNewToken(PNVMToken));
	place = null;
	if ((pnvmValueItemCount(block)) > size) {
		iter = pnvmValueIterator(block);
		pnvmIterSeek(iter, size);
		return releaseItemsFromPos(iter);
	} else {
		if ((pnvmValueItemCount(block)) < size) {
			iter = pnvmValueIterator(block);
			pnvmIterSeekEnd(iter);
			sig = signature(block);
			while (((((unsigned int) (pnvmIterIndex(iter)))) < size) && (!(error != ErrorSuccess))) {
				if (sig == TypeSignString) {
					pnvmIterWrite(pnvmIterString(iter), 0);
				} else {
					if (sig == TypeSignTuple) {
						pnvmIterWrite(pnvmIterTuple(iter), token);
					} else {
						if (sig == TypeSignArray) {
							pnvmIterWrite(pnvmIterArray(iter), token);
						} else {
							if (sig == TypeSignPlace) {
								pnvmIterWrite(pnvmIterPlace(iter), placeItem);
							} else {
								if (sig == TypeSignNetInst) {

									/* do no allocate a place - it may be created in parser */

									pnvmIterWrite(pnvmIterNetInst(iter), place);
								}
							}
						}
					}
				}
			}
			return iter;
		}
	}
	iter = pnvmValueIterator(block);
	pnvmIterSeekEnd(iter);
	return iter;
}

static bool charisOneOf(sqInt c, char const *str) {
	assert((interpreterProxy->isKindOf(c,'Character')) || (interpreterProxy->isKindOf(c,'Number')));
	assert(interpreterProxy->isKindOf(str,'String'));
	return strchr(str, c);
}

static bool charIsBlank(sqInt c) {
	assert(interpreterProxy->isKindOf(c,'Character'));
	return strchr(" \n\r\t\f\v", c);
}

static PNVMArrayIter cleanLastAttemptsFromPos(PNVMArrayIter & i) {
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,(,(,("cleaning last attempts ", dereference(pnvmIterHeaderBlock(i))), " from pos "), pnvmIterIndex(i)));
	releaseItemsFromPos(pnvmIterAsItemIterator(i));
	return i;
}


/*	
	Release all resources.
	 */

static void cleanupOMModule(void) {
	PNVMEvent *event;
	sqInt i;
	PNVMTemplate *tmpl;
	sqInt index;
	PNVMArrayHead *instances;


	/* clear calendar */

	while (!(calendarHead == null)) {
		event = calPop();
		pnvmValueDelete(event);
	}
	if ((numberOfNetTemplates > 0) && ((pnvmTemplateInstances(tmpl = netTemplateTable[0])) != null)) {
		instances = pnvmTemplateInstances(tmpl);
		if ((pnvmValueItemCount(instances)) > 0) {
			pnvmTokenMakeInvalid((dereference(instances))[0]);
		}
	}

	/* delete templates */

	index = 0;
	for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
		tmpl = netTemplateTable[i];
		if (!((pnvmTemplateInstances(tmpl)) == null)) {
			pnvmValueDelete(pnvmTemplateInstances(tmpl));
			pnvmTemplateSetInstances(tmpl, null);
		}
		pnvmValueDelete(pnvmTemplateSymbols(tmpl));
		pnvmTemplateSetSymbols(tmpl, null);
		pnvmValueDelete(pnvmTemplatePlaces(tmpl));
		pnvmTemplateSetPlaces(tmpl, null);
		pnvmValueDelete(pnvmTemplateName(tmpl));
		pnvmTemplateSetName(tmpl, null);
		pnvmValueDelete(tmpl);
		netTemplateTable[i] = null;
		index += 1;
		while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == null)) {
			index += 1;
		}
	}
	numberOfNetTemplates = 0;
	error = ErrorSuccess;
	;
}


/*	
	When calling uplink transition from transition of some other net instance, we make
	a new variable array, that is passed to downlink function. But the history array for
	embedded execution of uplink stays the same. Thus all these assignments made
	in uplink call are not relevant for our transition. That's why we need to remove all
	of them.
	
	*Note* this does not modify current position of history iterator.
	 */

static PNVMArrayIter clearVariableAssignments(PNVMArrayIter & history) {
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	while (!(pnvmIterAtEnd(history))) {
		if ((pnvmTokenInteger((dereference(((PNVMArrayHead *) (pnvmTokenPointer(pnvmIterValue(history))))))[0])) == (((sqInt)':'))) {
			removeItemFromBlockAt(pnvmIterAsItemIterator(history));
		}
	}
	return history;
}


/*	
	return:
		a < b -> -1
		a > b -> 1
		otherwise -> 0
	 */

static sqInt cmpPointerwith(PNVMHeaderBlock const *a, PNVMHeaderBlock const *b) {
	sqInt res;
	PNVMItemIterator ib;
	PNVMItemIterator ia;
	PNVMEvent const *eventB;
	PNVMEvent const *eventA;

	assert(interpreterProxy->isKindOf(a,'PNVMHeaderBlock'));
	assert(interpreterProxy->isKindOf(b,'PNVMHeaderBlock'));
	if (a == b) {
		return 0;
	}
	if ((signature(a)) < (signature(b))) {
		return -1;
	}
	if ((signature(a)) > (signature(b))) {
		return 1;
	}
	if (pnvmTypeIndexable(a)) {
		if ((signature(a)) == TypeSignString) {
			return cmpStringwith(((PNVMStringHead *) a), ((PNVMStringHead *) b));
		} else {
			if ((pnvmValueItemCount(a)) < (pnvmValueItemCount(b))) {
				return -1;
			}
			if ((pnvmValueItemCount(a)) > (pnvmValueItemCount(b))) {
				return 1;
			}
		}
		ia = pnvmValueIterator(((PNVMHeaderBlock *) a));
		ib = pnvmValueIterator(((PNVMHeaderBlock *) b));
		while (!((pnvmIterAtEnd(ia)) || (pnvmIterAtEnd(ib)))) {
			if ((signature(a)) == TypeSignString) {
				if ((pnvmIterValue(pnvmIterString(ia))) < (pnvmIterValue(pnvmIterString(ib)))) {
					return -1;
				}
				if ((pnvmIterValue(pnvmIterString(ia))) > (pnvmIterValue(pnvmIterString(ib)))) {
					return 1;
				}
			} else {
				if ((signature(a)) == TypeSignTuple) {
					res = cmpTokenwith(pnvmIterValue(pnvmIterTuple(ia)), pnvmIterValue(pnvmIterTuple(ib)));
					if (res != 0) {
						return res;
					}
				} else {
					if ((signature(a)) == TypeSignArray) {
						res = cmpTokenwith(pnvmIterValue(pnvmIterArray(ia)), pnvmIterValue(pnvmIterArray(ib)));
						if (res != 0) {
							return res;
						}
					} else {
						dieWithmsgwith(ErrorExecutionUnhandledSignature, "unsupported data block for comparison: ", dereference(a));
					}
				}
			}
			pnvmIterNext(ia);
			pnvmIterNext(ib);
		}
		if ((pnvmIterAtEnd(ia)) && (!(pnvmIterAtEnd(ib)))) {
			return -1;
		}
		if ((!(pnvmIterAtEnd(ia))) && (pnvmIterAtEnd(ib))) {
			return 1;
		}
		pnvmIterNext(ia);
		pnvmIterNext(ib);
	} else {
		if ((signature(a)) == TypeSignTemplate) {
			res = cmpPointerwith(pnvmTemplateName(((PNVMTemplate const *) a)), pnvmTemplateName(((PNVMTemplate const *) b)));
			if (res != 0) {
				return res;
			}
		} else {
			if ((signature(a)) == TypeSignEvent) {
				eventA = ((PNVMEvent const *) a);
				eventB = ((PNVMEvent const *) a);
				if ((pnvmEventTime(eventA)) < (pnvmEventTime(eventB))) {
					return -1;
				}
				if ((pnvmEventTime(eventA)) > (pnvmEventTime(eventB))) {
					return 1;
				}
				if ((pnvmEventNetInstance(eventA)) < (pnvmEventNetInstance(eventB))) {
					return -1;
				}
				if ((pnvmEventNetInstance(eventA)) > (pnvmEventNetInstance(eventB))) {
					return 1;
				}
				if ((pnvmEventPlaceId(eventA)) < (pnvmEventPlaceId(eventB))) {
					return -1;
				}
				if ((pnvmEventPlaceId(eventA)) > (pnvmEventPlaceId(eventB))) {
					return 1;
				}
				if (((res = cmpTokenwith(pnvmEventToken(eventA), pnvmEventToken(eventB)))) != 0) {
					return res;
				}
				if ((pnvmEventNumber(eventA)) < (pnvmEventNumber(eventB))) {
					return -1;
				}
				if ((pnvmEventNumber(eventA)) > (pnvmEventNumber(eventB))) {
					return 1;
				}
			} else {
				dieWithmsgwith(ErrorExecutionUnhandledSignature, "unknown type signature: ", signature(a));
			}
		}
	}
	return 0;
}


/*	
	return:
		a < b -> -1
		a > b -> 1
		otherwise -> 0
	 */

static sqInt cmpStringwith(PNVMStringHead const *a, PNVMStringHead const *b) {
	PNVMStringIter ib;
	PNVMStringIter ia;

	assert(interpreterProxy->isKindOf(a,'PNVMStringHead'));
	assert(interpreterProxy->isKindOf(b,'PNVMStringHead'));
	if (a == b) {
		return 0;
	}
	ia = pnvmValueIterator(((PNVMStringHead *) a));
	ib = pnvmValueIterator(((PNVMStringHead *) b));
	while (!((pnvmIterAtEnd(ia)) || (pnvmIterAtEnd(ib)))) {
		if ((pnvmIterValue(ia)) < (pnvmIterValue(ib))) {
			return -1;
		}
		if ((pnvmIterValue(ia)) > (pnvmIterValue(ib))) {
			return 1;
		}
		if ((pnvmIterAtEnd(ia)) && (!(pnvmIterAtEnd(ib)))) {
			return -1;
		}
		if ((!(pnvmIterAtEnd(ia))) && (pnvmIterAtEnd(ib))) {
			return 1;
		}
		pnvmIterNext(ia);
		pnvmIterNext(ib);
	}
	if ((pnvmIterAtEnd(ia)) && (!(pnvmIterAtEnd(ib)))) {
		return -1;
	}
	if ((!(pnvmIterAtEnd(ia))) && (pnvmIterAtEnd(ib))) {
		return 1;
	}
	return 0;
}


/*	
	return:
		a < b -> -1
		a > b -> 1
		otherwise -> 0
	 */

static sqInt cmpTokenwith(PNVMToken const & a, PNVMToken const & b) {
	assert(interpreterProxy->isKindOf(a,'PNVMToken'));
	assert(interpreterProxy->isKindOf(b,'PNVMToken'));
	if ((pnvmTokenType(a)) < (pnvmTokenType(b))) {
		return -1;
	}
	if ((pnvmTokenType(a)) > (pnvmTokenType(b))) {
		return 1;
	}
	if ((pnvmTokenType(a)) == TokenTypeInteger) {
		if ((pnvmTokenInteger(a)) < (pnvmTokenInteger(b))) {
			return -1;
		}
		if ((pnvmTokenInteger(a)) > (pnvmTokenInteger(b))) {
			return 1;
		}
	} else {
		if ((pnvmTokenType(a)) == TokenTypeNetRef) {

			/* in case of net reference, just compare the address */

			if (pnvmTokenNetRef(a) < pnvmTokenNetRef(b)) {
				return -1;
			}
			if (pnvmTokenNetRef(a) > pnvmTokenNetRef(b)) {
				return 1;
			}
			return 0;
		} else {

			/* pointer to value */

			if ((!(pnvmTokenIsValid(a))) && (pnvmTokenIsValid(b))) {
				return -1;
			}
			if ((pnvmTokenIsValid(a)) && (!(pnvmTokenIsValid(b)))) {
				return 1;
			}
			if ((!(pnvmTokenIsValid(a))) && (!(pnvmTokenIsValid(b)))) {
				return 0;
			}
			return cmpPointerwith(pnvmTokenPointer(a), pnvmTokenPointer(b));
		}
	}
	return 0;
}


/*	
	:param codeptr gets modified.
		After return tt points just behind the closing bracket of variables.
	 */

static sqInt codeGetVariableCount(char const * & codeptr) {
	sqInt c;
	sqInt num;

	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	num = 0;
	while (!(((c = codeptr[0])) == (((sqInt)')')))) {
		if (isalpha(c)) {
			num += 1;
			while (!(charisOneOf((c = codeptr[0]), ",)"))) {
				*codeptr++;
			}
		}
		if (c == (((sqInt)','))) {
			*codeptr++;
		}
	}
	*codeptr++;
	return num;
}


/*	
	Skip expression of G or A transition elements.
	It shifts codeptr after the expression's closing bracket.
	 */

static void codeSeekSkipExpression(char const * & codeptr) {
	sqInt j;
	sqInt numparams;
	sqInt c;

	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	c = *codeptr;
	*codeptr++;
	if (charisOneOf(c, "VSI")) {
		*codeptr++;
		*codeptr++;
		*codeptr++;
	} else {
		if ((c == 'd') || ((c == 'n') && (charisOneOf(codeptr[0], "sat")))) {

			/* parameter-less operators */

			*codeptr++;
			if (c == 'n') {
				*codeptr++;
			}
		} else {

			/* unary or binary operators */

			numparams = 0;
			if ((charisOneOf(c, "!phtlcsu")) || ((c == 'i') && (charisOneOf(codeptr[0], "(visatn")))) {

				/* unary operator */

				if ((c == 'i') && ((codeptr[0]) != (((sqInt)'(')))) {
					*codeptr++;
				}
				numparams = 1;
			} else {

				/* binary operators */

				assert(charisOneOf(c, "=<>&|^o:,+-*%/#a"));
				numparams = 2;
			}
			for (j = 1; j <= numparams; j += 1) {
				codeSeekSkipExpression(codeptr);
			}
			*codeptr++;
		}
	}
}

static void codeSeekSkipTransition(char const * & codeptr) {
	sqInt kind;

	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	assert(charisOneOf(codeptr[0], "UIT"));
	kind = *codeptr;
	if ((kind == 'U') || (kind == 'T')) {

		/* skip transition name */

		while (!((codeptr[0]) == (((sqInt)'(')))) {
			*codeptr++;
		}
	}
	if (kind == 'U') {

		/* skip parameters */

		codeSeekSkipVariables(codeptr);
	}
	if ((kind == 'U') || (kind == 'T')) {

		/* skip local variables */

		codeSeekSkipVariables(codeptr);
	}
	codeSeekSkipTransitionElements(codeptr);
	assert((codeptr[0]) == (((sqInt)')')));
	*codeptr++;
}

static void codeSeekSkipTransitionElement(char const * & codeptr) {
	sqInt elem;
	sqInt paramCount;

	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	elem = *codeptr++;
	if (charisOneOf(elem, "POY")) {
		if (elem == (((sqInt)'Y'))) {
			codeStoreOffsettoRef((((codeptr + 2) + 2) + 3) + 4, codeptr);
		} else {
			codeStoreOffsettoRef(((codeptr + 2) + 2) + 3, codeptr);
		}
	} else {
		if (elem == (((sqInt)'D'))) {
			while ((*codeptr++) > 0) {
			}
			*codeptr++;
			*codeptr++;
			paramCount = memLoadShort(codeptr);
			codeStoreOffsettoRef((codeptr + (3 * paramCount)) + 2, codeptr);
		} else {

			/* skip expressions */

			assert(charisOneOf(elem, "AG"));
			assert((codeptr[0]) == (((sqInt)'(')));
			codeSeekSkipExpression(codeptr);
		}
	}
	*codeptr++;
}

static void codeSeekSkipTransitionElements(char const * & codeptr) {
	while (!((codeptr[0]) == (((sqInt)')')))) {
		codeSeekSkipTransitionElement(codeptr);
	}
}

static void codeSeekSkipVariables(char const * & codeptr) {
	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	while (!((*codeptr++) == (((sqInt)')')))) {
	}
}

static sqInt codeStoreOffsettoRef(char const *codeptr, char const *& ref) {
	sqInt ret;

	ret = codeptr - ref;
	ref = codeptr;
	return ret;
}


/*	
	Return number of items written.
	Both iterators get modified.
	 */

static sqInt copyValueItemsFromto(PNVMItemIterator & src, PNVMItemIterator & dest) {
	return copyValueNitemsFromto(pnvmValueItemCount(pnvmIterHeaderBlock(src)), src, dest);
}


/*	
	Retrun number of items copied.
	Both iterators get modified.
	 */

static sqInt copyValueNitemsFromto(sqInt n, PNVMItemIterator & src, PNVMItemIterator & dest) {
	sqInt count;

	assert((signature(pnvmIterHeaderBlock(src))) == (signature(pnvmIterHeaderBlock(dest))));
	count = 0;
	while ((!(pnvmIterAtEnd(src))) && (count < n)) {
		writeValueItemat(pnvmIterNext(src), dest);
		count += 1;
	}
	return count;
}


/*	
	Instance is created and appended to template instance list.
	Instance should be initialized by caller.
	
	:param tmplNo is a zero-based index to netTemplateTable
	
	Return created instance in token.
	 */

static PNVMToken createNetInstanceFrom(PNVMTemplate *tmpl) {
	PNVMPlaceHead *place;
	PNVMToken res;
	PNVMNetInstIter instIter;
	PNVMNetInstHead *inst;

	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("creating instance of template ", dereference(tmpl)));
	if (((inst = pnvmNetInstNew(PNVMNetInstHead, tmpl))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new net instance");
		return pnvmNewToken(PNVMToken);
	}
	changeBlockSizeOfto(inst, pnvmTemplatePlaceCount(tmpl));
	if (error != ErrorSuccess) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to resize net instance");
		pnvmValueDelete(inst);
		return pnvmNewToken(PNVMToken);
	}
	instIter = pnvmValueIterator(inst);
	while (!(pnvmIterAtEnd(instIter))) {
		if (((place = pnvmPlaceNew(PNVMPlaceHead))) == null) {
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new place");
			pnvmValueDelete(inst);
			return pnvmNewToken(PNVMToken);
		}
		pnvmIterWrite(instIter, place);
	}
	if (!(pnvmTokenIsValid(res = manageNetInstance(inst)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to manage net instance");
		pnvmValueDelete(inst);
	}
	return res;
}


/*	
	Converts null-terminated c string to string value.
	 */

EXPORT(PNVMStringHead *) cstrToString(char const *cstr) {
	sqInt i;
	PNVMStringHead *res;
	PNVMStringIter o;

	if (((res = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to new string for convertion from c-string");
		return null;
	}
	o = pnvmValueIterator(res);
	i = 0;
	while (cstr[i]) {
		pnvmIterWrite(o, cstr[i]);
		i += 1;
	}
	return res;
}

static bool evalAddto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	sqInt res;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypeInteger) && ((pnvmTokenType(tokenB)) == TokenTypeInteger))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "failed to add two values");
		return setInvalidResult(result);
	}
	res = (pnvmTokenInteger(tokenA)) + (pnvmTokenInteger(tokenB));
	pnvmTokenSetInteger(result, res);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", pnvmTokenInteger(result)), " = "), pnvmTokenInteger(tokenA)), " + "), pnvmTokenInteger(tokenB)));
	return 1;
}

static bool evalAndto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (evalIsTrue(tokenA)) {
		pnvmTokenAssign(result, tokenB);
	} else {
		pnvmTokenAssign(result, tokenA);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("and evaluates to: ", evalIsTrue(result)));
	return 1;
}


/*	
	This evaluation is special.
	The first operand can either be a valid integer token holding index to vars
	or invalid token (in code represented by Vxx). We need to get index to
	vars to assign to them. That's why we need code position.
	
	:param tokenA either integer token or invalid token
	:param tokenB value to be assigned to variable
	:param codeptr points to the opening bracket of the first operand.
		Only needed, whan tokenA is not valid.
		
	Return tokenB.
	 */

static bool evalAssignatCodewithVariablestohistory(PNVMToken const & tokenA, PNVMToken & tokenB, char const * & codeptr, PNVMTupleHead *vars, PNVMToken & result, PNVMArrayIter & history) {
	PNVMTupleIter vi;
	PNVMTupleIter ai;
	PNVMTupleHead *action;
	PNVMToken tmp;
	sqInt varId;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	if (!((pnvmTokenIsValid(tokenB)) && (((pnvmTokenIsValid(tokenA)) && ((pnvmTokenType(tokenA)) == TokenTypeInteger)) || (!(pnvmTokenIsValid(tokenA)))))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "second operand must be valid and first must not for assignment");
		return setInvalidResult(result);
	}
	if (pnvmTokenIsValid(tokenA)) {
		varId = pnvmTokenInteger(tokenA);
	} else {
		if (!((*codeptr++) == (((sqInt)'V')))) {
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "first operand must be variable");
			return setInvalidResult(result);
		}
		varId = memLoadShort(codeptr);
	}
	if ((varId < 0) || ((((unsigned int) varId)) >= (pnvmValueItemCount(vars)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "variables index out of range");
		return setInvalidResult(result);
	}
	vi = pnvmValueIterator(vars);
	pnvmIterSeek(vi, varId);
	if (pnvmTokenIsValid(pnvmIterValue(vi))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("can not assign to binded variable at index ", varId));
		return setInvalidResult(result);
	}
	pnvmIterSetItem(vi, tokenB);
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to create tuple to store history action");
		return setInvalidResult(result);
	}
	ai = pnvmValueIterator(action);
	tmp = pnvmNewInteger(PNVMToken, ((sqInt)':'));
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, varId);
	pnvmIterWrite(ai, tmp);
	appendActiontoHistoryWith(action, history);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("V", varId), " := "), tokenB));
	pnvmTokenAssign(result, tokenB);
	*codeptr++;
	return 1;
}

static bool evalConcatenateto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	PNVMTupleHead *blockBt;
	PNVMTupleHead *blockAt;
	PNVMStringIter o;
	PNVMArrayHead *blockBa;
	PNVMArrayHead *blockAa;
	PNVMArrayHead *resa;
	PNVMStringHead *blockB;
	PNVMStringIter i;
	PNVMArrayIter ia;
	PNVMStringHead *res;
	PNVMStringHead *blockA;
	PNVMArrayIter oa;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!((pnvmTokenIsValid(tokenA)) && ((pnvmTokenIsValid(tokenB)) && (((pnvmTokenType(tokenA)) == TokenTypePointer) && ((pnvmTokenType(tokenB)) == TokenTypePointer))))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to concatenate: operands must be strings");
		return setInvalidResult(result);
	}
	blockA = ((PNVMStringHead *) (pnvmTokenPointer(tokenA)));
	blockB = ((PNVMStringHead *) (pnvmTokenPointer(tokenB)));
	blockAa = ((PNVMArrayHead *) (pnvmTokenPointer(tokenA)));
	blockBa = ((PNVMArrayHead *) (pnvmTokenPointer(tokenB)));
	blockAt = ((PNVMTupleHead *) (pnvmTokenPointer(tokenA)));
	blockBt = ((PNVMTupleHead *) (pnvmTokenPointer(tokenB)));
	if (!((((signature(pnvmTokenPointer(tokenA))) == TypeSignString) && ((signature(pnvmTokenPointer(tokenB))) == TypeSignString)) || (((signature(pnvmTokenPointer(tokenA))) == TypeSignArray) && ((signature(pnvmTokenPointer(tokenB))) == TypeSignArray)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to concatenate: operands must be strings or arrays");
		return setInvalidResult(result);
	}
	if ((signature(pnvmTokenPointer(tokenA))) == TypeSignString) {
		if (((res = pnvmStringNew(PNVMStringHead))) == null) {
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate string for concatenation");
			return setInvalidResult(result);
		}
		o = pnvmValueIterator(res);
		i = pnvmValueIterator(blockA);
		while (!(pnvmIterAtEnd(i))) {
			pnvmIterWrite(o, pnvmIterNext(i));
		}
		i = pnvmValueIterator(blockB);
		while (!(pnvmIterAtEnd(i))) {
			pnvmIterWrite(o, pnvmIterNext(i));
		}
		pnvmTokenSetPointer(result, res);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", asPlainString(((PNVMStringHead *) (pnvmTokenPointer(result))))), " = "), asPlainString(((PNVMStringHead *) (pnvmTokenPointer(tokenA))))), ", "), asPlainString(((PNVMStringHead *) (pnvmTokenPointer(tokenB))))));
	}
	if ((signature(pnvmTokenPointer(tokenA))) == TypeSignArray) {
		if (((resa = pnvmArrayNew(PNVMArrayHead))) == null) {
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate array for concatenation");
			return setInvalidResult(result);
		}
		oa = pnvmValueIterator(resa);
		ia = pnvmValueIterator(blockAa);
		while (!(pnvmIterAtEnd(ia))) {
			pnvmIterWrite(oa, pnvmIterNext(ia));
		}
		ia = pnvmValueIterator(blockBa);
		while (!(pnvmIterAtEnd(ia))) {
			pnvmIterWrite(oa, pnvmIterNext(ia));
		}
		pnvmTokenSetPointer(result, resa);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", ((PNVMArrayHead *) (pnvmTokenPointer(result)))), " = "), ((PNVMArrayHead *) (pnvmTokenPointer(tokenA)))), ", "), ((PNVMArrayHead *) (pnvmTokenPointer(tokenB)))));
	}
	return 1;
}

static bool evalDividedto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	sqInt res;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypeInteger) && ((pnvmTokenType(tokenB)) == TokenTypeInteger))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "failed to divide");
		return setInvalidResult(result);
	}
	res = (pnvmTokenInteger(tokenA)) / (pnvmTokenInteger(tokenB));
	pnvmTokenSetInteger(result, res);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(pnvmTokenInteger(result), " = "), pnvmTokenInteger(tokenA)), " / "), pnvmTokenInteger(tokenB)));
	return 1;
}


/*	get value on index from indexable value */

static bool evalGetto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	PNVMHeaderBlock const *col;
	PNVMItemIterator i;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypePointer) && ((pnvmTokenIsValid(tokenA)) && (pnvmTypeIndexable(pnvmTokenPointer(tokenA)))))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("failed to index unindexable value ", tokenA));
		return setInvalidResult(result);
	}
	if (!((pnvmTokenType(tokenB)) == TokenTypeInteger)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "collection is indexable only by integers");
		return setInvalidResult(result);
	}
	col = pnvmTokenPointer(tokenA);
	if (((pnvmTokenInteger(tokenB)) < 0) || ((pnvmTokenInteger(tokenB)) >= (((int) (pnvmValueItemCount(col)))))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "index out of range");
		return setInvalidResult(result);
	}
	i = pnvmValueIterator(((PNVMHeaderBlock *) col));
	pnvmIterSeek(i, pnvmTokenInteger(tokenB));
	pnvmTokenAssign(result, ((signature(col)) == TypeSignArray
		? pnvmIterValue(pnvmIterArray(i))
		: ((signature(col)) == TypeSignTuple
	? pnvmIterValue(pnvmIterTuple(i))
	: ((signature(col)) == TypeSignString
	? pnvmNewInteger(PNVMToken, pnvmIterValue(pnvmIterString(i)))
	: pnvmNewToken(PNVMToken)))));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,("", result), " = "), tokenA), "["), pnvmTokenInteger(tokenB)), "]"));
	return 1;
}

static bool evalIsEqualToto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if ((cmpTokenwith(tokenA, tokenB)) == 0) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", pnvmTokenInteger(result)), " = "), tokenA), " == "), tokenB));
	return 1;
}

static bool evalIsGreaterThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if ((cmpTokenwith(tokenA, tokenB)) > 0) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", pnvmTokenInteger(result)), " = "), tokenA), " > "), tokenB));
	return 1;
}

static bool evalIsSmallerThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if ((cmpTokenwith(tokenA, tokenB)) < 0) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", pnvmTokenInteger(result)), " = "), tokenA), " < "), tokenB));
	return 1;
}

static bool evalMinusto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	sqInt res;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypeInteger) && ((pnvmTokenType(tokenB)) == TokenTypeInteger))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "operands must be numbers for aithmetic operation");
		return setInvalidResult(result);
	}
	res = (pnvmTokenInteger(tokenA)) - (pnvmTokenInteger(tokenB));
	pnvmTokenSetInteger(result, res);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(pnvmTokenInteger(result), " = "), pnvmTokenInteger(tokenA)), " - "), pnvmTokenInteger(tokenB)));
	return 1;
}

static bool evalModuloto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypeInteger) && ((pnvmTokenType(tokenB)) == TokenTypeInteger))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "operands must be numbers for arithmetic operation");
		return 0;
	}
	pnvmTokenSetInteger(result, (pnvmTokenInteger(tokenA)) % (pnvmTokenInteger(tokenB)));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", pnvmTokenInteger(result)), " = "), pnvmTokenInteger(tokenA)), " % "), pnvmTokenInteger(tokenB)));
	return 1;
}

static bool evalOrto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (evalIsTrue(tokenA)) {
		pnvmTokenAssign(result, tokenA);
	} else {
		pnvmTokenAssign(result, tokenB);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", pnvmTokenValue(result)), " = "), pnvmTokenValue(tokenA)), " || "), pnvmTokenValue(tokenB)));
	return 1;
}


/*	
	appends value to modifiable collection such as
		* string
		* array
	Note: that tokenA is really modified! That means the value is modified for all referents.
	This can be issue especially for symbols (user probably expects the symbols to be constants).
	Should be fixed -> sequences should have copy-on-write semantics.
	
	Result is the first argument.
	 */

static bool evalPushBacktohistory(PNVMToken & tokenA, PNVMToken & tokenB, PNVMToken & result, PNVMArrayIter & history) {
	PNVMToken tmp;
	PNVMItemIterator i;
	PNVMTupleIter ai;
	PNVMTupleHead *action;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	assert(interpreterProxy->isKindOf(result,'PNVMToken'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypePointer) && ((pnvmTokenIsValid(tokenA)) && (((signature(pnvmTokenPointer(tokenA))) == TypeSignString) || ((signature(pnvmTokenPointer(tokenA))) == TypeSignArray))))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("failed to append to unindexable or non-modifiable value ", tokenA));
		return setInvalidResult(result);
	}
	if (!(pnvmTokenIsValid(tokenB))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "second operand must be valid to append to collection");
		return setInvalidResult(result);
	}
	i = pnvmValueIterator(pnvmTokenPointer(tokenA));
	pnvmIterSeekEnd(i);
	if ((signature(pnvmIterHeaderBlock(i))) == TypeSignString) {
		pnvmIterSetItem(pnvmIterString(i), pnvmTokenInteger(tokenB));
	} else {
		pnvmIterSetItem(pnvmIterArray(i), tokenB);
	}
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
		return setInvalidResult(result);
	}
	ai = pnvmValueIterator(action);
	tmp = pnvmNewInteger(PNVMToken, ((sqInt)'a'));
	pnvmIterWrite(ai, tmp);
	pnvmIterWrite(ai, tokenA);
	appendActiontoHistoryWith(action, history);
	pnvmTokenAssign(result, tokenA);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,("", dereference(pnvmTokenPointer(tokenA))), ".push_back("), tokenB), ")"));
	return 1;
}

static bool evalTimesto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	sqInt res;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!(((pnvmTokenType(tokenA)) == TokenTypeInteger) && ((pnvmTokenType(tokenB)) == TokenTypeInteger))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "operands must be numbers for aithmetic operation");
		return setInvalidResult(result);
	}
	res = (pnvmTokenInteger(tokenA)) * (pnvmTokenInteger(tokenB));
	pnvmTokenSetInteger(result, res);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(pnvmTokenInteger(result), " = "), pnvmTokenInteger(tokenA)), " * "), pnvmTokenInteger(tokenB)));
	return 1;
}

static bool evalXorto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (evalIsTrue(tokenA)) {
		return evalNotto(tokenB, result);
	} else {
		pnvmTokenAssign(result, tokenB);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,("", result), " = "), tokenA), " ^ "), tokenB));
	return 1;
}


/*	
	Result is a net instance.
	
	:param token is a string with net template name.
	 */

static bool evalCreateNetInstto(PNVMToken const & token, PNVMToken & result) {
	PNVMToken tmp;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (!((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TokenTypePointer) && ((signature(pnvmTokenPointer(token))) == TypeSignString)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "token must be a string with template name");
		return setInvalidResult(result);
	}
	tmpl = findNetTemplate(((PNVMStringHead *) (pnvmTokenPointer(token))));
	if (tmpl == null) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("could not find template named ", asPlainString(((PNVMStringHead *) (pnvmTokenPointer(token))))));
		return setInvalidResult(result);
	}
	tmp = createNetInstanceFrom(tmpl);
	initializeNetInstance(pnvmTokenNetRef(tmp));
	pnvmTokenAssign(result, tmp);
	pnvmTokenMakeInvalid(tmp);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("created new net instance from template ", dereference(pnvmTemplateName(tmpl))));
	return 1;
}


/*	
	This evaluates unary operator 'dump'.
	
	:param inst is a net instance to serialize
	
	Result is a string containing serialized instance.
	 */

static bool evalDumpto(PNVMNetInstHead const *inst, PNVMToken & result) {
	PNVMStringIter o;
	PNVMStringHead *str;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	if (((str = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new string for dump");
		return setInvalidResult(result);
	}
	o = pnvmValueIterator(str);
	if ((serializeNetInstto(inst, o)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("failed to serialize net instance ", dereference(inst)));
		return setInvalidResult(result);
	}
	pnvmTokenSetPointer(result, str);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,("instance ", dereference(inst)), " dumped"));
	return 1;
}

static bool evalHeadto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (!(((pnvmTokenType(token)) == TokenTypePointer) && (pnvmTokenIsValid(token)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "can not get head from not indexable or invalid value");
		return setInvalidResult(result);
	}
	if ((pnvmValueItemCount(pnvmTokenPointer(token))) < 1) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "collection is empty");
		return setInvalidResult(result);
	}
	if ((signature(pnvmTokenPointer(token))) == TypeSignString) {
		pnvmTokenSetInteger(result, (dereference(((PNVMStringHead *) (pnvmTokenPointer(token)))))[0]);
	} else {
		if ((signature(pnvmTokenPointer(token))) == TypeSignArray) {
			pnvmTokenAssign(result, (dereference(((PNVMArrayHead *) (pnvmTokenPointer(token)))))[0]);
		} else {
			if ((signature(pnvmTokenPointer(token))) == TypeSignTuple) {
				pnvmTokenAssign(result, (dereference(((PNVMTupleHead *) (pnvmTokenPointer(token)))))[0]);
			} else {
				categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("can not apply head() on ", token));
				return 0;
			}
		}
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,("", result), " = head("), token), ")"));
	return 1;
}

static bool evalIsArrayto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if ((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TokenTypePointer) && ((signature(pnvmTokenPointer(token))) == TypeSignArray))) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	return 1;
}

static bool evalIsIntegerto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if ((pnvmTokenType(token)) == TokenTypeInteger) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	return 1;
}

static bool evalIsNetRefto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if ((pnvmTokenType(token)) == TokenTypeNetRef) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	return 1;
}

static bool evalIsStringto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if ((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TokenTypePointer) && ((signature(pnvmTokenPointer(token))) == TypeSignString))) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	return 1;
}

static bool evalIsTrue(PNVMToken const & token) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if ((pnvmTokenType(token)) == TokenTypeInteger) {
		return (pnvmTokenInteger(token)) != 0;
	}
	if ((pnvmTokenType(token)) == TokenTypeNetRef) {
		return 1;
	}
	if (!(pnvmTokenIsValid(token))) {
		return 0;
	}
	if ((pnvmTypeIndexable(pnvmTokenPointer(token))) && ((pnvmValueItemCount(pnvmTokenPointer(token))) > 0)) {
		return 1;
	}
	if (!(pnvmTypeIndexable(pnvmTokenPointer(token)))) {
		return 1;
	}
	return 0;
}

static bool evalIsTupleto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if ((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TokenTypePointer) && ((signature(pnvmTokenPointer(token))) == TypeSignTuple))) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	return 1;
}

static bool evalIsValidto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (pnvmTokenIsValid(token)) {
		pnvmTokenSetInteger(result, 1);
	} else {
		pnvmTokenSetInteger(result, 0);
	}
	return 1;
}


/*	
	Evaluates $i operator.
	Result is a net instance.
	We don't need to store the action in history, garbage collection will do the work.
	
	:param token is a string with serialized net instance.
	 */

static bool evalLoadNetInstto(PNVMToken const & token, PNVMToken & result) {
	PNVMToken tmp;
	PNVMStringIter i;
	PNVMNetInstHead *inst;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (!(((pnvmTokenType(token)) == TokenTypePointer) && ((pnvmTokenIsValid(token)) && ((signature(pnvmTokenPointer(token))) == TypeSignString)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "token must be string for template parsing");
		return setInvalidResult(result);
	}
	i = pnvmValueIterator(((PNVMStringHead *) (pnvmTokenPointer(token))));
	if (!(((inst = parseNetInstance(i))) == null)) {
		if (!(pnvmTokenIsValid(tmp = manageNetInstance(inst)))) {
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to manage instance");
			pnvmValueDelete(inst);
			return 0;
		}
		pnvmTokenAssign(result, tmp);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,("loaded new net instance of template '", dereference(pnvmTemplateName(pnvmNetInstTemplate(inst)))), "' from string"));
		return 1;
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to parse net instance");
	return setInvalidResult(result);
}


/*	
	Result is a boolean. 1 for successful load and 0 on failure.
	
	:param token is a string with net template code.
	 */

static bool evalLoadTemplatetohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history) {
	PNVMToken tmp;
	PNVMStringIter i;
	PNVMTemplate *tmpl;
	PNVMTupleIter ai;
	sqInt index;
	PNVMTupleHead *action;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	if (!(((pnvmTokenType(token)) == TokenTypePointer) && ((pnvmTokenIsValid(token)) && ((signature(pnvmTokenPointer(token))) == TypeSignString)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "token must be string for template parsing");
		return setInvalidResult(result);
	}
	if (numberOfNetTemplates >= MaxNetTemplates) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "not enough space for another net template");
		return setInvalidResult(result);
	}
	i = pnvmValueIterator(((PNVMStringHead *) (pnvmTokenPointer(token))));
	if (!(((tmpl = parseNetTemplate(i))) == null)) {
		index = appendNetTemplate(tmpl);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("loaded new net template '", dereference(tmpl)), "' as id "), index));
		pnvmTokenSetInteger(result, 1);
		if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
			pnvmValueDelete(pnvmTemplateName(tmpl));
			pnvmValueDelete(pnvmTemplateSymbols(tmpl));
			pnvmValueDelete(pnvmTemplatePlaces(tmpl));
			pnvmValueDelete(tmpl);
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
			return setInvalidResult(result);
		}
		ai = pnvmValueIterator(action);
		tmp = pnvmNewInteger(PNVMToken, ((sqInt)'l'));
		pnvmIterWrite(ai, tmp);
		pnvmTokenSetInteger(tmp, index);
		pnvmIterWrite(ai, tmp);
		pnvmTokenSetPointer(tmp, tmpl);
		pnvmIterWrite(ai, tmp);
		appendActiontoHistoryWith(action, history);
		return 1;
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to parse net template");
	pnvmTokenSetInteger(result, 0);
	return 1;
}


/*	
	This evaluates unary operator creating instance of particular type.
	
	:param elem is a last character of operator determining type of value to be created.
	 */

static bool evalNewto(char elem, PNVMToken & result) {
	assert(charisOneOf(elem, "sat"));
	if (elem == 's') {
		pnvmTokenSetPointer(result, pnvmStringNew(PNVMStringHead));
	} else {
		if (elem == 'a') {
			pnvmTokenSetPointer(result, pnvmArrayNew(PNVMArrayHead));
		} else {
			if (elem == 't') {
				pnvmTokenSetPointer(result, pnvmTupleNew(PNVMTupleHead));
			} else {
				dieWithmsgwith(ErrorExecutionUnhandledOperator, "unhandled second character of new operator: ", elem);
			}
		}
	}
	if ((pnvmTokenPointer(result)) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", ,(,("failed to allocate object for operator 'n", elem), "' while evaluating transition expression."));
		return setInvalidResult(result);
	}
	return 1;
}

static bool evalNotto(PNVMToken const & token, PNVMToken & result) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (evalIsTrue(token)) {
		pnvmTokenSetInteger(result, 0);
	} else {
		pnvmTokenSetInteger(result, 1);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("", pnvmTokenInteger(result)), " = ! "), token));
	return 1;
}

static bool evalReadPinto(PNVMToken const & token, PNVMToken & result) {
	sqInt res;
	sqInt at;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (!((pnvmTokenType(token)) == TokenTypeInteger)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to read from pin: pin needs to be specified by integer");
		return setInvalidResult(result);
	}
	at = pnvmTokenInteger(token);
	if ((at < LowestPin) || (at > HighestPin)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,("pin index is out of bounds (", at), ")"));
		return setInvalidResult(result);
	}
	res = 0;
	res = digitalRead(at);
	pnvmTokenSetInteger(result, res);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(pnvmTokenInteger(result), " = digitalInput("), at), ")"));
	return 1;
}

static bool evalSendtohistory(PNVMToken & token, PNVMToken & result, PNVMArrayIter & history) {
	PNVMToken tmp;
	PNVMTupleIter ai;
	PNVMTupleHead *action;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (!(pnvmTokenIsValid(token))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "can not send invalid value");
		return setInvalidResult(result);
	}
	outputValue(token);
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
		return setInvalidResult(result);
	}
	ai = pnvmValueIterator(action);
	tmp = pnvmNewInteger(PNVMToken, ((sqInt)'s'));
	pnvmIterWrite(ai, tmp);
	pnvmIterWrite(ai, token);
	appendActiontoHistoryWith(action, history);
	pnvmTokenAssign(result, token);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,("token ", result), " sent to output buffer"));
	return 1;
}

static bool evalTailto(PNVMToken const & token, PNVMToken & result) {
	PNVMItemIterator i;
	PNVMItemIterator o;
	PNVMHeaderBlock *tail;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	tail = null;
	if (!(((pnvmTokenType(token)) == TokenTypePointer) && (pnvmTokenIsValid(token)))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "can not get head from not indexable or invalid value");
		return setInvalidResult(result);
	}
	if ((pnvmValueItemCount(pnvmTokenPointer(token))) < 1) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "collection is empty");
		return setInvalidResult(result);
	}
	i = pnvmValueIterator(((PNVMHeaderBlock *) (pnvmTokenPointer(token))));
	if ((signature(pnvmTokenPointer(token))) == TypeSignString) {
		tail = pnvmStringNew(PNVMStringHead);
	} else {
		if ((signature(pnvmTokenPointer(token))) == TypeSignArray) {
			tail = pnvmArrayNew(PNVMArrayHead);
		} else {
			if ((signature(pnvmTokenPointer(token))) == TypeSignTuple) {
				tail = pnvmTupleNew(PNVMTupleHead);
			} else {
				dieWithmsgwith(ErrorExecutionUnhandledSignature, "unexpected kind of block: ", dereference(pnvmTokenPointer(token)));
			}
		}
	}
	if (tail == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tail for value");
		return setInvalidResult(result);
	}
	o = pnvmValueIterator(tail);
	pnvmIterNext(i);
	copyValueItemsFromto(i, o);
	pnvmTokenSetPointer(result, tail);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,("", result), " = tail("), token), ")"));
	return 1;
}


/*	
	Evaluates $i operator.
	Result is a boolean saying, whether the unload was successful.
	
	:param token is a string with name of template to unload.
	 */

static bool evalUnloadtohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history) {
	PNVMToken tmp;
	PNVMTemplate *tmpl;
	PNVMTupleIter ai;
	sqInt index;
	PNVMStringHead *name;
	PNVMTupleHead *action;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	if (((pnvmTokenType(token)) != TokenTypePointer) || ((signature(pnvmTokenPointer(token))) != TypeSignString)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to unload template, operand must be a string");
		return setInvalidResult(result);
	}
	name = ((PNVMStringHead *) (pnvmTokenPointer(token)));
	tmpl = findNetTemplate(name);
	pnvmValueDelete(name);
	if (tmpl == null) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,("failed to find net template with name '", asPlainString(name)), "'"));
		pnvmTokenSetInteger(result, 0);
		return 1;
	}
	if (((pnvmTemplateInstances(tmpl)) != null) && ((pnvmValueItemCount(pnvmTemplateInstances(tmpl))) > 0)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "can not unload template with alive instances");
		pnvmTokenSetInteger(result, 0);
		return 1;
	}
	index = 0;
	while (!((netTemplateTable[index]) == tmpl)) {
		index += 1;
	}
	pnvmTokenSetInteger(result, 1);
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
		return setInvalidResult(result);
	}
	ai = pnvmValueIterator(action);
	tmp = pnvmNewInteger(PNVMToken, ((sqInt)'u'));
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, index);
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetPointer(tmp, tmpl);
	pnvmIterWrite(ai, tmp);
	appendActiontoHistoryWith(action, history);
	numberOfNetTemplates -= 1;
	netTemplateTable[index] = null;
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("unloaded net template '", pnvmTemplateName(tmpl)), "' from index="), index));
	return 1;
}

static bool evalWriteAtValueto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
	sqInt at;
	sqInt value;

	assert(interpreterProxy->isKindOf(tokenA,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tokenB,'PNVMToken'));
	if (!((pnvmTokenType(tokenA)) == TokenTypeInteger)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to write to pin: pin needs to be specified by integer");
		return setInvalidResult(result);
	}
	at = pnvmTokenInteger(tokenA);
	if ((at < LowestPin) || (at > HighestPin)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,("pin index is out of bounds (", at), ")"));
		return setInvalidResult(result);
	}
	value = evalIsTrue(tokenB);
	digitalWrite(at, value ? HIGH:LOW);
	pnvmTokenAssign(result, tokenB);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("written ", value), " to pin "), at));
	return 1;
}


/*	
	It recursively evaluates expression and returns boolean.
	Some parameters are short-circuit evaluated.
	
	:param codeptr is modified. It's placed to the end of expression if the result is true.
		Otherwise it's value is undefined.
	:param history only gets new items. It's caller's responsibility to restore it upon failure.
	:param result will be filled with the result of expression's evaluation.
	
	Returns true upon successful evaluation.
	 */

static bool evaluateExpressionAtontowithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMToken & result, PNVMTupleHead *vars, PNVMArrayIter & history) {
	char elem;
	char elem2;
	PNVMToken tmp;
	sqInt satisfied;
	char const *  codeptrOrig;
	PNVMToken op2;
	PNVMToken op1;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(codeptr,'CArrayAccessor'));
	assert(interpreterProxy->isKindOf(result,'PNVMToken'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert((codeptr[0]) == (((sqInt)'(')));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering evaluateExpressionAt:on:to:withVariables:history:");
	codeptrOrig = codeptr + 0;
	satisfied = 0;
	elem = codeptr[1];
	elem2 = 0;
	tmpl = pnvmNetInstTemplate(inst);
	if (elem == 'd') {

		/* dump memory - TODO */

		*codeptr++;
		*codeptr++;
		*codeptr++;
		return evalDumpto(inst, result);
	}
	if (elem == 'n') {
		elem2 = codeptr[2];
		codeStoreOffsettoRef(codeptr + 4, codeptr);
		return evalNewto(elem2, result);
	}
	if (charisOneOf(elem, "ISV")) {

		/* one of symbol, integer or variable */

		*codeptr++;
		tmp = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
		pnvmTokenAssign(result, tmp);
		pnvmTokenMakeInvalid(tmp);
		*codeptr++;
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving evaluateExpressionAt:on:to:withVariables:history: with success");
		return 1;
	}
	*codeptr++;
	*codeptr++;
	if (charisOneOf(elem, "!phtlicsu")) {
		if ((elem == 'i') && (charisOneOf(codeptr[0], "vistan"))) {

			/* 2-character operator */

			elem2 = codeptr[0];
			;
			*codeptr++;
		}
	}

	/* let's get the first operand */

	op1 = pnvmNewToken(PNVMToken);
	if (!(evaluateExpressionAtontowithVariableshistory(codeptr, inst, op1, vars, history))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving evaluateExpressionAt:on:to:withVariables:history: with failure");
		return 0;
	}
	if (elem == '!') {

		/* not */

		satisfied = evalNotto(op1, result);
	} else {
		if (elem == 'p') {

			/* read pin */

			satisfied = evalReadPinto(op1, result);
		} else {
			if (elem == 'h') {

				/* get head from collection */

				satisfied = evalHeadto(op1, result);
			} else {
				if (elem == 't') {

					/* get tail from collection */

					satisfied = evalTailto(op1, result);
				} else {
					if (elem == 'l') {

						/* load net template from string */

						satisfied = evalLoadTemplatetohistory(op1, result, history);
					} else {
						if (elem == 'u') {

							/* unload net template */

							satisfied = evalUnloadtohistory(op1, result, history);
						} else {
							if (elem == 'c') {

								/* create net instance */

								satisfied = evalCreateNetInstto(op1, result);
							} else {
								if (elem == 's') {

									/* send value to output buffer */

									satisfied = evalSendtohistory(op1, result, history);
								} else {
									if ((elem == 'i') && (elem2 == 0)) {

										/* load net instance from string */

										satisfied = evalLoadNetInstto(op1, result);
									} else {
										if ((elem == 'i') && (elem2 == 'v')) {

											/* is value valid? */

											satisfied = evalIsValidto(op1, result);
										} else {
											if ((elem == 'i') && (elem2 == 'i')) {

												/* is value integer? */

												satisfied = evalIsIntegerto(op1, result);
											} else {
												if ((elem == 'i') && (elem2 == 's')) {

													/* is value string? */

													satisfied = evalIsStringto(op1, result);
												} else {
													if ((elem == 'i') && (elem2 == 't')) {

														/* is value tuple? */

														satisfied = evalIsTupleto(op1, result);
													} else {
														if ((elem == 'i') && (elem2 == 'a')) {

															/* is value array? */

															satisfied = evalIsArrayto(op1, result);
														} else {
															if ((elem == 'i') && (elem2 == 'n')) {

																/* is value net instance? */

																satisfied = evalIsNetRefto(op1, result);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (charisOneOf(elem, "!phtlcsiu")) {
		pnvmTokenMakeInvalid(op1);
		*codeptr++;
		return satisfied;
	}
	if ((elem == '&') || (elem == '|')) {

		/* short-circuit evaluated operands */

		if (((elem == '&') && (!(evalIsTrue(op1)))) || ((elem == '|') && (evalIsTrue(op1)))) {

			/* caller expects us to parse the whole expression */

			codeSeekSkipExpression(codeptr);
			*codeptr++;
			pnvmTokenAssign(result, op1);
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,(,(,("", elem), " evaluates to first operand: "), op1));
			pnvmTokenMakeInvalid(op1);
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving evaluateExpressionAt:on:to:withVariables:history: with success");
			return 1;
		}
	}
	op2 = pnvmNewToken(PNVMToken);
	if (!(evaluateExpressionAtontowithVariableshistory(codeptr, inst, op2, vars, history))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving evaluateExpressionAt:on:to:withVariables:history: with failure");
		pnvmTokenMakeInvalid(op1);
		return 0;
	}
	assert((codeptr[0]) == (((sqInt)')')));
	*codeptr++;
	if (elem == ':') {
		*codeptrOrig++;
		*codeptrOrig++;

		/* release only the second argument */
		/* first one belongs to variables */

		satisfied = evalAssignatCodewithVariablestohistory(op1, op2, codeptrOrig, vars, result, history);
		pnvmTokenMakeInvalid(op2);
		return satisfied;
	} else {
		if (elem == ',') {
			satisfied = evalConcatenateto(op1, op2, result);
		} else {
			if (elem == '+') {
				satisfied = evalAddto(op1, op2, result);
			} else {
				if (elem == '-') {
					satisfied = evalMinusto(op1, op2, result);
				} else {
					if (elem == '*') {
						satisfied = evalTimesto(op1, op2, result);
					} else {
						if (elem == '/') {
							satisfied = evalDividedto(op1, op2, result);
						} else {
							if (elem == '%') {
								satisfied = evalModuloto(op1, op2, result);
							} else {
								if (elem == '=') {
									satisfied = evalIsEqualToto(op1, op2, result);
								} else {
									if (elem == '<') {
										satisfied = evalIsSmallerThanto(op1, op2, result);
									} else {
										if (elem == '>') {
											satisfied = evalIsGreaterThanto(op1, op2, result);
										} else {
											if (elem == '&') {
												satisfied = evalAndto(op1, op2, result);
											} else {
												if (elem == '|') {
													satisfied = evalOrto(op1, op2, result);
												} else {
													if (elem == '^') {
														satisfied = evalXorto(op1, op2, result);
													} else {
														if (elem == 'o') {
															satisfied = evalWriteAtValueto(op1, op2, result);
														} else {
															if (elem == '#') {
																satisfied = evalGetto(op1, op2, result);
															} else {
																if (elem == 'a') {
																	satisfied = evalPushBacktohistory(op1, op2, result, history);
																} else {
																	dieWithmsgwith(ErrorExecutionUnhandledOperator, "unhandled expression operator: ", elem);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	pnvmTokenMakeInvalid(op1);
	pnvmTokenMakeInvalid(op2);
	return satisfied;
}


/*	
	Makes uplink call to another instance. This is a generic function callable either from
	interpreter itself or from transition code of some other net instance.
	
	:param name: name of uplink transition in targeted instance
	:param inst: target net instance
	:param params: tuple containing uplink parameters. Free parameters may be binded
		after the successful execution of this call.
	:param lastAttempt: iterator to array of attempts.
		On the first call this points at the end of array.
	:param history: iterator pointing at the end of history array.
	 */

static bool executeDownlinkonwithParameterslastAttempthistory(PNVMStringHead const *name, PNVMNetInstHead *inst, PNVMTupleHead *params, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
	PNVMTupleIter pi;
	PNVMTupleIter vi;
	sqInt satisfied;
	char const *codeptr;
	PNVMTupleHead *vars;
	unsigned int paramN;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(name,'PNVMStringHead'));
	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(params,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	tmpl = pnvmNetInstTemplate(inst);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,("executeDownlink: ", asPlainString(name)), " on: (instance of "), asPlainString(pnvmTemplateName(tmpl))), ") withParameters:lastAttempt:history:"));
	if (((codeptr = findUplinkin(name, tmpl))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,(,("failed to find uplink ", asPlainString(name)), " in template "), dereference(tmpl)));
		return 0;
	}

	/* (U */
	/* this also skips parameters */

	codeptr = (codeptr + 2) + (pnvmValueItemCount(name));
	paramN = codeGetVariableCount(codeptr);
	if (paramN != (pnvmValueItemCount(params))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("number of parameters does not match for uplink ", asPlainString(name)));
		return 0;
	}
	if (((vars = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple for variables");
		return 0;
	}
	vi = pnvmValueIterator(vars);
	pi = pnvmValueIterator(params);
	while (!(pnvmIterAtEnd(pi))) {
		pnvmIterWrite(vi, pnvmIterNext(pi));
	}
	changeBlockSizeOfto(vars, (codeGetVariableCount(codeptr)) + paramN);
	if ((satisfied = executeTransitionElementsAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) {

		/* first remove the assignments to temporary variables from history */

		clearVariableAssignments(history);
		pnvmIterSeekStart(vi);
		pnvmIterSeekStart(pi);
		while (!(pnvmIterAtEnd(pi))) {

			/* write variables to free parameters */

			if (!(pnvmTokenIsValid(pnvmIterValue(pi)))) {
				pnvmIterSetItem(pi, pnvmIterValue(vi));
			}
			pnvmIterNext(pi);
			pnvmIterNext(vi);
		}
	}
	pnvmValueDelete(vars);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,("leaving executeDownlink: ", asPlainString(name)), " on: (instance of "), dereference(tmpl)), ") withParameters:lastAttempt:history: (success="), satisfied), ")"));
	return satisfied;
}


/*	
	This executes $D element of transition code.
	Expected format of code (D <uplinkNameNullTerminated> <receiver>
		<paramCount> <param-0> <param-1> ... <param-(paramCount - 1)>).
	
	:param codeptr points after the $D elem.
	:param lastAttempt must point to the end upon the first invocation.
		If invocation succeeds, it will contain new array of attempts for uplink's transition code.
	 */

static bool executeDownlinkAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
	PNVMTupleHead *mapping;
	PNVMArrayHead *nestedAttempts;
	PNVMTupleIter pi;
	PNVMTupleIter vi;
	PNVMStringHead *name;
	PNVMNetInstHead *receiver;
	sqInt paramCount;
	PNVMTupleIter mi;
	PNVMTupleHead *params;
	PNVMToken tmp;
	bool satisfied;
	PNVMArrayIter nli;
	PNVMToken param;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering executeDownlinkAt:on:withVariables:lastAttempt:history:");

	/* skips name including 0 */

	tmpl = pnvmNetInstTemplate(inst);
	if (((name = parseCString(codeptr))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to parse name of net template");
		return 0;
	}
	vi = pnvmValueIterator(vars);
	pnvmIterSeek(vi, memLoadShort(codeptr));
	if (!((pnvmTokenType(pnvmIterValue(vi))) == TokenTypeNetRef)) {

		/* variable must be instance */

		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "expected net instance in variable");
		pnvmValueDelete(name);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeDownlinkAt:on:withVariables:lastAttempt:history: with failure");
		return 0;
	}
	receiver = pnvmTokenNetRef(pnvmIterValue(vi));
	*codeptr++;
	*codeptr++;
	if (((mapping = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocated tuple for parameters mapping");
		return 0;
	}
	mi = pnvmValueIterator(mapping);
	if (((params = pnvmTupleNew(PNVMTupleHead))) == null) {
		pnvmValueDelete(mapping);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocated tuple for downlink parameters");
		return 0;
	}
	pi = pnvmValueIterator(params);
	paramCount = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	tmp = pnvmNewToken(PNVMToken);
	while (paramCount > 0) {
		param = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
		if (((codeptr - 3)[0]) == (((sqInt)'V'))) {

			/* write index of previous variable to mapping for later reassignment */

			pnvmTokenSetInteger(tmp, memLoadShort(codeptr - 2));
			pnvmIterWrite(mi, tmp);
		} else {

			/* not a variable - do not assign to it on binding */

			pnvmTokenMakeInvalid(tmp);
			pnvmIterWrite(mi, tmp);
		}
		pnvmIterWrite(pi, param);
		pnvmTokenMakeInvalid(param);
		paramCount -= 1;
	}
	*codeptr++;
	if (pnvmIterAtEnd(lastAttempt)) {

		/* first attempt to execute downlink; let's create new storage for attempts */

		if (((nestedAttempts = pnvmArrayNew(PNVMArrayHead))) == null) {
			pnvmValueDelete(params);
			pnvmValueDelete(mapping);
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocated array for downlink's last attempts");
			return 0;
		}
		tmp = pnvmNewPointer(PNVMToken, nestedAttempts);
		pnvmIterWrite(lastAttempt, tmp);
		pnvmTokenMakeInvalid(tmp);
	} else {
		assert((pnvmTokenType(pnvmIterValue(lastAttempt))) == TokenTypePointer);
		assert(interpreterProxy->isKindOf((pnvmTokenPointer(pnvmIterValue(lastAttempt))),'PNVMTupleHead'));
		nestedAttempts = ((PNVMArrayHead *) (pnvmTokenPointer(pnvmIterValue(lastAttempt))));
	}
	nli = pnvmValueIterator(nestedAttempts);
	satisfied = executeDownlinkonwithParameterslastAttempthistory(name, receiver, params, nli, history);
	pnvmValueDelete(name);
	if (!(satisfied)) {
		pnvmValueDelete(params);
		pnvmValueDelete(mapping);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeDownlinkAt:on:withVariables:lastAttempt:history: with failure");
		return 0;
	}
	bindVariableswithParamsmappinghistory(vars, params, mapping, history);
	pnvmValueDelete(params);
	pnvmValueDelete(mapping);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeDownlinkAt:on:withVariables:lastAttempt:history: with success");
	return 1;
}


/*	
	Execute one transition element on instance. This should only be called from:
		executeTransitionElementsAt:on:withVariables:lastAttempt:history:
	
	:param: lastAttempt: is an iterator to attempts of execution. If it points at the end of
		array, we know that this is the first time we are invoked. So the first attempt is made.
		Otherwise the iterator points at the information we left there last time we were called.
		It represents attempt from which we should continue in search for some other variable
		binding.
		
		If there are more options to execute this element, we store information about current
		attempt made at the current position of iterator.
	:param: history: will be extended for any actions modifying interpreter state.
		We don't care about cleaning/restoring it here. That's taken care of by parent function.
	
	Return true, if the element has been executed successfully.
	 */

static bool executeOneTransitionElementAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
	PNVMToken tmp;
	char elem;
	char const *i;
	bool satisfied;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert((codeptr[0]) == (((sqInt)'(')));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering executeOneTransitionElementAt:on:withVariables:lastAttempt:history:");
	elem = codeptr[1];
	;
	if ((elem == 'G') || (elem == 'A')) {

		/* recursively process guard or action expression - just one way to do it */

		tmp = pnvmNewToken(PNVMToken);
		i = codeptr + 2;
		satisfied = evaluateExpressionAtontowithVariableshistory(i, inst, tmp, vars, history);
		codeStoreOffsettoRef(i + 1, codeptr);

		/* release the result of expression if any */

		satisfied = satisfied && ((elem != 'G') || (evalIsTrue(tmp)));
		pnvmTokenMakeInvalid(tmp);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,(,(,("leaving executeOneTransitionElementAt:on:withVariables:lastAttempt:history: ", " (success="), satisfied), ")"));
		return satisfied;
	}
	*codeptr++;
	*codeptr++;
	if (elem == 'D') {
		return executeDownlinkAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history);
	}
	if (elem == 'P') {
		return executeTakeTokenAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history);
	}
	if (elem == 'O') {
		return executePutTokenAtonwithVariableshistory(codeptr, inst, vars, history);
	}
	if (elem == 'Y') {
		return executeSchedulePutAtonwithVariableshistory(codeptr, inst, vars, history);
	}
	dieWithmsgwith(ErrorExecutionUnhandledTransitionElement, "unhandled code element: ", elem);
	return 0;
}


/*	
	Put amount of tokens to place (O <placeId> <amount> {V,S,I} <value>).
	There is just one way to do it -> no need for another attempts.
	
	:param codePos points after the $O elem.
	 */

static bool executePutTokenAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history) {
	PNVMTupleIter ai;
	PNVMTupleHead *action;
	PNVMToken tmp;
	PNVMToken value;
	sqInt placeId;
	sqInt amount;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert((codeptr[-1]) == (((sqInt)'O')));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering executePutTokenAt:on:withVariables:history:");
	tmpl = pnvmNetInstTemplate(inst);
	placeId = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	amount = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	value = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
	if (!(pnvmTokenIsValid(value))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "attempt to write free variable to place");
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executePutTokenAt:on:withVariables:history: with failure");
		return 0;
	}
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
		return 0;
	}
	ai = pnvmValueIterator(action);
	tmp = pnvmNewInteger(PNVMToken, ((sqInt)'O'));
	pnvmIterWrite(ai, tmp);
	tmp = pnvmNewNetRef(PNVMToken, inst);
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, placeId);
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, amount);
	pnvmIterWrite(ai, tmp);
	pnvmIterWrite(ai, value);
	appendActiontoHistoryWith(action, history);
	putNtokenstoPlaceofNetInst(amount, value, placeId, inst);
	pnvmTokenMakeInvalid(value);
	*codeptr++;
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executePutTokenAt:on:withVariables:history: with success");
	return 1;
}


/*	
	Delay the insertion of <amount> tokens to place.
	Expected code format:(Y <placeId> <amount> {V,S,I} <value> <time>).
	There is just one way to do it -> no need for more attempts.
	
	:param codePos points after the $Y elem.
	 */

static bool executeSchedulePutAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history) {
	PNVMTupleIter ai;
	PNVMTupleHead *action;
	PNVMToken tmp;
	PNVMToken value;
	sqInt placeId;
	sqInt amount;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert((codeptr[-1]) == (((sqInt)'Y')));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering executeSchedulePutAt:on:withVariables:history:");
	tmpl = pnvmNetInstTemplate(inst);
	placeId = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	amount = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	value = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
	if (!(pnvmTokenIsValid(value))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "attempt to write free variable to place");
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeSchedulePutAt:on:withVariables:history: with failure");
		return 0;
	}
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
		return 0;
	}
	ai = pnvmValueIterator(action);
	tmp = pnvmNewInteger(PNVMToken, ((sqInt)'Y'));
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetPointer(tmp, calScheduletimestoPlaceofInstat(value, amount, placeId, inst, (memLoadLong(codeptr)) + currentTime));
	if (!(pnvmTokenIsValid(tmp))) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to schedule event");
		pnvmValueDelete(action);
		return 0;
	}
	pnvmIterWrite(ai, tmp);
	pnvmTokenMakeInvalid(tmp);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,(,(,("scheduled insertion of ", amount), " of tokens "), value), " to place "), placeId), " of instance "), inst), " at time: "), memLoadLong(codeptr)));
	appendActiontoHistoryWith(action, history);
	codeStoreOffsettoRef(codeptr + 5, codeptr);
	pnvmTokenMakeInvalid(value);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeSchedulePutAt:on:withVariables:history: with success");
	return 1;
}


/*	
	Remove amount of tokens from place (P <placeId> <amount> {V,SI} <value>).
	There is many ways to select a token (number of items in place).
	
	:param codePos points after the $P elem.
	 */

static bool executeTakeTokenAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
	PNVMPlaceIter pi;
	PNVMPlaceHead *place;
	PNVMTupleIter vi;
	PNVMTupleIter ai;
	PNVMNetInstIter ni;
	PNVMTupleHead *action;
	sqInt attempt;
	sqInt valueId;
	PNVMToken tmp;
	PNVMToken value;
	sqInt placeId;
	unsigned int amount;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator'));
	assert((codeptr[-1]) == (((sqInt)'P')));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering executeTakeTokenAt:on:withVariables:lastAttempt:history:");
	tmpl = pnvmNetInstTemplate(inst);
	placeId = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	amount = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	value = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
	ni = pnvmValueIterator(inst);
	pnvmIterSeek(ni, placeId);
	place = pnvmIterValue(ni);
	pi = pnvmValueIterator(place);
	attempt = 0;
	if (!(pnvmIterAtEnd(lastAttempt))) {
		unlessdieWithmsgwith((pnvmTokenType(pnvmIterValue(lastAttempt))) == TokenTypeInteger, ErrorExecutionUnspecified, "unexpected last attempt: ", pnvmIterValue(lastAttempt));
		attempt = (pnvmTokenInteger(pnvmIterValue(lastAttempt))) + 1;
	}
	if ((((unsigned int) attempt)) >= (pnvmValueItemCount(pnvmIterHeaderBlock(pi)))) {
		pnvmTokenMakeInvalid(value);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,("leaving executeTakeTokenAt:on:withVariables:lastAttempt:history:", " with failure (no more items to try)"));
		return 0;
	}
	tmp = pnvmNewInteger(PNVMToken, attempt);
	pnvmIterWrite(lastAttempt, tmp);
	pnvmIterSeek(pi, attempt);
	if ((pnvmPlaceItemNumber(pnvmIterValue(pi))) < amount) {

		/* required amount of tokens not present */

		pnvmTokenMakeInvalid(value);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,("leaving executeTakeTokenAt:on:withVariables:lastAttempt:history:", " with failure (required amount of tokens not present)"));
		return 0;
	}
	if ((pnvmTokenIsValid(value)) && ((cmpTokenwith(value, pnvmPlaceItemToken(pnvmIterValue(pi)))) != 0)) {

		/* token must match precise value given by code */

		pnvmTokenMakeInvalid(value);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,("leaving executeTakeTokenAt:on:withVariables:lastAttempt:history:", " with failure (token must match precise value given by code)"));
		return 0;
	}
	if (!(pnvmTokenIsValid(value))) {

		/* store the token in vars */

		valueId = memLoadShort(codeptr - 2);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("storing token ", pnvmPlaceItemToken(pnvmIterValue(pi))), " in variable "), valueId));
		vi = pnvmValueIterator(vars);
		pnvmIterSeek(vi, valueId);
		if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
			return 0;
		}
		ai = pnvmValueIterator(action);
		pnvmTokenSetInteger(tmp, ((sqInt)':'));
		pnvmIterWrite(ai, tmp);
		pnvmTokenSetInteger(tmp, valueId);
		pnvmIterWrite(ai, tmp);
		appendActiontoHistoryWith(action, history);
		pnvmIterWrite(vi, pnvmPlaceItemToken(pnvmIterValue(pi)));
	}
	if (((action = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store history action");
		return 0;
	}
	ai = pnvmValueIterator(action);
	pnvmTokenSetInteger(tmp, ((sqInt)'P'));
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetNetRef(tmp, inst);
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, placeId);
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, pnvmIterIndex(pi));
	pnvmIterWrite(ai, tmp);
	pnvmTokenSetInteger(tmp, amount);
	pnvmIterWrite(ai, tmp);
	pnvmIterWrite(ai, pnvmPlaceItemToken(pnvmIterValue(pi)));
	appendActiontoHistoryWith(action, history);
	if (((pnvmPlaceItemNumber(pnvmIterValue(pi))) - amount) == 0) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,("removing ", amount), " of tokens "), pnvmPlaceItemToken(pnvmIterValue(pi))), " from place "), placeId), " of instance "), dereference(inst)));
		removeItemFromBlockAt(pnvmIterAsItemIterator(pi));
	} else {
		pnvmPlaceItemDecBy(pnvmIterValue(pi), amount);
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,(,(,("decreased number of tokens ", pnvmPlaceItemToken(pnvmIterValue(pi))), " from place "), placeId), " of instance "), inst), " by "), amount), " to "), pnvmPlaceItemNumber(pnvmIterValue(pi))));
	}
	pnvmTokenMakeInvalid(value);
	*codeptr++;
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeTakeTokenAt:on:withVariables:lastAttempt:history: with success");
	return 1;
}


/*	
	This is a recursive function executing transition elements. Function executes one transition
	element and if it is successful, it nests a level down.
	This is done rerursevely until all transition elements are finished.
	
	Check for transition elements end is at the beggining of function.
	
	Main principle
	=========
	If the executed transition and all of the following were executed successfully do the following:
		1.	Keep the lastAttemps, which may or may not be changed by nested execution.
			We may be called again by our parent to continue from the last attempt in finding
			next possible variable binding.
		2.	Keep the history. History will be cleared by invoker if the whole transition is successful.
		3.	Return true.
	If the first transition (the one at our level) fails:
		1.	There are no other options left, so let's delete lastAttempts from our position
			(the position in array of attempts we have been given). Parent may try to call
			us with different variables binded, so we may make some more attempts in
			the future from the same position in attempts array.
		2.	Restore history from our position to state before we were called.
		3.	Return false.
	If the first transition succeeds, be the nested ones don't:
		1.	Let's restore history from our position, before calling first transition again.
		2.	If there are more attempts to try in the first transition, let's call it again and
			nest down once more with different binding. We know, that there are more
			attempts to try if the first transition shifted lastAttempt iterator.
		3.	Repeat 1. and 2. until either first transition fails -> no more attemts to try, or
			nested execution succeeds.
	 */

static bool executeTransitionElementsAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
	char const *codeptrBackup;
	sqInt lastAttemptOrigPos;
	sqInt attemptsToTry;
	sqInt historyOrigPos;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(history,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator'));
	assert(charisOneOf(codeptr[0], "()"));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering executeTransitionElementsAt:on:withVariables:lastAttempt:history:");
	if ((codeptr[0]) == (((sqInt)')'))) {

		/* we have reached the end of elements; transition is complete */

		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,("leaving executeTransitionElementsAt:on:withVariables:lastAttempt:history:", " with success (no more transition elements)"));
		return 1;
	}
	historyOrigPos = pnvmIterIndex(history);
	lastAttemptOrigPos = pnvmIterIndex(lastAttempt);
	attemptsToTry = 1;
	codeptrBackup = codeptr + 0;
	while (attemptsToTry) {

		/* restore position of last attempt iterator */

		pnvmIterSeek(lastAttempt, lastAttemptOrigPos);
		if (((attemptsToTry = executeOneTransitionElementAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) && (executeTransitionElementsAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) {

			/* transition has been successfuly completed, caller should clean up the history */

			categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeTransitionElementsAt:on:withVariables:lastAttempt:history: with success");
			return 1;
		}
		attemptsToTry = attemptsToTry && ((pnvmIterIndex(lastAttempt)) > lastAttemptOrigPos);
		codeStoreOffsettoRef(codeptrBackup, codeptr);
		pnvmIterSeek(history, historyOrigPos);
		restoreHistoryFromPoswithVariables(history, vars);
	}
	pnvmIterSeek(lastAttempt, lastAttemptOrigPos);
	cleanLastAttemptsFromPos(lastAttempt);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving executeTransitionElementsAt:on:withVariables:lastAttempt:history: with failure");
	return 0;
}


/*	
	Can be called to check, whether the serious error occured.
	
	Return Boolean.
	 */

EXPORT(bool) failed(void) {
	return error != ErrorSuccess;
}


/*	
	Shifts code lying after the hole created by removal of some net template.
	If holes were allowed, free memory would get soon fragmented.
	Returns new code length.
	 */

static sqInt fillCodeHoles(void) {
	sqInt i;
	PNVMTemplate *tmpl;
	sqInt ci;
	sqInt index;
	sqInt codeSize;
	sqInt ciLimiT;

	index = 0;
	codeSize = 0;
	for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
		tmpl = netTemplateTable[index];
		if (codeSize < (pnvmTemplateCodeOffset(tmpl))) {
			pnvmTemplateSetTransitions(tmpl, codeSize + ((pnvmTemplateTransitions(tmpl)) - (pnvmTemplateCodeOffset(tmpl))));
			for (ci = 0, ciLimiT = ((pnvmTemplateCodeLength(tmpl)) - 1); ci <= ciLimiT; ci += 1) {
				netTemplateCode[codeSize] = (netTemplateCode[(pnvmTemplateCodeOffset(tmpl)) + ci]);
				codeSize += 1;
			}
			pnvmTemplateSetCodeOffset(tmpl, codeSize - (pnvmTemplateCodeLength(tmpl)));
		} else {
			codeSize += pnvmTemplateCodeLength(tmpl);
		}
		index += 1;
		while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == null)) {
			index += 1;
		}
	}
	return codeSize;
}

static PNVMTemplate * findNetTemplate(PNVMStringHead const *name) {
	sqInt i;
	sqInt index;

	index = 0;
	for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
		if ((cmpStringwith(name, pnvmTemplateName(netTemplateTable[index]))) == 0) {
			return netTemplateTable[i];
		}
		index += 1;
		while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == null)) {
			index += 1;
		}
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("failed to find template: ", asPlainString(name)));
	return null;
}


/*	
	Try to find uplink in net template code.
	Uplink is searched by its name.
	
	If uplink is found, return pointer pointing at the opening bracket just before $U.
	Otherwise nil is returned.
	 */

static char const * findUplinkin(PNVMStringHead const *name, PNVMTemplate const *tmpl) {
	PNVMStringHead *tmp;
	PNVMStringIter o;
	char const *uplinkStart;
	char const *codeptr;

	assert(interpreterProxy->isKindOf(name,'PNVMStringHead'));
	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	if (((tmp = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate temporary string for uplink name");
		return null;
	}
	o = pnvmValueIterator(tmp);
	codeptr = getCodeIteratorAt((pnvmTemplateCodeOffset(tmpl)) + 2);
	while ((codeptr[0]) == (((sqInt)'('))) {

		/* save the position for later return */

		uplinkStart = codeptr + 0;
		*codeptr++;
		if (!((codeptr[0]) == (((sqInt)'U')))) {
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,(,("failed to find uplink ", asPlainString(name)), " in template "), dereference(tmpl)));
			pnvmValueDelete(tmp);
			return null;
		}
		*codeptr++;
		pnvmIterSeekStart(o);
		while (!((codeptr[0]) == (((sqInt)'(')))) {
			pnvmIterWrite(o, *codeptr++);
		}
		if ((cmpStringwith(name, tmp)) == 0) {

			/* success, the uplink is found */

			pnvmValueDelete(tmp);
			return uplinkStart;
		}
		codeSeekSkipVariables(codeptr);
		codeSeekSkipVariables(codeptr);
		codeSeekSkipTransitionElements(codeptr);
		assert((codeptr[0]) == (((sqInt)')')));
		*codeptr++;
		changeBlockSizeOfto(tmp, 0);
	}
	assert((codeptr[0]) == (((sqInt)')')));
	*codeptr++;
	pnvmValueDelete(tmp);
	return null;
}

static char * getCodeIteratorAt(sqInt pos) {
	return &netTemplateCode[pos];
}

static CodeLength_t getCodeSize(void) {
	sqInt i;
	PNVMTemplate const *tmpl;
	sqInt index;
	CodeLength_t size;

	size = 0;
	index = 0;
	for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
		tmpl = netTemplateTable[index];
		if (((pnvmTemplateCodeOffset(tmpl)) + (pnvmTemplateCodeLength(tmpl))) > size) {
			size = (pnvmTemplateCodeOffset(tmpl)) + (pnvmTemplateCodeLength(tmpl));
		}
		index += 1;
		while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == null)) {
			index += 1;
		}
	}
	return size;
}


/*	
	Return error flag. setError: shall be used to set it. Errors are defined in PNVMConstants >> initialize class method.
	Their text description can be obtained with strError:.
	 */

EXPORT(Error_t) getError(void) {
	return error;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*) getModuleName(void) {
	return moduleName;
}


/*	
	Returns token depending on value kind determined by char on codePos followed by index.
	First character can be:
		S - symbol of net template
		I - integer constant
		V - in case of free variable it returns invalid token;
			otherwise variable from vars indexed by following number is returned

	:param codeptr points to the first character (C, I, V).
		After the execution it's shifted behind last character read.
	 */

static PNVMToken getTokenForValueOnPosinTemplatewithVariables(char const * & codeptr, PNVMTemplate const *tmpl, PNVMTupleHead *vars) {
	unsigned short valueId;
	PNVMTupleIter ti;

	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	assert(interpreterProxy->isKindOf(codeptr,'CArrayAccessor'));
	assert(charisOneOf(codeptr[0], "SIV"));
	*codeptr++;
	valueId = memLoadShort(codeptr);
	*codeptr++;
	*codeptr++;
	if ((codeptr[-3]) == (((sqInt)'S'))) {

		/* template symbol */

		ti = pnvmValueIterator(((PNVMTupleHead *) (pnvmTemplateSymbols(tmpl))));
		pnvmIterSeek(ti, valueId);
		return pnvmTokenClone(pnvmIterValue(ti));
	} else {
		if ((codeptr[-3]) == (((sqInt)'I'))) {

			/* constant integer value */

			return pnvmNewInteger(PNVMToken, ((short) valueId));
		} else {

			/* variable (free or used) */

			ti = pnvmValueIterator(vars);
			pnvmIterSeek(ti, valueId);
			return pnvmTokenClone(pnvmIterValue(ti));
		}
	}
}

static sqInt halt(void) {
	;
}

EXPORT(void) initializeModule(void) {
	initializeOMModule();
	;
	inputBuffer = pnvmArrayNew(PNVMArrayHead);

	/* time of current event in unix time in milliseconds */

	outputBuffer = pnvmArrayNew(PNVMArrayHead);
	updateTime();
	nothingChanged = 0;
	stepCounter = 0;
}

static Error_t initializeNetInstance(PNVMNetInstHead *inst) {
	PNVMTupleHead *vars;
	PNVMTemplate *tmpl;
	PNVMArrayHead *arrtmp;
	PNVMArrayIter lastAttempt;
	char const *codeptr;
	PNVMArrayIter history;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering initializeNetInstance:");
	tmpl = pnvmNetInstTemplate(inst);

	/* find initialization transition */

	codeptr = getCodeIteratorAt((pnvmTemplateCodeOffset(tmpl)) + 2);
	while (!((codeptr[0]) == (((sqInt)'(')))) {
		*codeptr++;
	}
	while (!((codeptr[1]) == (((sqInt)'I')))) {
		codeSeekSkipTransition(codeptr);
	}
	assert((codeptr[0]) == (((sqInt)'(')));
	*codeptr++;
	*codeptr++;
	if (((vars = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate variables");
		return setError(ErrorNoMemory);
	}
	if (((arrtmp = pnvmArrayNew(PNVMArrayHead))) == null) {
		pnvmValueDelete(vars);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate array for history");
		return setError(ErrorNoMemory);
	}
	history = pnvmValueIterator(arrtmp);
	if (((arrtmp = pnvmArrayNew(PNVMArrayHead))) == null) {
		pnvmValueDelete(vars);
		pnvmValueDelete(pnvmIterHeaderBlock(history));
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate array for lastAttempt");
		return setError(ErrorNoMemory);
	}
	lastAttempt = pnvmValueIterator(arrtmp);
	if (!(executeTransitionElementsAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) {
		dieWithmsgwith(ErrorInitFailed, "failed to run initialization code for template: ", dereference(tmpl));
	}
	pnvmValueDelete(vars);
	pnvmValueDelete(pnvmIterHeaderBlock(history));
	pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving initializeNetInstance:");
	return error;
}


/*	object memory contains net instances */

EXPORT(void) initializeOMModule(void) {
	;
	codeWithHoles = 0;
	numberOfNetTemplates = 0;
	calendarHead = null;
	calendarTail = null;
	error = ErrorSuccess;
}


/*	
	Append token to input buffer for interpreter to handle.

	:param message is a serialized token.
	
	Return true if token has been correctly parsed and enqueued.
	 */

static bool inputMessage(char const *message) {
	PNVMStringHead *tmp;
	PNVMArrayIter i;
	PNVMToken parsedToken;

	categorylevelmessage(LoggingEvent, "pnvmInOut", "info", ,(,("incoming: '", message), "'"));
	i = pnvmValueIterator(inputBuffer);
	pnvmIterSeekEnd(i);
	tmp = cstrToString(message);
	if (tmp == null) {
		categorylevelmessage(LoggingEvent, "pnvmInOut", "error", "failed to convert cstr to string");
		return 0;
	}
	parsedToken = parseToken(tmp);
	if (!(pnvmTokenIsValid(parsedToken))) {
		pnvmValueDelete(tmp);
		return 0;
	}
	pnvmIterWrite(i, parsedToken);
	pnvmValueDelete(tmp);
	pnvmTokenMakeInvalid(parsedToken);
	return 1;
}


/*	
	Step of input/output subsystem. 
	If input packet received from serial input is complete,
	it attempts to invoke input uplink of first net instance in PNVM.
	It also attempts to invoke output uplink of the main net and if it successes,
	it starts to process serial output.
	 */

static Error_t inputOutput(void) {
	PNVMArrayIter ibi;
	PNVMTupleHead *params;
	PNVMArrayHead *arrtmp;
	PNVMStringHead *name;
	PNVMTupleIter pi;
	PNVMArrayIter lastAttempt;
	PNVMNetInstHead *inst;
	PNVMArrayIter history;

	assert(numberOfNetTemplates > 0);
	assert((pnvmTemplateInstances(netTemplateTable[0])) != null);
	assert((pnvmValueItemCount(pnvmTemplateInstances(netTemplateTable[0]))) > 0);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering inputOutput");
	inst = pnvmTokenNetRef((dereference(pnvmTemplateInstances(netTemplateTable[0])))[0]);
	params = pnvmTupleNew(PNVMTupleHead);
	if (params == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate allocate tuple for parameters");
		return setError(ErrorNoMemory);
	}
	changeBlockSizeOfto(params, 1);
	pi = pnvmValueIterator(params);
	if (((arrtmp = pnvmArrayNew(PNVMArrayHead))) == null) {
		pnvmValueDelete(params);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate temporary array for last attempts");
		return setError(ErrorNoMemory);
	}
	lastAttempt = pnvmValueIterator(arrtmp);
	if (((arrtmp = pnvmArrayNew(PNVMArrayHead))) == null) {
		pnvmValueDelete(params);
		pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate temporary array for history");
		return setError(ErrorNoMemory);
	}
	history = pnvmValueIterator(arrtmp);
	name = cstrToString("input");
	if (name == null) {
		pnvmValueDelete(params);
		pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		pnvmValueDelete(pnvmIterHeaderBlock(history));
		return setError(ErrorNoMemory);
	}

	/* for all items in input buffer execute input downlink */

	ibi = pnvmValueIterator(inputBuffer);
	while (!((pnvmIterAtEnd(ibi)) || (error != ErrorSuccess))) {

		/* assign the input token to the first and only parameter */

		pnvmIterSetItem(pi, pnvmIterValue(ibi));
		categorylevelmessage(LoggingEvent, "pnvmInOut", "info", ,("inputOutput - calling input downlink on token ", pnvmIterValue(ibi)));
		if (executeDownlinkonwithParameterslastAttempthistory(name, inst, params, lastAttempt, history)) {

			/* downlink successful */

			removeItemFromBlockAt(pnvmIterAsItemIterator(ibi));
			nothingChanged = 0;
		} else {

			/* check, whether called functions did clean up properly */

			unlessdieWithmsg((pnvmIterAtEnd(lastAttempt)) && (pnvmIterAtStart(lastAttempt)), ErrorExecutionUnspecified, "lastAttempts must be cleared for failed transition");
			unlessdieWithmsg((pnvmIterAtEnd(history)) && (pnvmIterAtStart(history)), ErrorExecutionUnspecified, "history must be cleared for failed transition");
			pnvmIterNext(ibi);
		}
		pnvmTokenMakeInvalid(pnvmIterValue(pi));
		pnvmIterSeekStart(history);
		changeBlockSizeOfto(pnvmIterHeaderBlock(history), 0);
		pnvmIterSeekStart(lastAttempt);
		changeBlockSizeOfto(pnvmIterHeaderBlock(lastAttempt), 0);
	}
	pnvmValueDelete(name);
	if (error != ErrorSuccess) {
		pnvmValueDelete(params);
		pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		pnvmValueDelete(pnvmIterHeaderBlock(history));
		return error;
	}
	name = cstrToString("output");
	if (name == null) {
		pnvmValueDelete(params);
		pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		pnvmValueDelete(pnvmIterHeaderBlock(history));
		return setError(ErrorNoMemory);
	}
	if (executeDownlinkonwithParameterslastAttempthistory(name, inst, params, lastAttempt, history)) {

		/* output uplink may have empty body */

		if (pnvmTokenIsValid(pnvmIterValue(pi))) {
			categorylevelmessage(LoggingEvent, "pnvmInOut", "info", ,("inputOutput - output downlink produced a value ", pnvmIterValue(pi)));
			outputValue(pnvmIterValue(pi));
			nothingChanged = 0;
		}
	} else {
		unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(lastAttempt))) == 0, ErrorExecutionUnspecified, "lastAttempts must be cleared for failed transition");
		unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(history))) == 0, ErrorExecutionUnspecified, "history must be cleared for failed transition");
	}
	pnvmValueDelete(name);
	pnvmValueDelete(pnvmIterHeaderBlock(history));
	pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
	pnvmValueDelete(params);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving inputOutput");
	return error;
}


/*	
	Append token to input buffer for interpreter to handle.

	:param message is a serialized token given as String.
	
	Return true if token has been correctly parsed and enqueued.
	 */

EXPORT(bool) inputString(PNVMStringHead *message) {
	PNVMArrayIter i;
	PNVMToken parsedToken;

	assert(interpreterProxy->isKindOf(message,'PNVMStringHead'));
	categorylevelmessage(LoggingEvent, "pnvmInOut", "info", ,(,("incoming: '", asPlainString(message)), "'"));
	i = pnvmValueIterator(inputBuffer);
	pnvmIterSeekEnd(i);
	parsedToken = parseToken(message);
	if (!(pnvmTokenIsValid(parsedToken))) {
		categorylevelmessage(LoggingEvent, "pnvmInOut", "error", "failed to parse input message");
		return 0;
	}
	pnvmIterWrite(i, parsedToken);
	pnvmTokenMakeInvalid(parsedToken);
	return 1;
}


/*	
	This should be used for the first instantiation of the first net template.
	Return instance.
	
	:param tmplId: Index of template in netTemplateTable.
	 */

static PNVMNetInstHead * instantiateTemplate(sqInt tmplId) {
	PNVMNetInstHead *inst;
	PNVMToken token;

	token = createNetInstanceFrom(netTemplateTable[tmplId]);
	inst = pnvmTokenNetRef(token);
	initializeNetInstance(inst);
	pnvmTokenMakeInvalid(token);
	return inst;
}


/*	
	This should be used for the first net template (platform).
	
	:param code is plain c-string
	
	Return template id.
	 */

static sqInt loadNetTemplate(char const *  code) {
	PNVMStringIter iter;
	PNVMTemplate *tmpl;
	PNVMStringHead *str;

	assert(interpreterProxy->isKindOf(code,'CArrayAccessor'));
	assert(interpreterProxy->isKindOf((object(code)),'String'));
	str = cstrToString(code);
	if (str == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate temporary string for net template code");
		return -1;
	}
	iter = pnvmValueIterator(str);
	tmpl = parseNetTemplate(iter);
	unlessdieWithmsg(tmpl != null, ErrorParsingTemplate, "failed to parse net template");
	if (tmpl == null) {
		return -1;
	}
	pnvmValueDelete(str);
	return appendNetTemplate(tmpl);
}


/*	
	Adds instance to the list of instances of template.
	Only this way it can be recognized by interpreter for its transitions to be executed.
	Interpreter iterates over all instances referenced by templates.
	
	There is one special net instance. The first instance of the first net template. It's reference
	count is set to 1 upon call to this function to ensure it's never released. Otherwise reference
	count is decreased by 1 for any other instance so that they can be garbage collected,
	when rc decreases	to zero.
		
	Return instance in PNVMToken.
	 */

static PNVMToken manageNetInstance(PNVMNetInstHead *inst) {
	PNVMArrayIter i;
	PNVMTemplate *tmpl;
	PNVMToken res;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	tmpl = pnvmNetInstTemplate(inst);
	if ((pnvmTemplateInstances(tmpl)) == null) {
		pnvmTemplateSetInstances(tmpl, pnvmArrayNew(PNVMArrayHead));
		if ((pnvmTemplateInstances(tmpl)) == null) {
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate array for template instances");
			return pnvmNewToken(PNVMToken);
		}
	}
	i = pnvmValueIterator(pnvmTemplateInstances(tmpl));
	res = pnvmNewNetRef(PNVMToken, inst);
	pnvmIterSeekEnd(i);
	pnvmIterWrite(i, res);
	if (!(((pnvmNetInstTemplate(inst)) == (netTemplateTable[0])) && ((pnvmValueItemCount(pnvmTemplateInstances(tmpl))) == 1))) {

		/* 
			Let's decrease reference count to ensure it's garbage collected, when template
			is the only referent..
			 */

		pnvmValueUnreference(inst);
	}
	return res;
}

static uint32_t memLoadLong(char const *mem) {
	uint32_t res;

	res = ((uint32_t) (((unsigned char) (mem[3]))));
	res = (res << 8) | (((uint32_t) (((unsigned char) (mem[2])))));
	res = (res << 8) | (((uint32_t) (((unsigned char) (mem[1])))));
	res = (res << 8) | (((uint32_t) (((unsigned char) (mem[0])))));
	return res;
}


/*	
	mem is an address to memory, where 2 bytes (s1, s0) are stored;
	where s1*256 + s0 = short value
	this returnes obtained value
	 */

static uint16_t memLoadShort(char const *mem) {
	uint16_t res;

	res = (mem[1]) * 256;
	res = res | (((uint16_t) (((unsigned char) (mem[0])))));
	return res;
}

static char * memStoreLongto(uint32_t value, char *mem) {
	uint32_t tmp;

	tmp = value;
	*(uint32_t *) mem = tmp;
	return mem + 4;
}


/*	
	mem is an address to memory, where 2 bytes (s1, s0) are to be stored;
	where s1*256 + s0 = value
	return position in memory after stored value
	 */

static char * memStoreShortto(uint16_t value, char *mem) {
	*(uint16_t *) mem = value;
	return mem + 2;
}


/*	
	Removes first inserted item in output buffer, makes a string object
	out of it and returns it.
	
	If error occurs, nil is returned.
	 */

static PNVMStringHead * outputPopMessage(void) {
	PNVMStringHead *tmp;
	PNVMArrayIter iter;
	PNVMStringIter o;

	unlessdieWithmsg(!((pnvmValueItemCount(outputBuffer)) == 0), ErrorOutputBufferEmpty, "can not pop message out of empty output buffer");
	if ((pnvmValueItemCount(outputBuffer)) == 0) {
		return null;
	}
	iter = pnvmValueIterator(outputBuffer);
	if (((tmp = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate temporary string for serialization of token");
		return null;
	}
	o = pnvmValueIterator(tmp);
	if ((serializeTokento(pnvmIterValue(iter), o)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmInOut", "error", "failed to serialize output token");
		setError(ErrorSerializationFailed);
		return null;
	}
	removeItemFromBlockAt(pnvmIterAsItemIterator(iter));
	return tmp;
}


/*	
	Appends token to output buffer.
	It will be sent to receiver in the next invocation of inputOutput.
	 */

static void outputValue(PNVMToken const & token) {
	PNVMArrayIter o;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	o = pnvmValueIterator(outputBuffer);
	pnvmIterSeekEnd(o);
	pnvmIterWrite(o, ((PNVMToken &) token));
}

static PNVMArrayHead * parseArrayallowNetInst(PNVMStringIter & i, sqInt allowNetInst) {
	PNVMItemIterator iter;
	PNVMArrayIter ai;
	PNVMArrayHead *res;

	assert(interpreterProxy->isKindOf(allowNetInst,'Boolean'));
	if (((res = pnvmArrayNew(PNVMArrayHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new array for parsed array");
		return null;
	}
	ai = pnvmValueIterator(res);
	iter = pnvmIterAsItemIterator(ai);
	if (!(parseCollectionstartingWithendingWithtoallowNetInst(i, '{', '}', iter, allowNetInst))) {
		pnvmValueDelete(res);
		setError(ErrorParsingCollection);
		return null;
	}
	return res;
}


/*	
	Parse null-terminated string.
	
	:param str gets shifter after null-terminating character
	 */

static PNVMStringHead * parseCString(char const * & str) {
	PNVMStringHead *res;
	PNVMStringIter o;

	assert(interpreterProxy->isKindOf(str,'CObjectAccessor'));
	if (((res = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate string for serialization of string object");
		return null;
	}
	o = pnvmValueIterator(res);
	while ((((sqInt)(str[0]))) > 0) {
		pnvmIterWrite(o, *str++);
	}
	*str++;
	return res;
}


/*	
	Parse transition elements of net template:
			(P <placeId>, <amount>, <value>)
		|	(G <expression>)
		|	(D <name>, <varid>, <variableids>)
		|	(A <expression>)
		|	(O <placeId>, <amount>, <value>)
	
	TODO: check range of variable ids
	 */

static sqInt parseCodeto(PNVMStringIter & i, char **outptr) {
	char *out;
	sqInt paramCount;
	char *paramPos;
	char **outacc;
	sqInt c;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;

	/* function ends on one of the statements inside of this loop */

	outacc = &out;
	while (1) {
		parseSkipBlanksuntilOneOf(i, "()");
		if (!((!(pnvmIterAtEnd(i))) && (((c = pnvmIterValue(i))) != ')'))) break;
		if ((parseSkipBlanksLBto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '('");
			setError(ErrorParsingTransitionCode);
			return -1;
		}
		out[0] = (((sqInt)((c = pnvmIterNext(i)))));
		*out++;
		if (c == 'P') {

			/* placeid */

			if ((parsePosIntegerto(i, outacc)) < 0) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse place id");
				setError(ErrorParsingTransitionCode);
				return -1;
			}
			if (!(parseSkipBlanksComma(i))) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
				setError(ErrorParsingTransitionCode);
				return -1;
			}
			if ((parsePosIntegerto(i, outacc)) < 0) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse number of tokens");
				setError(ErrorParsingTransitionCode);
				return -1;
			}
			if (!(parseSkipBlanksComma(i))) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
				setError(ErrorParsingTransitionCode);
				return -1;
			}
			if ((parseValueto(i, outacc)) < 0) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse token value");
				setError(ErrorParsingTransitionCode);
				return -1;
			}
		} else {

			/* guard function */

			if (c == 'G') {
				if ((parseExpressionto(i, outacc)) < 0) {
					categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse guard expression");
					setError(ErrorParsingTransitionCode);
					return -1;
				}
			} else {

				/* create net instance */

				if (c == 'C') {

					/* place id */

					if ((parsePosIntegerto(i, outacc)) < 0) {
						categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse place id");
						setError(ErrorParsingTransitionCode);
						return -1;
					}
					if ((parseExpressionto(i, outacc)) < 0) {
						categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse instance name expression");
						setError(ErrorParsingTransitionCode);
						return -1;
					}
				} else {

					/* downlink */

					if (c == 'D') {

						/* name of channel */

						if ((parseNameto(i, outacc)) < 0) {
							categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse downlink's name");
							setError(ErrorParsingTransitionCode);
							return -1;
						}
						if (!(parseSkipBlanksComma(i))) {
							categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
							setError(ErrorParsingTransitionCode);
							return -1;
						}
						out[0] = 0;
						*out++;
						parseSkipBlanks(i);
						if ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) == 'V')) {
							pnvmIterNext(i);
						}
						if ((parsePosIntegerto(i, outacc)) < 0) {
							categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse net instance variable id");
							setError(ErrorParsingTransitionCode);
							return -1;
						}
						paramCount = 0;
						paramPos = out;
						*out++;
						*out++;
						while ((parseSkipBlanksuntilOneOf(i, ",)")) && ((pnvmIterValue(i)) != ')')) {
							pnvmIterNext(i);
							parseSkipBlanks(i);
							if ((parseValueto(i, outacc)) < 0) {
								categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse variable id");
								setError(ErrorParsingTransitionCode);
								return -1;
							}
							paramCount += 1;
						}
						memStoreShortto(paramCount, paramPos);
						if ((pnvmIterAtEnd(i)) || ((pnvmIterValue(i)) != ')')) {
							categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ')'");
							setError(ErrorParsingTransitionCode);
							return -1;
						}
					} else {

						/* action, that must not fail */

						if (c == 'A') {
							if ((parseExpressionto(i, outacc)) < 0) {
								categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse action's expression");
								setError(ErrorParsingTransitionCode);
								return -1;
							}
						} else {

							/* store tokens in place */

							if (c == 'O') {

								/* place id */

								if ((parsePosIntegerto(i, outacc)) < 0) {
									categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse place id");
									setError(ErrorParsingTransitionCode);
									return -1;
								}
								if (!(parseSkipBlanksComma(i))) {
									categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
									setError(ErrorParsingTransitionCode);
									return -1;
								}
								if ((parsePosIntegerto(i, outacc)) < 0) {
									categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse number of tokens");
									setError(ErrorParsingTransitionCode);
									return -1;
								}
								if (!(parseSkipBlanksComma(i))) {
									categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
									setError(ErrorParsingTransitionCode);
									return -1;
								}
								if ((parseValueto(i, outacc)) < 0) {
									categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse token value");
									setError(ErrorParsingTransitionCode);
									return -1;
								}
							} else {

								/* schedule event, that will store tokens in place */

								if (c == 'Y') {

									/* placeid */

									if ((parsePosIntegerto(i, outacc)) < 0) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse place id");
										return -1;
									}
									if (!(parseSkipBlanksComma(i))) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
										setError(ErrorParsingTransitionCode);
										return -1;
									}
									if ((parsePosIntegerto(i, outacc)) < 0) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse number of tokens");
										setError(ErrorParsingTransitionCode);
										return -1;
									}
									if (!(parseSkipBlanksComma(i))) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
										setError(ErrorParsingTransitionCode);
										return -1;
									}
									if ((parseValueto(i, outacc)) < 0) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse token value");
										setError(ErrorParsingTransitionCode);
										return -1;
									}
									if (!(parseSkipBlanksComma(i))) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
										setError(ErrorParsingTransitionCode);
										return -1;
									}
									if ((parseLongIntegerto(i, outacc)) < 0) {
										categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse time");
										setError(ErrorParsingTransitionCode);
										return -1;
									}
								} else {

									/* unexpected type of symbol */

									setError(ErrorParsingTransitionCode);
									return -1;
								}
							}
						}
					}
				}
			}
		}
		if ((parseSkipBlanksRBto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ')'");
			setError(ErrorParsingTransitionCode);
			return -1;
		}
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static sqInt parseCollectionstartingWithendingWithtoallowNetInst(PNVMStringIter & i, sqInt start, sqInt end, PNVMItemIterator & o, sqInt allowNetInst) {
	PNVMToken symbol;
	sqInt expectItem;
	sqInt c;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(start,'Character'));
	assert(interpreterProxy->isKindOf(end,'Character'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(allowNetInst,'Boolean'));
	if (!(parseSkipBlanksexpecting(i, start))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,("expected ", start));
		setError(ErrorParsingCollection);
		return 0;
	}
	parseSkipBlanks(i);
	expectItem = 0;
	while ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) != end)) {
		symbol = parseSymbolallowNetInst(i, allowNetInst);
		if (!(pnvmTokenIsValid(symbol))) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse symbol");
			setError(ErrorParsingCollection);
			return 0;
		}
		writeValueItemat(makePointer(symbol), o);
		pnvmTokenMakeInvalid(symbol);
		parseSkipBlanks(i);
		if (!((charisOneOf(pnvmIterValue(i), ",/")) || ((pnvmIterValue(i)) == end))) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected one of separators");
			setError(ErrorParsingCollection);
			return 0;
		}
		c = pnvmIterValue(i);
		if ((c == ',') || (c == '/')) {
			pnvmIterNext(i);
			parseSkipBlanks(i);
			expectItem = 1;
		} else {
			expectItem = 0;
		}
	}
	if (expectItem) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected item");
		setError(ErrorParsingCollection);
		return 0;
	}
	if ((pnvmIterAtEnd(i)) || ((pnvmIterValue(i)) != end)) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,("expected ", end));
		setError(ErrorParsingCollection);
		return 0;
	}
	pnvmIterNext(i);
	return 1;
}


/*	
	Check, whether character on position 'i' matches expected 'character', and place it into output
	with 'outptr' iterator.
	 */

static sqInt parseExpCharfromto(sqInt character, PNVMStringIter & i, char **outptr) {
	char *out;

	if (!((pnvmIterNext(i)) == character)) {
		return -1;
	}
	out = *outptr;
	out[0] = (((sqInt)character));
	*out++;
	*outptr = out;
	return 1;
}


/*	
	Parse expression of transition elements G or A.
	It expects input iterator 'i' to point at opening bracket of expression.
	On function exit, this iterator will point after the closing bracket.
	
	:param outptr: points to object memory, where the parsed result will be stored
	 */

static sqInt parseExpressionto(PNVMStringIter & i, char **outptr) {
	sqInt j;
	char *out;
	sqInt numparams;
	char **outacc;
	sqInt c;

	out = *outptr;
	outacc = &out;
	if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '('");
		setError(ErrorParsingExpression);
		return -1;
	}
	parseSkipBlanks(i);
	numparams = -1;
	if ((((c = pnvmIterValue(i))) == 'I') || ((c == 'S') || (c == 'V'))) {
		if ((parseValueto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse variable");
			setError(ErrorParsingExpression);
			return -1;
		}
		numparams = 0;
	} else {
		pnvmIterNext(i);
		out[0] = (((sqInt)c));
		*out++;
		if (charisOneOf(c, "=<>&|^o:,+-*/%#a")) {
			numparams = 2;
		} else {

			/* parse unary operators */

			if (((c == '!') || ((c == 'p') || ((c == 'h') || ((c == 't') || (c == 'u'))))) || ((c == 'l') || ((c == 'c') || ((c == 's') || ((c == 'i') || (c == 'n')))))) {

				/* check whether it can be multicharacter operator */

				if (charisOneOf(c, "in")) {
					if (((c == 'i') && ((charisOneOf(pnvmIterValue(i), "isatnv(")) || (charIsBlank(pnvmIterValue(i))))) || ((c == 'n') && ((charisOneOf(pnvmIterValue(i), "sat(")) || (charIsBlank(pnvmIterValue(i)))))) {

						/* check, whether multicharacter operator is parameter-less */
						/* (c = $t and: [i pnvmIterValue = $i]) ifTrue: [numparams := 0]. */
						/* store one more character for 2-character operators */

						if (((c == 'i') && (charisOneOf(pnvmIterValue(i), "isatnv"))) || ((c == 'n') && (charisOneOf(pnvmIterValue(i), "sat")))) {
							out[0] = (((sqInt)(pnvmIterNext(i))));
							*out++;
							if (c == 'n') {
								numparams = 0;
							}
						}
					} else {
						categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "unknown multicharacter operator");
						setError(ErrorParsingExpression);
						return -1;
					}
				}
				if (numparams == -1) {
					numparams = 1;
				}
			} else {

				/* parse parameter-less operators */

				if (c == 'd') {

					/* dump */

					numparams = 0;
				} else {

					/* no matching operator found */

					categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,(,("not supported operator '", c), "' found"));
					setError(ErrorParsingExpression);
					return -1;
				}
			}
		}
	}
	assert(numparams >= 0);
	for (j = 1; j <= numparams; j += 1) {
		if ((parseExpressionto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,("failed to parse nested argument number ", j));
			setError(ErrorParsingExpression);
			return -1;
		}
	}
	if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ')'");
		setError(ErrorParsingExpression);
		return -1;
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static sqInt parseInitto(PNVMStringIter & i, char **outptr) {
	char *out;
	sqInt res;
	char **outacc;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	outacc = &out;
	if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected (");
		setError(ErrorParsingInit);
		return -1;
	}
	if ((parseExpCharfromto('I', i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 'I'");
		setError(ErrorParsingInit);
		return -1;
	}
	if (((res = parseCodeto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse code");
		setError(ErrorParsingInit);
		return -1;
	}
	if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected )");
		setError(ErrorParsingInit);
		return -1;
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static sqInt parseIntegerto(PNVMStringIter & i, char **outptr) {
	unsigned short tmp;
	char *out;
	PNVMToken token;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	token = parseNumber(i);
	if (!(pnvmTokenIsValid(token))) {
		return -1;
	}
	tmp = ((unsigned short) (pnvmTokenInteger(token)));
	;
	out[0] = (tmp % 256);
	*out++;
	out[0] = (((usqInt) tmp) >> 8);
	*out++;
	parseStoreOffsettoPtr(out, outptr);
	return 2;
}

static sqInt parseLongIntegerto(PNVMStringIter & i, char **outptr) {
	sqInt negative;
	char *out;
	sqInt c;
	long value;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	parseSkipBlanks(i);
	if (pnvmIterAtEnd(i)) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "empty string");
		return -1;
	}
	negative = 0;
	if (((c = pnvmIterValue(i))) == '-') {
		negative = 1;
		pnvmIterNext(i);
		c = pnvmIterValue(i);
	}
	if ((pnvmIterAtEnd(i)) || ((c < '0') || (c > '9'))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected digit 0-9");
		return -1;
	}
	value = (((sqInt)c)) - (((sqInt)'0'));
	pnvmIterNext(i);
	if ((value == 0) && ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9')))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "junk after first 0");
		return -1;
	}
	while ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9'))) {
		value = (value * 10) + ((((sqInt)c)) - (((sqInt)'0')));
		pnvmIterNext(i);
	}
	if ((!(pnvmIterAtEnd(i))) && ((!(charIsBlank(c))) && (!(charisOneOf(c, "(,/)]}"))))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,("invalid number terminator: ", c));
		return -1;
	}
	if (negative) {
		value = 0 - value;
	}
	memStoreLongto(value, out);
	parseStoreOffsettoPtr(out + 4, outptr);
	return 4;
}

static PNVMStringHead * parseName(PNVMStringIter & i) {
	PNVMStringHead *res;
	PNVMStringIter o;
	char c;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	parseSkipBlanks(i);
	if (pnvmIterAtEnd(i)) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "string empty");
		return null;
	}
	c = pnvmIterNext(i);
	if (!(isalpha(c))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,(,("expected alpha, not: '", c), "'"));
		return null;
	}
	if (((res = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate string for name");
		return null;
	}
	o = pnvmValueIterator(res);
	pnvmIterWrite(o, c);
	while ((!(pnvmIterAtEnd(i))) && ((isalnum(c = pnvmIterValue(i))) || (c == '_'))) {
		pnvmIterWrite(o, c);
		pnvmIterNext(i);
		c = pnvmIterValue(i);
	}
	if (!((charIsBlank(c)) || (charisOneOf(c, "[/(),")))) {
		pnvmValueDelete(res);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,(,("expected blank or one of separators not: '", c), "'"));
		return null;
	}
	return res;
}


/*	
	Parse identifier in Net template definition or in net instance code.
	Identifier matches expression:
		[a-zA-Z][a-zA-Z0-9_]*
	It expects either space, parameter separator, closing or opening bracket after
	the identifier.
	 */

static sqInt parseNameto(PNVMStringIter & i, char **outptr) {
	char *out;
	sqInt c;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	parseSkipBlanks(i);
	if (pnvmIterAtEnd(i)) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "string empty");
		return -1;
	}
	c = pnvmIterNext(i);
	if (!(isalpha(c))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected alpha");
		return -1;
	}
	out[0] = (((sqInt)c));
	*out++;
	while ((!(pnvmIterAtEnd(i))) && ((isalnum(c = pnvmIterValue(i))) || (c == '_'))) {
		out[0] = (((sqInt)c));
		*out++;
		pnvmIterNext(i);
		c = pnvmIterValue(i);
	}
	if (!((charIsBlank(c)) || (charisOneOf(c, "/(),")))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,(,("expected blank or separator, not: '", c), "'"));
		return -1;
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static PNVMTupleHead * parseNames(PNVMStringIter & i) {
	PNVMTupleHead *res;
	PNVMTupleIter o;
	PNVMStringHead *name;
	PNVMToken token;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	if (!(parseSkipBlanksexpecting(i, '('))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expecting (");
		setError(ErrorParsingNames);
		return null;
	}
	parseSkipBlanks(i);
	if (((res = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple to store names");
		return null;
	}
	o = pnvmValueIterator(res);
	while (!((pnvmIterValue(i)) == ')')) {
		name = parseName(i);
		if (name == null) {
			pnvmValueDelete(res);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse name");
			setError(ErrorParsingNames);
			return null;
		}
		token = pnvmNewPointer(PNVMToken, name);
		pnvmIterWrite(o, token);
		pnvmTokenMakeInvalid(token);
		if (!(parseSkipBlanksuntilOneOf(i, "/),"))) {
			pnvmValueDelete(res);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected one of separators");
			setError(ErrorParsingNames);
			return null;
		}
		if (((pnvmIterValue(i)) == '/') || ((pnvmIterValue(i)) == ',')) {
			pnvmIterNext(i);
			parseSkipBlanks(i);
		}
	}
	if (!((pnvmIterNext(i)) == ')')) {
		pnvmValueDelete(res);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expecting ')'");
		setError(ErrorParsingNames);
		return null;
	}
	return res;
}


/*	
	Parse sequence of identifiers to object memory.
	Sequence starts with $( and ends with $). Identifiers are separated with $, or $/.
	 */

static sqInt parseNamesto(PNVMStringIter & i, char **outptr) {
	char *out;
	char **outacc;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	outacc = &out;
	if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expecting (");
		setError(ErrorParsingNames);
		return -1;
	}
	parseSkipBlanks(i);
	while (!((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) == ')'))) {
		if ((parseNameto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse name");
			setError(ErrorParsingNames);
			return -1;
		}
		if (!(parseSkipBlanksuntilOneOf(i, "/),"))) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected one of separators");
			setError(ErrorParsingNames);
			return -1;
		}
		if (((pnvmIterValue(i)) == '/') || ((pnvmIterValue(i)) == ',')) {
			pnvmIterNext(i);
			parseSkipBlanks(i);
			out[0] = (((sqInt)','));
			*out++;
		}
	}
	if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expecting ')'");
		setError(ErrorParsingNames);
		return -1;
	}
	return parseStoreOffsettoPtr(out, outptr);
}


/*	
	parse token value in net instance string
	it can be:
		* number with or without I prefix
		* symbol of net template given as S <index>
		* any value, that can occur as symbol in net template code
		
	Returns token.
	 */

static PNVMToken parseNetInstValueofTemplate(PNVMStringIter & i, PNVMTemplate const *tmpl) {
	PNVMTupleIter si;
	PNVMToken index;
	PNVMToken res;
	PNVMTupleHead const *symbols;
	sqInt c;

	res = pnvmNewToken(PNVMToken);
	parseSkipBlanks(i);
	c = pnvmIterValue(i);
	if (c == 'I') {
		pnvmIterNext(i);
		res = parseNumber(i);
		if (!(pnvmTokenIsValid(res))) {
			setError(ErrorParsingNetInstValue);
		}
	} else {
		if (c == 'S') {
			pnvmIterNext(i);
			if (!((pnvmTokenIsValid(index = parseNumber(i))) && ((pnvmTokenInteger(index)) >= 0))) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse positive integer");
				setError(ErrorParsingNetInstValue);
				return res;
			}
			symbols = pnvmTemplateSymbols(tmpl);
			if ((((unsigned int) (pnvmTokenInteger(index)))) >= (pnvmValueItemCount(pnvmTemplateSymbols(tmpl)))) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,(,(,("no such symbol with index=", pnvmTokenInteger(index)), " in template: "), tmpl));
				setError(ErrorParsingNetInstValue);
				return res;
			}
			si = pnvmValueIterator(((PNVMTupleHead *) symbols));
			pnvmIterSeek(si, pnvmTokenInteger(index));
			res = pnvmIterValue(si);
		} else {
			res = parseSymbolallowNetInst(i, 1);
		}
	}
	return res;
}


/*	
	Format of net instance:
		(n net_template_name (p place_name (t <number> <symbol>) (t <number> <symbol>)) )
	
	Places can be serialized in arbitrary order. They only need to have name matching
	one in net template.
	
	:param i: string iterator with serialized net instance. It is shifted past the closing bracket of
		net instance code.

	Return instance of PNVMNetInstHead.
	 */

static PNVMNetInstHead * parseNetInstance(PNVMStringIter & i) {
	PNVMPlaceHead *place;
	PNVMTemplate *tmpl;
	PNVMNetInstIter o;
	PNVMStringHead *name;
	PNVMNetInstHead *inst;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	if (!(parseSkipBlanksexpecting(i, '('))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '('");
		setError(ErrorParsingNetInst);
		return null;
	}
	if ((pnvmIterAtEnd(i)) || ((pnvmIterNext(i)) != 'n')) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 'n'");
		setError(ErrorParsingNetInst);
		return null;
	}
	if (((name = parseName(i))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse name");
		setError(ErrorParsingNetInst);
		return null;
	}
	tmpl = findNetTemplate(name);
	pnvmValueDelete(name);
	if (tmpl == null) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,("no such net template: ", asPlainString(name)));
		setError(ErrorNoSuchTemplate);
		return null;
	}
	parseSkipBlanks(i);
	if (((inst = pnvmNetInstNew(PNVMNetInstHead, tmpl))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new net instance");
		return null;
	}
	changeBlockSizeOfto(inst, pnvmTemplatePlaceCount(tmpl));
	if (error != ErrorSuccess) {
		pnvmValueDelete(inst);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to resize net instance");
		return null;
	}
	o = pnvmValueIterator(inst);
	parseSkipBlanks(i);
	while (!((pnvmIterValue(i)) == ')')) {
		if ((parsePlaceofTemplateto(i, tmpl, o)) == null) {
			pnvmValueDelete(inst);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse net instance");
			setError(ErrorParsingNetInst);
			return null;
		}
		parseSkipBlanks(i);
	}
	pnvmIterSeekStart(o);
	while (!(pnvmIterAtEnd(o))) {
		if ((pnvmIterValue(o)) == null) {
			if (((place = pnvmPlaceNew(PNVMPlaceHead))) == null) {
				pnvmValueDelete(inst);
				categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new place");
				return null;
			}
			pnvmIterSetItem(o, place);
		}
		pnvmIterNext(o);
	}
	pnvmIterNext(i);
	return inst;
}

static PNVMTemplate * parseNetTemplate(PNVMStringIter & i) {
	char *out;
	sqInt parsed;
	PNVMTemplate *tmpl;
	sqInt codeOffset;
	PNVMStringHead *name;
	PNVMTupleHead *symbols;
	PNVMTupleHead *places;
	sqInt transitions;
	char **outacc;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	codeOffset = getCodeSize();
	out = getCodeIteratorAt(codeOffset);
	outacc = &out;
	if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '('");
		setError(ErrorParsingTemplate);
		return null;
	}
	if ((parseExpCharfromto('N', i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 'N'");
		setError(ErrorParsingTemplate);
		return null;
	}
	if (((name = parseName(i))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse name");
		setError(ErrorParsingTemplate);
		return null;
	}
	if (((symbols = parseSymbols(i))) == null) {
		pnvmValueDelete(name);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse symbols");
		setError(ErrorParsingTemplateSymbols);
		return null;
	}
	if (((places = parseNames(i))) == null) {
		pnvmValueDelete(name);
		pnvmValueDelete(symbols);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse names");
		setError(ErrorParsingNames);
		return null;
	}
	if (((parsed = parseUplinksto(i, outacc))) < 0) {
		pnvmValueDelete(name);
		pnvmValueDelete(places);
		pnvmValueDelete(symbols);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse uplinks");
		setError(ErrorParsingUplinks);
		return null;
	}
	if (((parsed = parseInitto(i, outacc))) < 0) {
		pnvmValueDelete(name);
		pnvmValueDelete(places);
		pnvmValueDelete(symbols);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse init transition");
		setError(ErrorParsingInit);
		return null;
	}
	transitions = codeOffset + (*outacc - getCodeIteratorAt(codeOffset));
	if (((parsed = parseTransitionsto(i, outacc))) < 0) {
		pnvmValueDelete(name);
		pnvmValueDelete(places);
		pnvmValueDelete(symbols);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse transitions");
		setError(ErrorParsingTransitions);
		return null;
	}
	if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		pnvmValueDelete(name);
		pnvmValueDelete(places);
		pnvmValueDelete(symbols);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ')' at the end of net tmpl code");
		setError(ErrorParsingTemplate);
		return null;
	}
	if (((tmpl = pnvmTemplateNew(PNVMTemplate))) == null) {
		pnvmValueDelete(name);
		pnvmValueDelete(places);
		pnvmValueDelete(symbols);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate net template");
		return null;
	}
	pnvmTemplateSetPlaceCount(tmpl, pnvmValueItemCount(places));
	pnvmTemplateSetName(tmpl, name);
	pnvmTemplateSetPlaces(tmpl, places);
	pnvmTemplateSetSymbols(tmpl, symbols);
	pnvmTemplateSetCodeOffset(tmpl, codeOffset);
	pnvmTemplateSetCodeLength(tmpl, *outacc - getCodeIteratorAt(codeOffset));
	pnvmTemplateSetTransitions(tmpl, transitions);
	return tmpl;
}

static PNVMToken parseNumber(PNVMStringIter & i) {
	sqInt negative;
	PNVMToken res;
	sqInt c;
	sqInt value;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	res = pnvmNewToken(PNVMToken);
	parseSkipBlanks(i);
	if (pnvmIterAtEnd(i)) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "empty string");
		return res;
	}
	negative = 0;
	if (((c = pnvmIterValue(i))) == '-') {
		negative = 1;
		pnvmIterNext(i);
		c = pnvmIterValue(i);
	}
	if ((pnvmIterAtEnd(i)) || ((c < '0') || (c > '9'))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected digit 0-9");
		return res;
	}
	value = (((sqInt)c)) - (((sqInt)'0'));
	pnvmIterNext(i);
	if ((value == 0) && ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9')))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "junk after first 0");
		return res;
	}
	while ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9'))) {
		value = (value * 10) + ((((sqInt)c)) - (((sqInt)'0')));
		pnvmIterNext(i);
	}
	if ((!(pnvmIterAtEnd(i))) && ((!(charIsBlank(c))) && (!(charisOneOf(c, "(,/)]}"))))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,("invalid number terminator: ", c));
		return res;
	}
	if (negative) {
		value = 0 - value;
	}
	pnvmTokenSetInteger(res, value);
	return res;
}


/*	
	Parse single place of serialized net instance.
	It's format is following:
		(p <name> <token0> <token1> ... )
	
	:param i: string iterator with serialized net instance.
	:param netInstIter: Iterator of net instance, which will acquire parsed place.
		Iterator will be seeked to correct position determined by index of place name in
		template places.
	
	Return created place.
	 */

static PNVMPlaceHead * parsePlaceofTemplateto(PNVMStringIter & i, PNVMTemplate const *tmpl, PNVMNetInstIter & netInstIter) {
	PNVMToken tmp;
	PNVMPlaceHead *place;
	sqInt index;
	PNVMPlaceIter o;
	PNVMStringHead *name;
	PNVMPlaceItem plcItem;
	char c;
	sqInt number;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	assert(interpreterProxy->isKindOf(netInstIter,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(netInstIter)),'PNVMNetInstHead'));
	c = 0;
	if (!(parseSkipBlanksexpecting(i, '('))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '('");
		setError(ErrorParsingPlace);
		return null;
	}
	if ((pnvmIterAtEnd(i)) || ((pnvmIterNext(i)) != 'p')) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 'p'");
		setError(ErrorParsingPlace);
		return null;
	}
	if (((name = parseName(i))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse name of place");
		setError(ErrorParsingPlace);
		return null;
	}
	index = placeIndexin(name, tmpl);
	if (index < 0) {
		pnvmValueDelete(name);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", ,(,(,("failed to find place ", asPlainString(name)), " in template "), dereference(tmpl)));
		setError(ErrorNoSuchPlace);
		return null;
	}
	pnvmValueDelete(name);
	if (!(parseSkipBlanksuntilOneOf(i, "()"))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '(' or ')'");
		setError(ErrorParsingPlace);
		return null;
	}
	if (((place = pnvmPlaceNew(PNVMPlaceHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate new place");
		return null;
	}
	o = pnvmValueIterator(place);
	while ((!(pnvmIterAtEnd(i))) && (((c = pnvmIterNext(i))) != ')')) {
		if (!(c == '(')) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected '('");
			setError(ErrorParsingPlace);
			return null;
		}
		if (!(((c = pnvmIterNext(i))) == 't')) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 't'");
			setError(ErrorParsingPlace);
			return null;
		}
		if (!(pnvmTokenIsValid(tmp = parseNumber(i)))) {
			pnvmValueDelete(place);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse number of tokens of place");
			setError(ErrorParsingPlace);
			return null;
		}
		number = pnvmTokenInteger(tmp);
		if (!(parseSkipBlanksComma(i))) {
			pnvmValueDelete(place);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ','");
			setError(ErrorParsingPlace);
			return null;
		}
		if (!(pnvmTokenIsValid(tmp = parseNetInstValueofTemplate(i, tmpl)))) {
			pnvmValueDelete(place);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse token value of place");
			setError(ErrorParsingPlace);
			return null;
		}
		if (!(parseSkipBlanksexpecting(i, ')'))) {
			pnvmValueDelete(place);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ')'");
			setError(ErrorParsingPlace);
			return null;
		}
		if (!(parseSkipBlanksuntilOneOf(i, "()"))) {
			pnvmValueDelete(place);
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected one of '()'");
			setError(ErrorParsingPlace);
			return null;
		}
		plcItem = pnvmPlaceItemNewof(PNVMPlaceItem, number, tmp);
		pnvmTokenMakeInvalid(tmp);
		pnvmIterWrite(o, plcItem);
		pnvmPlaceItemMakeInvalid(plcItem);
	}
	pnvmIterSeek(netInstIter, index);
	if (!((pnvmIterValue(netInstIter)) == null)) {
		pnvmValueDelete(pnvmIterValue(netInstIter));
	}
	pnvmIterSetItem(netInstIter, place);
	if (!(c == ')')) {
		pnvmValueDelete(place);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected ')'");
		setError(ErrorParsingPlace);
		return null;
	}
	return place;
}

static sqInt parsePosIntegerto(PNVMStringIter & i, char **outptr) {
	char *out;
	PNVMToken token;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	token = parseNumber(i);
	if (!(pnvmTokenIsValid(token))) {
		return -1;
	}
	if ((pnvmTokenInteger(token)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "value is negative");
		return -1;
	}
	out[0] = ((((unsigned short) (pnvmTokenInteger(token)))) % 256);
	*out++;
	out[0] = (((sqInt) (((unsigned short) (pnvmTokenInteger(token)))) >> 8));
	*out++;
	parseStoreOffsettoPtr(out, outptr);
	return 2;
}

static void parseSkipBlanks(PNVMStringIter & iterator) {
	assert(interpreterProxy->isKindOf(iterator,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(iterator)),'PNVMStringHead'));
	while ((!(pnvmIterAtEnd(iterator))) && (charIsBlank(pnvmIterValue(iterator)))) {
		pnvmIterNext(iterator);
	}
}

static sqInt parseSkipBlanksexpecting(PNVMStringIter & iterator, sqInt character) {
	parseSkipBlanks(iterator);
	if (pnvmIterAtEnd(iterator)) {
		return 0;
	}
	if (!((pnvmIterValue(iterator)) == character)) {
		return 0;
	}
	pnvmIterNext(iterator);
	return 1;
}

static sqInt parseSkipBlanksuntil(PNVMStringIter & iterator, sqInt character) {
	parseSkipBlanks(iterator);
	return (pnvmIterValue(iterator)) == character;
}

static sqInt parseSkipBlanksuntilOneOf(PNVMStringIter & iterator, char const *string) {
	assert(interpreterProxy->isKindOf(string,'String'));
	parseSkipBlanks(iterator);
	if (pnvmIterAtEnd(iterator)) {
		return 0;
	}
	return strchr(string, pnvmIterValue(iterator)) != NULL;
}


/*	
	Skip blanks up to left bracket, which is stored to output buffer.
	 */

static sqInt parseSkipBlanksComma(PNVMStringIter & i) {
	if (!(parseSkipBlanksuntil(i, ','))) {
		return 0;
	}
	pnvmIterNext(i);
	return 1;
}


/*	
	Skip blanks up to left bracket, which is stored to output buffer.
	 */

static sqInt parseSkipBlanksLBto(PNVMStringIter & i, char **outptr) {
	parseSkipBlanks(i);
	return parseExpCharfromto('(', i, outptr);
}


/*	
	Skip blanks up to left bracket, which is stored to output buffer.
	 */

static sqInt parseSkipBlanksRBto(PNVMStringIter & i, char **outptr) {
	parseSkipBlanks(i);
	return parseExpCharfromto(')', i, outptr);
}


/*	
	This is for functions taking reference to pointer as argument and want
	to change it.
	 */

static sqInt parseStoreOffsettoPtr(char *off, char **ptr) {
	sqInt ret;

	ret = -1;
	if (!(ptr == null)) {
		ret = off - (*ptr);
		*ptr = off;
	}
	return ret;
}

static PNVMStringHead * parseString(PNVMStringIter & i) {
	PNVMStringHead *res;
	PNVMStringIter o;
	char c;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	if (!(parseSkipBlanksexpecting(i, '"'))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected double quotes");
		setError(ErrorParsingString);
		return null;
	}
	if (((res = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate string for parsed string");
		return res;
	}
	o = pnvmValueIterator(res);
	while ((!(pnvmIterAtEnd(i))) && (((c = pnvmIterValue(i))) != '"')) {
		while ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) != '"') && (c != '\\'))) {
			pnvmIterWrite(o, c);
			pnvmIterNext(i);
		}
		if (c == '\\') {
			pnvmIterNext(i);
			if (pnvmIterAtEnd(i)) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "unexpected EOS");
				pnvmValueDelete(res);
				setError(ErrorParsingString);
				return null;
			}
			c = pnvmIterNext(i);
			if (c == 'n') {
				c = '\n';
			} else {
				if (c == 't') {
					c = '\t';
				} else {
					if (c == 'r') {
						c = '\r';
					}
				}
			}
			pnvmIterWrite(o, c);
		}
	}
	if ((pnvmIterAtEnd(i)) || ((pnvmIterValue(i)) != '"')) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected double quotes");
		pnvmValueDelete(res);
		setError(ErrorParsingString);
		return null;
	}
	pnvmIterNext(i);
	return res;
}


/*	
	Parse serialized symbol.
	
	:param i: Iterator to String object containing one of serialized symbols:
		integer, string, tuple, array, net instance
	:param allowNetInst: Boolean saying, whether to parse net instance.
		Net instances are not allowed in net template symbols, but they may
		occur in serialized net instance.
	 */

static PNVMToken parseSymbolallowNetInst(PNVMStringIter & i, sqInt allowNetInst) {
	PNVMHeaderBlock *tmp;
	PNVMNetInstHead *inst;
	sqInt c;
	PNVMToken token;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(allowNetInst,'Boolean'));
	parseSkipBlanks(i);
	token = pnvmNewToken(PNVMToken);
	c = pnvmIterValue(i);
	if ((c == '-') || (isdigit(c))) {
		token = parseNumber(i);
		if (!(pnvmTokenIsValid(token))) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse number");
		}
	} else {
		if ((c == '(') && (allowNetInst)) {

			/* 
		If instance is embedded in place of another instance being parsed,
		we need to manage the embedded instance first. If parsing of
		outer instance fails, embedded will be unmanaged and released
		upon deletion of outer one.
		 */

			if (((inst = parseNetInstance(i))) == null) {
				categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to parse embedded net instance");
				return token;
			}
			pnvmTokenAssign(token, manageNetInstance(inst));
			if (!(pnvmTokenIsValid(token))) {
				categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("failed to manage net instance ", dereference(inst)));
				return token;
			}
		} else {
			if (c == '"') {
				if (((tmp = parseString(i))) == null) {
					categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse string");
				} else {
					pnvmTokenSetPointer(token, tmp);
				}
			} else {
				if (c == '[') {
					if (((tmp = parseTupleallowNetInst(i, allowNetInst))) == null) {
						categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse tuple");
					} else {
						pnvmTokenSetPointer(token, tmp);
					}
				} else {
					if (c == '{') {
						if (((tmp = parseArrayallowNetInst(i, allowNetInst))) == null) {
							categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse tuple");
						} else {
							pnvmTokenSetPointer(token, tmp);
						}
					} else {
						categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "invalid symbol");
					}
				}
			}
		}
	}
	if (!(pnvmTokenIsValid(token))) {
		setError(ErrorParsingSymbol);
	}
	return token;
}

static PNVMTupleHead * parseSymbols(PNVMStringIter & i) {
	PNVMItemIterator iter;
	PNVMTupleHead *res;
	PNVMTupleIter ti;

	if (((res = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple for symbols");
		return null;
	}
	ti = pnvmValueIterator(res);
	iter = pnvmIterAsItemIterator(ti);
	if (!(parseCollectionstartingWithendingWithtoallowNetInst(i, '(', ')', iter, 0))) {
		pnvmValueDelete(res);
		setError(ErrorParsingTemplateSymbols);
		return null;
	}
	return res;
}


/*	
	Parse serialized token. This includes numbers, strings, tuples, arrays and net instances.
	Net templates should be sent as embedded strings.
	 */

static PNVMToken parseToken(PNVMStringHead *str) {
	PNVMStringIter iter;
	PNVMToken res;

	assert(interpreterProxy->isKindOf(str,'PNVMStringHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering parseToken:");
	if ((pnvmValueItemCount(str)) < 1) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "invalid token received");
		setError(ErrorParsingToken);
		return pnvmNewToken(PNVMToken);
	}
	iter = pnvmValueIterator(str);
	res = parseSymbolallowNetInst(iter, 1);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,("leaving parseToken: with result=", res));
	if (!(pnvmTokenIsValid(res))) {
		setError(ErrorParsingToken);
	}
	return res;
}

static sqInt parseTransitionto(PNVMStringIter & i, char **outptr) {
	char *out;
	sqInt res;
	char **outacc;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	outacc = &out;
	if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected (");
		setError(ErrorParsingTransition);
		return -1;
	}
	if ((parseExpCharfromto('T', i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 'T'");
		setError(ErrorParsingTransition);
		return -1;
	}
	if ((parseNameto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse transition name");
		setError(ErrorParsingTransition);
		return -1;
	}
	if (((res = parseNamesto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse variables");
		setError(ErrorParsingTransition);
		return -1;
	}
	if (((res = parseCodeto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse code");
		setError(ErrorParsingTransitionCode);
		return -1;
	}
	if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected )");
		setError(ErrorParsingTransition);
		return -1;
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static sqInt parseTransitionsto(PNVMStringIter & i, char **outptr) {
	char *out;
	char **outacc;
	PNVMStringIter iterTmp;
	char *outTmp;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	parseSkipBlanksuntilOneOf(i, "()");
	while ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) != ')')) {
		iterTmp = i;
		outTmp = out;
		outacc = makePointer(outTmp);
		if ((parseTransitionto(iterTmp, outacc)) < 0) {
			if (!(parseSkipBlanksuntil(iterTmp, ')'))) {
				categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,("expected ')', not: '", pnvmIterValue(iterTmp)), "'"));
				setError(ErrorParsingTransitions);
				return -1;
			}
			return parseStoreOffsettoPtr(out, outptr);
		} else {
			pnvmIterAssign(i, iterTmp);
			out = outTmp;
			parseSkipBlanksuntilOneOf(i, "()");
		}
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static PNVMTupleHead * parseTupleallowNetInst(PNVMStringIter & i, sqInt allowNetInst) {
	PNVMItemIterator iter;
	PNVMTupleHead *res;
	PNVMTupleIter ti;

	assert(interpreterProxy->isKindOf(allowNetInst,'Boolean'));
	if (((res = pnvmTupleNew(PNVMTupleHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple for parsed tuple");
		return null;
	}
	ti = pnvmValueIterator(res);
	iter = pnvmIterAsItemIterator(ti);
	if (!(parseCollectionstartingWithendingWithtoallowNetInst(i, '[', ']', iter, allowNetInst))) {
		pnvmValueDelete(res);
		setError(ErrorParsingCollection);
		return null;
	}
	return res;
}

static sqInt parseUplinkto(PNVMStringIter & i, char **outptr) {
	char *out;
	sqInt res;
	char **outacc;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	outacc = &out;
	if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected (");
		setError(ErrorParsingUplink);
		return -1;
	}
	if ((parseExpCharfromto('U', i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected 'U'");
		setError(ErrorParsingUplink);
		return -1;
	}
	if (((res = parseNameto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse name");
		setError(ErrorParsingUplink);
		return -1;
	}
	if (((res = parseNamesto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse arguments");
		setError(ErrorParsingUplink);
		return -1;
	}
	if (((res = parseNamesto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse variables");
		setError(ErrorParsingUplink);
		return -1;
	}
	if (((res = parseCodeto(i, outacc))) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse code");
		setError(ErrorParsingUplink);
		return -1;
	}
	if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected )");
		setError(ErrorParsingUplink);
		return -1;
	}
	return parseStoreOffsettoPtr(out, outptr);
}

static sqInt parseUplinksto(PNVMStringIter & i, char **outptr) {
	char *out;
	PNVMStringIter ii;
	char **outacc;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	out = *outptr;
	outacc = &out;
	parseSkipBlanksuntilOneOf(i, "()");
	while ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) != ')')) {
		ii = i;
		pnvmIterNext(ii);
		if ((pnvmIterValue(ii)) == 'U') {
			if ((parseUplinkto(i, outacc)) < 0) {
				categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse uplinks");
				setError(ErrorParsingUplinks);
				return -1;
			}
			parseSkipBlanksuntilOneOf(i, "()");
		} else {
			return parseStoreOffsettoPtr(out, outptr);
		}
	}
	return parseStoreOffsettoPtr(out, outptr);
}


/*	
	Parse parameter of transition element or value of expression.
	It consists of value symbol (one of {$S, $I, $V)) and integer.
	Meaning of value symbols:
		$S following number points to the symbols of net template -> the result is a symbol
		$I following number is integer value
		$V following number points to the transition variables array
	 */

static sqInt parseValueto(PNVMStringIter & i, char **outptr) {
	char *out;
	char **outacc;
	sqInt c;

	out = *outptr;
	outacc = &out;
	if (!(parseSkipBlanksuntilOneOf(i, "SIV"))) {
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "expected one of "SIV"");
		return -1;
	}
	c = ((sqInt)(pnvmIterNext(i)));
	out[0] = c;
	*out++;
	if (c == (((sqInt)'I'))) {
		if ((parseIntegerto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse integer");
			return -1;
		}
	} else {
		if ((parsePosIntegerto(i, outacc)) < 0) {
			categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse positive integer");
			return -1;
		}
	}
	parseStoreOffsettoPtr(out, outptr);
	return 3;
}

static sqInt placeIndexin(PNVMStringHead const *name, PNVMTemplate const *tmpl) {
	PNVMTupleIter i;
	sqInt index;

	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	assert(interpreterProxy->isKindOf(name,'PNVMStringHead'));
	i = pnvmValueIterator(((PNVMTupleHead *) (pnvmTemplatePlaces(tmpl))));
	index = 0;
	while (!(pnvmIterAtEnd(i))) {
		if ((cmpStringwith(name, ((PNVMStringHead *) (pnvmTokenPointer(pnvmIterValue(i)))))) == 0) {
			return index;
		}
		index += 1;
		pnvmIterNext(i);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,(,("could not find place with name ", asPlainString(name)), " in template "), dereference(tmpl)));
	return -1;
}

EXPORT(PNVMEvent *) primitiveCalFront(void) {
	/* begin calFront */
	unlessdieWithmsg(!(calendarHead == null), ErrorCalendarEmpty, "calendar is empty");
	return calendarHead;
}

EXPORT(bool) primitiveCalIsEmpty(void) {
	return calendarHead == null;
}


/*	
	Deallocates all resources.
	 */

EXPORT(void) primitiveCleanup(void) {
	;
}


/*	
	Deallocates all resources.
	 */

EXPORT(void) primitiveCleanupModule(void) {
	pnvmValueDelete(inputBuffer);
	pnvmValueDelete(outputBuffer);
	inputBuffer = null;
	outputBuffer = null;
	;
	stepCounter = 0;
	currentTime = 0;
	cleanupOMModule();
}

EXPORT(char *) primitiveCodeIteratorAt(sqInt pos) {
	return getCodeIteratorAt(pos);
}


/*	
	Gets the number of bytes occupied in net template code array.
	 */

EXPORT(CodeLength_t) primitiveCodeSize(void) {
	return getCodeSize();
}

EXPORT(Time_t) primitiveCurrentTime(void) {
	return currentTime;
}


/*	Returns Boolean saying, whether serious error occured. */

EXPORT(bool) primitiveFailed(void) {
	return error != ErrorSuccess;
}

EXPORT(bool) primitiveInputCStr(char const *msg) {
	return inputMessage(msg);
}

EXPORT(bool) primitiveInputString(PNVMStringHead *msg) {
	return inputString(msg);
}

EXPORT(PNVMNetInstHead *) primitiveInstantiateTemplate(sqInt tmplId) {
	return instantiateTemplate(tmplId);
}

EXPORT(sqInt) primitiveLoadNetTemplate(char const *msg) {
	sqInt tmp;

	return loadNetTemplate(msg);
}


/*	
	This is supposed to be used by main program at initialization.
	Code for this template must already be filled in netTemplateCode.
	
	:param places: array of pointers to string with names of places of plcCount length
	 */

EXPORT(Error_t) primitiveMakePlatformTemplateplaceCountplacessymbolscodeLengthtransitions(char const *name, sqInt plcCount, char const * const *places, char const *symbols, CodeLength_t codeLength, CodeLength_t transitions) {
	sqInt i;
	PNVMTemplate *tmpl;
	PNVMStringHead *tmpStr;
	PNVMStringIter strIter;
	PNVMTupleHead *tuple;
	PNVMToken token;
	PNVMTupleIter tupiter;

	assert(transitions < codeLength);
	assert(plcCount >= 0);
	if (((tmpl = pnvmTemplateNew(PNVMTemplate))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate net template");
		return setError(ErrorNoMemory);
	}
	if (((tmpStr = cstrToString(name))) == null) {
		pnvmValueDelete(tmpl);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to create string for template name of out c-string");
		return setError(ErrorNoMemory);
	}
	pnvmTemplateSetName(tmpl, tmpStr);
	if (((tuple = pnvmTupleNew(PNVMTupleHead))) == null) {
		pnvmValueDelete(pnvmTemplateName(tmpl));
		pnvmValueDelete(tmpl);
		return setError(ErrorNoMemory);
	}
	tupiter = pnvmValueIterator(tuple);
	for (i = 0; i <= (plcCount - 1); i += 1) {
		if (((tmpStr = cstrToString(places[i]))) == null) {
			pnvmValueDelete(pnvmTemplateName(tmpl));
			pnvmValueDelete(tmpl);
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to create string of out c-string");
			return setError(ErrorNoMemory);
		}
		token = pnvmNewPointer(PNVMToken, tmpStr);
		pnvmIterWrite(tupiter, token);
		pnvmTokenMakeInvalid(token);
	}
	pnvmTemplateSetPlaces(tmpl, tuple);
	if (((tmpStr = cstrToString(symbols))) == null) {
		pnvmValueDelete(pnvmTemplateName(tmpl));
		pnvmValueDelete(pnvmTemplatePlaces(tmpl));
		pnvmValueDelete(tmpl);
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to make string out of platform's symbols");
		return setError(ErrorNoMemory);
	}
	strIter = pnvmValueIterator(tmpStr);
	if (((tuple = parseTupleallowNetInst(strIter, 0))) == null) {
		pnvmValueDelete(tmpStr);
		pnvmValueDelete(pnvmTemplateName(tmpl));
		pnvmValueDelete(pnvmTemplatePlaces(tmpl));
		pnvmValueDelete(tmpl);
		categorylevelmessage(LoggingEvent, "pnvmParsing", "error", "failed to parse platform symbols");
		return setError(ErrorParsingCollection);
	}
	pnvmValueDelete(tmpStr);
	pnvmTemplateSetSymbols(tmpl, tuple);
	pnvmTemplateSetPlaceCount(tmpl, plcCount);
	pnvmTemplateSetCodeOffset(tmpl, 0);
	pnvmTemplateSetCodeLength(tmpl, codeLength);
	pnvmTemplateSetTransitions(tmpl, transitions);
	if ((appendNetTemplate(tmpl)) < 0) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to append platform template");
		return setError(ErrorUnspecified);
	}
	return error;
}

EXPORT(PNVMTemplate *) primitiveNetTemplateAt(sqInt index) {
	unlessdieWithmsgwith((index > 0) && (index < numberOfNetTemplates), ErrorOutOfRange, "index to net template table is out of range: ", index);
	return netTemplateTable[index];
}

EXPORT(sqInt) primitiveNothingChanged(void) {
	return nothingChanged;
}

EXPORT(sqInt) primitiveNumberOfNetTemplates(void) {
	return numberOfNetTemplates;
}


/*	
	Returns serialized token from input buffer as String object.
	Caller should deallocate it with pnvmValueDelete()
	 */

EXPORT(bool) primitiveOutputBufferEmpty(void) {
	return (pnvmValueItemCount(outputBuffer)) == 0;
}


/*	
	This allocates new buffer and puts the output serialized token into it.
	Caller should deallocate it with free().
	
	In smalltalk this returns String instance.
	 */

EXPORT(char *) primitiveOutputPopCStr(void) {
	char *res;
	PNVMStringHead *str;

	str = outputPopMessage();
	res = stringToCStr(str);
	pnvmValueDelete(str);
	return res;
}


/*	
	Returns serialized token from input buffer as String object.
	Caller should deallocate it with pnvmValueDelete()
	 */

EXPORT(PNVMStringHead *) primitiveOutputPopMessage(void) {
	return outputPopMessage();
}


/*	
	just for testing purposes
	
	should be deleted, when parsing works perfectly
	 */

EXPORT(PNVMTemplate *) primitiveParseNetTemplate(PNVMStringHead *strBlock) {
	PNVMStringIter iter;

	iter = pnvmValueIterator(strBlock);
	return parseNetTemplate(iter);
}

EXPORT(PNVMStringHead *) primitiveRenderAsString(PNVMStringHead const *value) {
	return renderAsString(value);
}


/*	
	Returns number of characters written, -1 on error.
	 */

EXPORT(sqInt) primitiveSerializeTokento(PNVMToken const & token, PNVMStringIter & o) {
	return serializeTokento(token, o);
}


/*	
	Return number of characters written or -1 on error.
	 */

EXPORT(sqInt) primitiveSerializeValueto(PNVMHeaderBlock const *value, PNVMStringIter & o) {
	return serializeValueto(value, o);
}


/*	
	Do a single step.
	Return number of steps executed until now.
	 */

EXPORT(sqInt) primitiveStep(void) {
	step();
	return stepCounter;
}

EXPORT(sqInt) primitiveStepsExecuted(void) {
	return stepCounter;
}


/*	
	Converts String object to null-terminated c string.
	Caller has to call free on it to release it.
	 */

EXPORT(char *) primitiveStringToCStr(PNVMStringHead const *str) {
	return stringToCStr(str);
}


/*	
	This method iterates over transitions of template, which are tried
	to be executed for every instance.
	
	Return Success if no serious error occured during execution.
	 */

static Error_t processTemplateInstances(PNVMTemplate *tmpl) {
	PNVMTupleHead *vars;
	char const *codeptr;
	PNVMStringHead *trName;
	PNVMStringIter s;
	Error_t err;

	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering processTemplateInstances:");
	if (((pnvmTemplateInstances(tmpl)) == null) || ((pnvmValueItemCount(pnvmTemplateInstances(tmpl))) < 1)) {

		/* 
		Array of instances is allocated when it's needed.
		That's why we check it.
		 */

		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving processTemplateInstances:");
	} else {
		codeptr = getCodeIteratorAt(pnvmTemplateTransitions(tmpl));
		if (((vars = pnvmTupleNew(PNVMTupleHead))) == null) {
			categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate tuple for variables");
			return setError(ErrorNoMemory);
		}
		while (!(((codeptr[0]) == (((sqInt)')'))) || (error != ErrorSuccess))) {
			*codeptr++;
			*codeptr++;
			
#if !defined(TARGET_ARDUINO) && DEBUG
			if (((trName = pnvmStringNew(PNVMStringHead))) == null) {
				categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate temporary string for serialization of token");
				return setError(ErrorNoMemory);
			}
			s = pnvmValueIterator(trName);
			while (!((codeptr[0]) == (((sqInt)'(')))) {
				pnvmIterWrite(s, *codeptr++);
			}
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("running transaction '", asPlainString(trName)), "' on instances of template "), dereference(tmpl)));
			pnvmValueDelete(trName);
			
#else
			while (!((codeptr[0]) == (((sqInt)'(')))) {
				*codeptr++;
			}
			
#endif
			changeBlockSizeOfto(vars, codeGetVariableCount(codeptr));
			if (!(((err = processTemplateInstancesonTransitionwithVariables(pnvmTemplateInstances(tmpl), codeptr, vars))) == ErrorSuccess)) {
				pnvmValueDelete(vars);
				return err;
			}
			codeSeekSkipTransitionElements(codeptr);
			*codeptr++;
		}
		pnvmValueDelete(vars);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving processTemplateInstances:");
	return ErrorSuccess;
}


/*	
	Process all instances of template for particular transition.
	
	:param codeptr: points at the opening bracket of the first transition element.
		It is not modified by this function.
		
	Return ErrorSuccess if there was no serious error.
	 */

static Error_t processTemplateInstancesonTransitionwithVariables(PNVMArrayHead *instances, char const *codeptr, PNVMTupleHead *vars) {
	PNVMArrayIter i;
	PNVMToken inst;
	PNVMTupleIter vi;

	assert(interpreterProxy->isKindOf(instances,'PNVMArrayHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering processTemplateInstances:onTransition:withVariables:");
	i = pnvmValueIterator(instances);
	vi = pnvmValueIterator(vars);
	while (!((pnvmIterAtEnd(i)) || (error != ErrorSuccess))) {

		/* let's free all binded variables */

		pnvmIterSeekStart(vi);
		while (!(pnvmIterAtEnd(vi))) {
			pnvmTokenMakeInvalid(pnvmIterNext(vi));
		}

		/* codeptr does not get modified */

		inst = pnvmNewNetRef(PNVMToken, pnvmTokenNetRef(pnvmIterNext(i)));
		processTransitiononNetInstwithVariables(codeptr, pnvmTokenNetRef(inst), vars);
		pnvmTokenMakeInvalid(inst);
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving processTemplateInstances:onTransition:withVariables:");
	return error;
}


/*	
	Try to fire transition on particular net instance.
	This function modifies 'nothingChanged' if the transition succeeds.
	
	:param codeptr: points at the opening bracket of the first transition element.
		It is not modified by this function.
	 */

static Error_t processTransitiononNetInstwithVariables(char const *codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars) {
	PNVMArrayHead *arrtmp;
	PNVMArrayIter lastAttempt;
	PNVMArrayIter history;
	char const *tmpptr;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "entering processTransition:onNetInst:withVariables:");
	if (((arrtmp = pnvmArrayNew(PNVMArrayHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate array for lastAttempt");
		return setError(ErrorNoMemory);
	}
	lastAttempt = pnvmValueIterator(arrtmp);
	if (((arrtmp = pnvmArrayNew(PNVMArrayHead))) == null) {
		pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate array for history");
		return setError(ErrorNoMemory);
	}

	/* ensure that codeptr does not get modified */

	history = pnvmValueIterator(arrtmp);
	tmpptr = codeptr + 0;
	if (executeTransitionElementsAtonwithVariableslastAttempthistory(tmpptr, inst, vars, lastAttempt, history)) {
		nothingChanged = 0;
	} else {
		unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(lastAttempt))) == 0, ErrorExecutionUnspecified, "lastAttempts must be cleared for failed transition");
		unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(history))) == 0, ErrorExecutionUnspecified, "history must be cleared for failed transition");
	}
	pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
	releaseHistory(pnvmIterHeaderBlock(history));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving processTransition:onNetInst:withVariables:");
	return error;
}


/*	
	Puts number of tokens into particular place of net instance.
	Returns number of occurences of this token in place after insertion.
	 */

static sqInt putNtokenstoPlaceofNetInst(sqInt number, PNVMToken & token, sqInt placeId, PNVMNetInstHead *inst) {
	PNVMPlaceHead *place;
	PNVMNetInstIter ni;
	sqInt res;
	PNVMPlaceIter pi;
	PNVMPlaceItem plcItem;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,("put ", number), " of tokens "), token), " to place "), placeId), " of instance "), dereference(inst)));
	ni = pnvmValueIterator(inst);
	pnvmIterSeek(ni, placeId);
	place = pnvmIterValue(ni);
	pi = pnvmValueIterator(place);
	while ((!(pnvmIterAtEnd(pi))) && ((cmpTokenwith(token, pnvmPlaceItemToken(pnvmIterValue(pi)))) != 0)) {
		pnvmIterNext(pi);
	}
	if (pnvmIterAtEnd(pi)) {

		/* token not yet present in place */

		plcItem = pnvmPlaceItemNewof(PNVMPlaceItem, number, token);
		pnvmIterWrite(pi, plcItem);
		pnvmPlaceItemMakeInvalid(plcItem);
		res = number;
	} else {

		/* token already present in place -> just increase the number */

		res = pnvmPlaceItemIncBy(pnvmIterValue(pi), number);
	}
	return res;
}


/*	
	Some items in history need a post-processing before it can be released upon
	successful execution of transition. This post-processing sets in effect actions
	like removal of net template etc.
	
	This iterates over history, makes permanent changes for actions that need it
	and then releases them all together with history array.
	 */

static void releaseHistory(PNVMArrayHead *history) {
	PNVMArrayIter i;
	PNVMTemplate *tmpl;
	PNVMTupleIter ai;
	sqInt index;
	PNVMTupleHead *action;

	assert(interpreterProxy->isKindOf(history,'PNVMArrayHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "releasing history");
	i = pnvmValueIterator(history);
	while (!(pnvmIterAtEnd(i))) {

		/* check if action needs any post-processing and if not, release it */

		assert((pnvmTokenType(pnvmIterValue(i))) == TokenTypePointer);
		assert(interpreterProxy->isKindOf((pnvmTokenPointer(pnvmIterValue(i))),'PNVMTupleHead'));
		action = ((PNVMTupleHead *) (pnvmTokenPointer(pnvmIterValue(i))));
		assert((signature(action)) == TypeSignTuple);
		assert((pnvmValueItemCount(action)) > 0);
		ai = pnvmValueIterator(action);
		assert((pnvmTokenType(pnvmIterValue(ai))) == TokenTypeInteger);
		if ((pnvmTokenInteger(pnvmIterNext(ai))) == (((sqInt)'u'))) {

			/* unload net template */

			index = pnvmTokenInteger(pnvmIterNext(ai));
			tmpl = ((PNVMTemplate *) (pnvmTokenPointer(pnvmIterValue(ai))));
			removeNetTemplateonIndex(tmpl, index);
		}
		pnvmTokenMakeInvalid(pnvmIterNext(i));
	}
	pnvmValueDelete(history);
}


/*	
	This only deallocates any object on particular position in indexable value.
	It does not modify item count of affected value.
	 */

static void releaseItemAtPos(PNVMItemIterator & i) {
	PNVMPlaceHead *place;
	PNVMHeaderBlock *hb;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	assert(!(pnvmIterAtEnd(i)));
	hb = pnvmIterHeaderBlock(i);
	if ((signature(hb)) == TypeSignArray) {
		pnvmTokenMakeInvalid(pnvmIterValue(pnvmIterArray(i)));
	} else {
		if ((signature(hb)) == TypeSignTuple) {
			pnvmTokenMakeInvalid(pnvmIterValue(pnvmIterTuple(i)));
		} else {
			if ((signature(hb)) == TypeSignPlace) {
				pnvmPlaceItemMakeInvalid(pnvmIterValue(pnvmIterPlace(i)));
			} else {
				if ((signature(hb)) == TypeSignNetInst) {
					place = null;
					pnvmValueDelete(pnvmIterValue(pnvmIterNetInst(i)));
					pnvmIterSetItem(pnvmIterNetInst(i), place);
				} else {
					if ((signature(hb)) == TypeSignString) {
						pnvmIterSetItem(pnvmIterString(i), ((char) 0));
					} else {
						dieWithmsgwith(ErrorExecutionUnhandledSignature, "can not release item for ", dereference(hb));
					}
				}
			}
		}
	}
}


/*	
	Release all items from current position of iterator until the collection end.
	Empty blocks are removed as well.
	
	:param i: Iterator pointing at the first item of collection to release.
	
	Return valid iterator to current position (at end).
	 */

static PNVMItemIterator releaseItemsFromPos(PNVMItemIterator & i) {
	sqInt totalCapacity;
	sqInt destIndex;
	sqInt offset;
	PNVMItemIterator backIter;
	sqInt bc;
	PNVMItemIterator ii;
	PNVMTailBlock *srcBlock;
	sqInt offsetLimiT;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	ii = i;
	while (!((pnvmIterAtEnd(ii)) || (pnvmIterAtBlockEnd(ii)))) {

		/* first let's clean the current block */

		releaseItemAtPos(ii);
		pnvmIterNext(ii);
	}
	if (!(pnvmIterAtEnd(ii))) {

		/* we are at block end -> let's delete last item of block */

		releaseItemAtPos(ii);
		backIter = ii;
		pnvmIterNext(ii);
		if (!(pnvmIterAtEnd(ii))) {

			/* let's delete all following blocks */

			releaseItemsWithBlocksFromPos(ii);
			pnvmBlockSetTail(((PNVMHeaderBlock *) (pnvmIterCurrentBlock(backIter))), ((PNVMTailBlock *) null));
		}
	}

	/* total capacity of all blocks preceding current one */

	bc = pnvmValueIndexOfBlockAtItem(pnvmIterHeaderBlock(i), pnvmIterBlockIndex(i));
	totalCapacity = pnvmValueTotalCapacityAt(pnvmIterHeaderBlock(i), bc - 1);
	pnvmValueSetItemCount(pnvmIterHeaderBlock(i), pnvmIterIndex(i));
	if ((pnvmValueBlockCount(pnvmIterHeaderBlock(i))) <= (((unsigned) bc))) {

		/* let's move them to the previous block */


		/* current block is the source */

		srcBlock = ((PNVMTailBlock *) (pnvmIterCurrentBlock(i)));
		pnvmIterSeekStart(ii);
		pnvmIterSeek(ii, totalCapacity - 1);
		pnvmBlockSetTail(((PNVMHeaderBlock *) (pnvmIterCurrentBlock(ii))), ((PNVMTailBlock *) null));
		if ((pnvmIterCurrentBlock(ii)) == (pnvmIterHeaderBlock(i))) {
			destIndex = pnvmTypeNotLastCapacity(pnvmIterHeaderBlock(i));
		} else {
			destIndex = pnvmTypeTailNotLastCapacity(pnvmIterHeaderBlock(i));
		}
		for (offset = 0, offsetLimiT = ((pnvmIterIndex(i)) - totalCapacity); offset <= offsetLimiT; offset += 1) {

			/* move by swapping them */

			swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(destIndex + offset, pnvmIterCurrentBlock(ii), offset, srcBlock, signature(pnvmIterHeaderBlock(ii)), (pnvmIterHeaderBlock(i)) == (pnvmIterCurrentBlock(ii)));
		}
		pnvmBlockDelete(srcBlock);
		pnvmIterAssign(i, ii);
		pnvmIterSeekEnd(i);
	}
	return i;
}


/*	
	This is supposed to be called only from releaseItemsFromPos().
	It iteratively releases all items with blocks until the last one.
	 */

static void releaseItemsWithBlocksFromPos(PNVMItemIterator & i) {
	PNVMTailBlock *prevBlock;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	while (!(pnvmIterAtEnd(i))) {
		while (!((pnvmIterAtEnd(i)) || (pnvmIterAtBlockEnd(i)))) {

			/* first let's clean the current block */

			releaseItemAtPos(i);
			pnvmIterNext(i);
		}
		if (!(pnvmIterAtEnd(i))) {

			/* we are at block end -> let's delete last item of block */

			releaseItemAtPos(i);

			/* move to the next block */

			prevBlock = ((PNVMTailBlock *) (pnvmIterCurrentBlock(i)));
			pnvmIterNext(i);
			pnvmBlockDelete(prevBlock);
		}
	}
}


/*	
	Removes item from any position of any indexable value.
	
	:param i: iterator pointing at the item to remove
	
	Return iterator to original position. Since removing an item may invalidate
	any iterators of its value.
	 */

static PNVMItemIterator removeItemFromBlockAt(PNVMItemIterator & i) {
	sqInt notLastCapacity;
	PNVMTailBlock *lb;
	sqInt j;
	PNVMItemIterator src;
	void *lbo;
	sqInt bc;
	PNVMHeaderBlock *fb;
	sqInt lastCapacity;
	PNVMItemIterator dest;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	assert(!(pnvmIterAtEnd(i)));
	dest = i;
	src = i;
	releaseItemAtPos(dest);
	pnvmIterNext(src);
	while (!(pnvmIterAtEnd(src))) {
		swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(pnvmIterBlockIndex(dest), pnvmIterCurrentBlock(dest), pnvmIterBlockIndex(src), pnvmIterCurrentBlock(src), signature(pnvmIterHeaderBlock(dest)), (pnvmIterHeaderBlock(dest)) == (pnvmIterCurrentBlock(dest)));
		pnvmIterNext(src);
		pnvmIterNext(dest);
	}

	/* last but one block - it can be either header or tail block */

	fb = pnvmIterHeaderBlock(i);
	lbo = null;
	bc = pnvmValueBlockCount(fb);
	if (pnvmIterAtLastBlock(dest)) {
		lb = ((PNVMTailBlock *) (pnvmIterCurrentBlock(dest)));
	} else {

		/* if we are at convenient position, let's cache lbo before we need it for sure */

		pnvmIterSeek(dest, pnvmValueTotalCapacityAt(fb, bc - 3));
		assert(pnvmIterAtBlockStart(dest));
		lbo = pnvmIterCurrentBlock(dest);
		pnvmIterNextBlock(dest);
		lb = ((PNVMTailBlock *) (pnvmIterCurrentBlock(dest)));
	}
	pnvmValueSetItemCount(fb, (pnvmValueItemCount(fb)) - 1);
	if ((pnvmValueBlockCount(fb)) < (((unsigned int) bc))) {

		/* we must delete last block */

		if (lbo == null) {

			/* get last but one block */

			pnvmIterSeekStart(dest);
			pnvmIterSeek(dest, pnvmValueTotalCapacityAt(fb, bc - 3));
			lbo = pnvmIterCurrentBlock(dest);
			assert((pnvmIterAtBlockStart(dest)) && (pnvmIterAtLastBlock(dest)));
		}
		assert((pnvmBlockTail(((PNVMTailBlock *) lbo))) == lb);
		pnvmBlockSetTail(((PNVMTailBlock *) lbo), ((PNVMTailBlock *) null));
		if (lbo == fb) {

			/* we are assigning to header block */

			notLastCapacity = pnvmTypeNotLastCapacity(fb);
			lastCapacity = pnvmTypeLastCapacity(fb);
		} else {

			/* we are assigning to tail block */

			notLastCapacity = pnvmTypeTailNotLastCapacity(fb);
			lastCapacity = pnvmTypeTailLastCapacity(fb);
		}
		for (j = notLastCapacity; j <= (lastCapacity - 1); j += 1) {

			/* let's move items from last block to tail place of last but one block */
			/* we don't need to deallocate here */

			swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(j, lbo, j - notLastCapacity, lb, signature(fb), lbo == fb);
		}
		pnvmBlockDelete(lb);
		if ((((unsigned int) (pnvmIterIndex(i)))) >= (pnvmValueItemCount(fb))) {
			pnvmIterSeekEnd(dest);
			pnvmIterAssign(i, dest);
		}
	}
	return i;
}


/*	
	Returns number of net templates loaded after removal.
	At least one of arguments must be given. This can set codeWithHoles flag
	if there is a net template pointing to netTemlateCode after this one.
	
	:param index: points to the netTemplateTable to template to remove.
		If negative, index is found by tmpl address. If >=0 and tmpl is given
		and netTemplateTable contains nil at the index, template is deleted,
		but numberOfNetTemplates stays the same.
	:param tmpl: Net template address to remove. If not given, it's found in
		netTemplateTable by index.
	 */

static sqInt removeNetTemplateonIndex(PNVMTemplate *tmpl, sqInt index) {
	PNVMTemplate *ptr;
	sqInt tableIndex;

	assert((tmpl != null) || (index >= 0));
	assert((tmpl == null) || (interpreterProxy->isKindOf(tmpl,'PNVMTemplate')));
	assert((index < 0) || (index < MaxNetTemplates));
	if ((index >= 0) && (tmpl == null)) {
		tableIndex = index;
		ptr = netTemplateTable[index];
		assert(tmpl == ptr);
	} else {
		if ((tmpl != null) && (index < 0)) {
			tableIndex = 0;
			ptr = netTemplateTable[tableIndex];
			while (tmpl != ptr) {
				tableIndex += 1;
			}
		} else {
			tableIndex = index;
			ptr = tmpl;
			assert(((netTemplateTable[tableIndex]) == null) || (tmpl == (netTemplateTable[tableIndex])));
		}
	}
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("removing net template: ", dereference(tmpl)));
	if (!((netTemplateTable[tableIndex]) == null)) {
		numberOfNetTemplates -= 1;
		netTemplateTable[tableIndex] = null;
	}
	if ((getCodeSize()) > ((pnvmTemplateCodeOffset(tmpl)) + (pnvmTemplateCodeLength(tmpl)))) {
		codeWithHoles = 1;
	}
	pnvmValueDelete(pnvmTemplateName(tmpl));
	pnvmValueDelete(pnvmTemplatePlaces(tmpl));
	pnvmValueDelete(pnvmTemplateSymbols(tmpl));
	if (!((pnvmTemplateInstances(tmpl)) == null)) {
		pnvmValueDelete(pnvmTemplateInstances(tmpl));
	}
	pnvmValueDelete(tmpl);
	return numberOfNetTemplates;
}


/*	
	Wraps input string in double quotes and escapes any double quote and back-slash
	in it.
	
	:param str is a string block
	Return new string or NULL on error
	 */

static PNVMStringHead * renderAsString(PNVMStringHead const *str) {
	PNVMStringHead *res;
	PNVMStringIter o;

	assert(interpreterProxy->isKindOf(str,'PNVMStringHead'));
	if (((res = pnvmStringNew(PNVMStringHead))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmMemory", "error", "failed to allocate string for serialization of string object");
		return null;
	}
	o = pnvmValueIterator(res);
	if ((renderAsStringto(str, o)) < 0) {
		pnvmValueDelete(res);
		return null;
	}
	return res;
}


/*	
	Wraps input string in double quotes and escapes any double quote and back-slash
	in it.
	
	:param str: A String block
	:param o: An output String iterator
	Return number of items written or -1 on error.
	 */

static sqInt renderAsStringto(PNVMStringHead const *str, PNVMStringIter & o) {
	PNVMStringIter i;
	sqInt origWritePosition;

	assert(interpreterProxy->isKindOf(str,'PNVMStringHead'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(o)),'PNVMStringHead'));
	i = pnvmValueIterator(((PNVMStringHead *) str));
	origWritePosition = pnvmIterIndex(o);
	if (pnvmIterCanAppend(o)) {
		pnvmIterWrite(o, '"');
		while ((!(pnvmIterAtEnd(i))) && (pnvmIterCanAppend(o))) {
			if (((pnvmIterValue(i)) == '"') || ((pnvmIterValue(i)) == ('\\'))) {
				pnvmIterWrite(o, '\\');
				if (pnvmIterCanAppend(o)) {
					pnvmIterWrite(o, pnvmIterNext(i));
				}
			} else {
				if (((pnvmIterValue(i)) == ('\n')) || (((pnvmIterValue(i)) == ('\t')) || ((pnvmIterValue(i)) == ('\r')))) {
					pnvmIterWrite(o, '\\');
					if (pnvmIterCanAppend(o)) {
						pnvmIterWrite(o, ((pnvmIterValue(i)) == ('\n')
							? 'n'
							: ((pnvmIterValue(i)) == ('\t')
	? 't'
	: 'r')));
					}
					pnvmIterNext(i);
				} else {
					pnvmIterWrite(o, pnvmIterNext(i));
				}
			}
		}
	}
	if (pnvmIterCanAppend(o)) {
		pnvmIterWrite(o, '"');
	} else {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,("reached the max capacity of string, while rendering: ", asPlainString(str)));
		setError(ErrorCollectionFull);
		return -1;
	}
	return (pnvmIterIndex(o)) - origWritePosition;
}


/*	
	Restore action 'assign'. It's generated by : expression operator.
	
	Action contains following elements:
		[$:, variableId]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionAssignwithVariables(PNVMTupleIter ai, PNVMTupleHead *vars) {
	sqInt variableId;
	PNVMTupleIter vi;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)':')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
	vi = pnvmValueIterator(vars);
	variableId = pnvmTokenInteger(pnvmIterNext(ai));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("clearing assignment to variable ", variableId));
	pnvmIterSeek(vi, variableId);
	pnvmTokenMakeInvalid(pnvmIterValue(vi));
}


/*	
	Restore action creation of net instance. It's generated by $i or $c expression
	operators.
	
	Action contains following elements:
		[$l, instance]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionCreateInstance(PNVMTupleIter ai) {
	PNVMArrayIter iter;
	PNVMTemplate *tmpl;
	PNVMNetInstHead *inst;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert(((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'i'))) || ((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'c'))));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
	assert((pnvmTokenType(pnvmIterValue(ai))) == TokenTypeNetRef);
	inst = ((PNVMNetInstHead *) (pnvmTokenPointer(pnvmIterValue(ai))));
	if ((pnvmTemplateInstances(pnvmNetInstTemplate(inst))) == null) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "can not remove instance from template with no alive instances");
	} else {
		tmpl = pnvmNetInstTemplate(inst);
		iter = pnvmValueIterator(pnvmTemplateInstances(tmpl));
		while ((!(pnvmIterAtEnd(iter))) && ((pnvmTokenNetRef(pnvmIterValue(iter))) != inst)) {
			pnvmIterNext(iter);
		}
		if (pnvmIterAtEnd(iter)) {
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "can not remove not present instance from template");
		} else {

			/* let the garbage collector do the rest */

			removeItemFromBlockAt(pnvmIterAsItemIterator(iter));
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("removed instance from net template", tmpl));
		}
	}
}


/*	
	Restore action 'load template'. It's generated by l expression operator.
	
	Action contains following elements:
		[$l, index, template]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionLoadTemplate(PNVMTupleIter ai) {
	PNVMTemplate *tmpl;
	sqInt index;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'l')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 3);
	index = pnvmTokenInteger(pnvmIterNext(ai));
	tmpl = ((PNVMTemplate *) (pnvmTokenPointer(pnvmIterNext(ai))));
	removeNetTemplateonIndex(tmpl, index);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "restored action load template");
}


/*	
	Restore action 'push back'. It's generated by $a expression operator.
	
	Action contains following elements:
		[$a, array]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionPushBack(PNVMTupleIter ai) {
	PNVMArrayHead *array;
	PNVMArrayIter arrayIter;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'a')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
	array = ((PNVMArrayHead *) (pnvmTokenPointer(pnvmIterNext(ai))));
	arrayIter = pnvmValueIterator(array);
	pnvmIterSeek(arrayIter, (pnvmValueItemCount(array)) - 1);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,("removing last added item from collection ", array));
	removeItemFromBlockAt(pnvmIterAsItemIterator(arrayIter));
}


/*	
	Restore action put. It's generated by O transition element.
	
	Action contains following elements:
		[$O, inst, placeId, number, token]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionPut(PNVMTupleIter ai) {
	PNVMPlaceHead *place;
	PNVMNetInstIter ni;
	PNVMPlaceIter pi;
	sqInt placeId;
	PNVMNetInstHead *inst;
	PNVMToken token;
	sqInt found;
	sqInt number;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'O')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 5);
	inst = pnvmTokenNetRef(pnvmIterNext(ai));
	placeId = pnvmTokenInteger(pnvmIterNext(ai));
	number = pnvmTokenInteger(pnvmIterNext(ai));
	token = pnvmIterNext(ai);
	ni = pnvmValueIterator(inst);
	pnvmIterSeek(ni, placeId);
	place = pnvmIterValue(ni);
	pi = pnvmValueIterator(place);
	found = 0;
	while (!((pnvmIterAtEnd(pi)) && (!found))) {

		/* try to find token in place and restore its number */

		if ((cmpTokenwith(token, pnvmPlaceItemToken(pnvmIterValue(pi)))) == 0) {

			/* token found */

			categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,("taking back ", number), " of tokens: "), token), " to place "), placeId), " of instance "), inst));
			pnvmPlaceItemSetNumber(pnvmIterValue(pi), (pnvmPlaceItemNumber(pnvmIterValue(pi))) - number);
			found = 1;
		}
		pnvmIterNext(pi);
	}
	if (!(found)) {

		/* this must not happed for $O */

		dieWithmsgwithwith(ErrorExecutionUnspecified, "written token [1] not found in place [2] of instance ", token, placeId);
	}
}


/*	
	Restore action 'schedule put'. It's generated by $Y transition element.
	
	Action contains following elements:
		[$Y, event]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionSchedulePut(PNVMTupleIter ai) {
	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'Y')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "removing last added event from calendar");
	calRemoveEvent(((PNVMEvent *) (pnvmTokenPointer(pnvmIterNext(ai)))));
}


/*	
	Restore action 'send'. It's generated by $s expression operator.
	
	Action contains following elements:
		[$s, token]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionSend(PNVMTupleIter ai) {
	PNVMArrayIter bufIter;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'s')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
	bufIter = pnvmValueIterator(outputBuffer);
	pnvmIterSeek(bufIter, (pnvmValueItemCount(outputBuffer)) - 1);
	unlessdieWithmsg((cmpTokenwith(pnvmIterValue(bufIter), pnvmIterNext(ai))) == 0, ErrorExecutionUnspecified, "token appended to output buffer does not match");
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", "removing last added token from output buffer");
	removeItemFromBlockAt(pnvmIterAsItemIterator(bufIter));
}


/*	
	Restore action take. It's generated by P transition element.
	
	Action contains following elements:
		[$P, inst, placeId, position, number, token]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionTake(PNVMTupleIter ai) {
	PNVMPlaceIter pi;
	PNVMPlaceHead *place;
	PNVMNetInstHead *inst;
	PNVMNetInstIter ni;
	PNVMToken token;
	sqInt number;
	PNVMPlaceItem plcItem;
	PNVMPlaceIter src;
	sqInt position;
	sqInt placeId;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'P')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 6);
	inst = pnvmTokenNetRef(pnvmIterNext(ai));
	placeId = pnvmTokenInteger(pnvmIterNext(ai));
	position = pnvmTokenInteger(pnvmIterNext(ai));
	number = pnvmTokenInteger(pnvmIterNext(ai));
	token = pnvmIterNext(ai);
	ni = pnvmValueIterator(inst);
	pnvmIterSeek(ni, placeId);
	place = pnvmIterValue(ni);
	pi = pnvmValueIterator(place);
	if (position > (((int) (pnvmValueItemCount(place))))) {

		/* something wrong is going on */

		dieWithmsgwith(ErrorOutOfRange, "can not put back token on position > ", pnvmValueItemCount(place));
	}
	pnvmIterSeek(pi, position);
	if ((pnvmIterAtEnd(pi)) || ((cmpTokenwith(token, pnvmPlaceItemToken(pnvmIterValue(pi)))) != 0)) {

		/* token not found -> it has been deleted by current action; let's add it again */

		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,("writing back ", number), " of tokens: "), token), " to place "), placeId), " of instance "), dereference(inst)));
		if (pnvmIterAtEnd(pi)) {
			plcItem = pnvmPlaceItemNewof(PNVMPlaceItem, number, token);
			pnvmIterSetItem(pi, plcItem);
			pnvmPlaceItemMakeInvalid(plcItem);
		} else {

			/* we need to shift all the other tokens by one to the right */
			/* so we have space for our token on its original position */

			src = pi;
			pnvmIterSeekStart(pi);
			pnvmIterSeekEnd(src);
			plcItem = pnvmPlaceItemNewof(PNVMPlaceItem, number, token);
			pnvmIterSetItem(src, plcItem);
			pnvmPlaceItemMakeInvalid(plcItem);
			pnvmIterSeek(pi, (pnvmIterIndex(src)) - 1);
			while ((pnvmIterIndex(pi)) >= position) {

				/* shift them by swaping neighboring items from the rear */

				swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(pnvmIterBlockIndex(pi), pnvmIterCurrentBlock(pi), pnvmIterBlockIndex(src), pnvmIterCurrentBlock(src), TypeSignPlace, (pnvmIterHeaderBlock(pi)) == (pnvmIterCurrentBlock(pi)));
				pnvmIterAssign(src, pi);
				pnvmIterSeek(pi, (pnvmIterIndex(pi)) - 1);
			}
		}
	} else {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,(,(,(,(,(,(,("putting back ", number), " of tokens: "), token), " to place "), placeId), " of instance "), dereference(inst)), " at position "), position));
		pnvmPlaceItemSetNumber(pnvmIterValue(pi), (pnvmPlaceItemNumber(pnvmIterValue(pi))) + number);
	}
}


/*	
	Restore action 'send'. It's generated by $u expression operator.
	
	Action contains following elements:
		[$s, index, template]
	
	:param ai: is action iterator pointing at the second element of action
	 */

static void restoreActionUnload(PNVMTupleIter ai) {
	PNVMTemplate *tmpl;
	sqInt index;

	assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator'));
	assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((sqInt)'u')));
	assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 3);
	index = pnvmTokenInteger(pnvmIterNext(ai));
	tmpl = ((PNVMTemplate *) (pnvmTokenPointer(pnvmIterNext(ai))));
	netTemplateTable[index] = tmpl;
	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	numberOfNetTemplates += 1;
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,(,("put back template ", dereference(tmpl)), " at index="), index));
}


/*	
	History of actions made during transition execution needs to be restored any time
	one transition element fails. History is an array containing notes about modification
	of interpreter state in chronological order. This function reverts any action from
	the position of iterator (including current position) to the end of history array and
	releases allocated space.
	
	:param i: iterator to action in history. After the function completes, it will point at history
		end.
		
	Return iterator to current position (pointing at end).
	 */

static PNVMArrayIter restoreHistoryFromPoswithVariables(PNVMArrayIter & i, PNVMTupleHead *vars) {
	sqInt bc;
	PNVMArrayIter ii;

	assert(interpreterProxy->isKindOf(i,'PNVMItemIterator'));
	assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead'));
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", ,(,("entering restoreHistoryFromPos: ", pnvmIterIndex(i)), " withVariables:"));
	if (pnvmIterAtEnd(i)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving restoreHistoryFromPos:withVariables: (at end)");
	} else {
		if (!((((ItemCount_t) (pnvmIterIndex(i)))) == ((pnvmValueItemCount(pnvmIterHeaderBlock(i))) - 1))) {

			/* first restore the latest actions made */

			bc = pnvmValueBlockCount(pnvmIterHeaderBlock(i));
			ii = i;
			pnvmIterNext(ii);
			restoreHistoryFromPoswithVariables(ii, vars);
			if (bc > (((int) (pnvmValueBlockCount(pnvmIterHeaderBlock(i)))))) {
				pnvmIterSeekStart(i);
				pnvmIterSeek(i, (pnvmIterIndex(ii)) - 1);
			}
		}
		restoreTransactionActionwithVariables(((PNVMTupleHead *) (pnvmTokenPointer(pnvmIterValue(i)))), vars);
		removeItemFromBlockAt(pnvmIterAsItemIterator(i));
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving restoreHistoryFromPos:withVariables:");
	}
	return i;
}

static void restoreTransactionActionwithVariables(PNVMTupleHead *a, PNVMTupleHead *vars) {
	PNVMTupleIter ai;
	char kind;

	assert(interpreterProxy->isKindOf(a,'PNVMTupleHead'));
	ai = pnvmValueIterator(a);
	kind = pnvmTokenInteger(pnvmIterNext(ai));
	if (kind == (((sqInt)'P'))) {
		restoreActionTake(ai);
	} else {
		if (kind == (((sqInt)'O'))) {
			restoreActionPut(ai);
		} else {
			if (kind == (((sqInt)'l'))) {
				restoreActionLoadTemplate(ai);
			} else {
				if ((kind == (((sqInt)'i'))) || (kind == (((sqInt)'c')))) {
					restoreActionCreateInstance(ai);
				} else {
					if (kind == (((sqInt)':'))) {
						restoreActionAssignwithVariables(ai, vars);
					} else {
						if (kind == (((sqInt)'a'))) {
							restoreActionPushBack(ai);
						} else {
							if (kind == (((sqInt)'Y'))) {
								restoreActionSchedulePut(ai);
							} else {
								if (kind == (((sqInt)'u'))) {
									restoreActionUnload(ai);
								} else {
									if (kind == (((sqInt)'s'))) {
										restoreActionSend(ai);
									} else {
										dieWithmsgwith(ErrorExecutionUnhandledOperator, "unhandled action ro revert: ", kind);
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


/*	Return number of written characters, -1 on error. */

static sqInt serializeNameto(PNVMStringHead const *name, PNVMStringIter & o) {
	PNVMStringIter si;

	assert(interpreterProxy->isKindOf(name,'PNVMStringHead'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	si = pnvmValueIterator(((PNVMStringHead *) name));
	while ((!(pnvmIterAtEnd(si))) && (pnvmIterCanAppend(o))) {
		pnvmIterWrite(o, pnvmIterNext(si));
	}
	if (!(pnvmIterAtEnd(si))) {
		setError(ErrorCollectionFull);
		return -1;
	}
	return pnvmValueItemCount(name);
}


/*	Return number of written characters or -1 on error. */

static sqInt serializeNetInstto(PNVMNetInstHead const *inst, PNVMStringIter & o) {
	PNVMTemplate *tmpl;
	PNVMNetInstIter ni;
	sqInt origWritePosition;
	PNVMPlaceIter pi;
	PNVMPlaceItem placeItem;
	PNVMTupleIter pni;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	origWritePosition = pnvmIterIndex(o);
	if (!(pnvmIterCanAppend(o))) {
		setError(ErrorCollectionFull);
		return -1;
	}
	pnvmIterWrite(o, '(');
	if (!(pnvmIterCanAppend(o))) {
		setError(ErrorCollectionFull);
		return -1;
	}
	pnvmIterWrite(o, 'n');
	tmpl = pnvmNetInstTemplate(inst);
	if ((serializeNameto(pnvmTemplateName(tmpl), o)) < 0) {
		return -1;
	}
	ni = pnvmValueIterator(((PNVMNetInstHead *) inst));
	pni = pnvmValueIterator(pnvmTemplatePlaces(tmpl));
	while ((!(pnvmIterAtEnd(ni))) && (pnvmIterCanAppend(o))) {
		pnvmIterWrite(o, '(');
		if (!(pnvmIterCanAppend(o))) {
			setError(ErrorCollectionFull);
			return -1;
		}
		pnvmIterWrite(o, 'p');
		if (!(pnvmIterCanAppend(o))) {
			setError(ErrorCollectionFull);
			return -1;
		}
		if ((serializeNameto(((PNVMStringHead *) (pnvmTokenPointer(pnvmIterNext(pni)))), o)) < 0) {
			return -1;
		}
		pi = pnvmValueIterator(pnvmIterNext(ni));
		while (!(pnvmIterAtEnd(pi))) {
			placeItem = pnvmIterNext(pi);
			if (!(pnvmIterCanAppend(o))) {
				setError(ErrorCollectionFull);
				return -1;
			}
			pnvmIterWrite(o, '(');
			if (!(pnvmIterCanAppend(o))) {
				setError(ErrorCollectionFull);
				return -1;
			}
			pnvmIterWrite(o, 't');
			if ((serializeNumberto(pnvmPlaceItemNumber(placeItem), o)) < 0) {
				return -1;
			}
			if (!(pnvmIterCanAppend(o))) {
				setError(ErrorCollectionFull);
				return -1;
			}
			pnvmIterWrite(o, ',');
			if ((serializeNetInstValueofTemplateto(pnvmPlaceItemToken(placeItem), tmpl, o)) < 0) {
				return -1;
			}
			if (!(pnvmIterCanAppend(o))) {
				setError(ErrorCollectionFull);
				return -1;
			}
			pnvmIterWrite(o, ')');
		}
		if (!(pnvmIterCanAppend(o))) {
			setError(ErrorCollectionFull);
			return -1;
		}
		pnvmIterWrite(o, ')');
	}
	if (pnvmIterCanAppend(o)) {
		pnvmIterWrite(o, ')');
		return (pnvmIterIndex(o)) - origWritePosition;
	} else {
		setError(ErrorCollectionFull);
		return -1;
	}
}


/*	Return number of written characters or -1 on error. */

static sqInt serializeNetInstValueofTemplateto(PNVMToken const & token, PNVMTemplate *tmpl, PNVMStringIter & o) {
	PNVMTupleIter si;
	sqInt origWritePosition;
	PNVMTupleHead const *symbols;

	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	origWritePosition = pnvmIterIndex(o);
	if ((pnvmTokenType(token)) == TokenTypeInteger) {
		return serializeNumberto(pnvmTokenInteger(token), o);
	} else {
		if ((pnvmTokenType(token)) == TokenTypeNetRef) {
			return serializeNetInstto(pnvmTokenNetRef(token), o);
		} else {

			/* try to find, whether token value does not belong to template symbols to save space */

			symbols = pnvmTemplateSymbols(tmpl);
			si = pnvmValueIterator(((PNVMTupleHead *) symbols));
			while ((!(pnvmIterAtEnd(si))) && (((pnvmTokenType(pnvmIterValue(si))) != TokenTypePointer) || ((pnvmTokenPointer(pnvmIterValue(si))) != (pnvmTokenPointer(token))))) {
				pnvmIterNext(si);
			}
			if (pnvmIterAtEnd(si)) {

				/* token not found among net template's symbols */

				return serializeValueto(pnvmTokenPointer(token), o);
			} else {

				/*  token found among symbols */

				if (pnvmIterCanAppend(o)) {
					pnvmIterWrite(o, 'S');
					serializeNumberto(pnvmIterIndex(si), o);
				} else {
					setError(ErrorCollectionFull);
					return -1;
				}
			}
		}
	}
	return (pnvmIterIndex(o)) - origWritePosition;
}

static sqInt serializeNumberto(sqInt num, PNVMStringIter & o) {
	char buf[15];
	long tmp;
	sqInt i;
	sqInt origWritePosition;
	sqInt n;

	assert(interpreterProxy->isKindOf(num,'Number'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	origWritePosition = pnvmIterIndex(o);
	if (!(pnvmIterCanAppend(o))) {
		setError(ErrorCollectionFull);
		return -1;
	}
	if (num < 0) {
		pnvmIterWrite(o, '-');
	}
	tmp = abs(num);
	if (!(pnvmIterCanAppend(o))) {
		setError(ErrorCollectionFull);
		return -1;
	}
	if (tmp < 10) {
		pnvmIterWrite(o, (((sqInt)'0')) + tmp);
	} else {
		n = 0;
		;
		while (tmp > 0) {
			buf[n] = ((((sqInt)'0')) + (tmp % 10));
			tmp = tmp / 10;
			n += 1;
		}
		for (i = 1; i <= n; i += 1) {
			if (!(pnvmIterCanAppend(o))) {
				setError(ErrorCollectionFull);
				return -1;
			}
			pnvmIterWrite(o, buf[n - i]);
		}
	}
	return (pnvmIterIndex(o)) - origWritePosition;
}


/*	Return number of characters written or -1 on error. */

static sqInt serializeTokento(PNVMToken const & token, PNVMStringIter & o) {
	assert(interpreterProxy->isKindOf(token,'PNVMToken'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	if ((pnvmTokenType(token)) == TokenTypeInteger) {
		return serializeNumberto(pnvmTokenInteger(token), o);
	} else {
		if ((pnvmTokenType(token)) == TokenTypeNetRef) {
			return serializeNetInstto(pnvmTokenNetRef(token), o);
		} else {
			return serializeValueto(pnvmTokenPointer(token), o);
		}
	}
}


/*	
	Return number of characters written or -1 on error.
	 */

static sqInt serializeValueto(PNVMHeaderBlock const *block, PNVMStringIter & o) {
	PNVMArrayIter ai;
	sqInt origWritePosition;
	PNVMTupleIter ti;

	assert(interpreterProxy->isKindOf(block,'PNVMHeaderBlock'));
	assert(interpreterProxy->isKindOf(o,'PNVMItemIterator'));
	origWritePosition = pnvmIterIndex(o);
	if ((signature(block)) == TypeSignString) {
		return renderAsStringto(((PNVMStringHead const *) block), o);
	} else {
		if ((signature(block)) == TypeSignArray) {
			ai = pnvmValueIterator(((PNVMArrayHead *) block));
			if (pnvmIterCanAppend(o)) {
				pnvmIterWrite(o, '{');
				while ((!(pnvmIterAtEnd(ai))) && (pnvmIterCanAppend(o))) {
					if ((serializeTokento(pnvmIterNext(ai), o)) < 0) {
						return -1;
					}
					if ((!(pnvmIterAtEnd(ai))) && (pnvmIterCanAppend(o))) {
						pnvmIterWrite(o, ',');
					}
				}
			}
			if (pnvmIterCanAppend(o)) {
				pnvmIterWrite(o, '}');
			} else {
				categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to serialize array: output buffer full");
				setError(ErrorCollectionFull);
				return -1;
			}
		} else {
			if ((signature(block)) == TypeSignTuple) {
				ti = pnvmValueIterator(((PNVMTupleHead *) block));
				if (pnvmIterCanAppend(o)) {
					pnvmIterWrite(o, '[');
					while ((!(pnvmIterAtEnd(ti))) && (pnvmIterCanAppend(o))) {
						if ((serializeTokento(pnvmIterNext(ti), o)) < 0) {
							return -1;
						}
						if ((!(pnvmIterAtEnd(ti))) && (pnvmIterCanAppend(o))) {
							pnvmIterWrite(o, ',');
						}
					}
				}
				if (pnvmIterCanAppend(o)) {
					pnvmIterWrite(o, ']');
				} else {
					categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "failed to serialize tuple: output buffer full");
					setError(ErrorCollectionFull);
					return -1;
				}
			} else {
				if ((signature(block)) == TypeSignNetInst) {
					return serializeNetInstto(((PNVMNetInstHead const *) block), o);
				} else {
					dieWithmsgwith(ErrorExecutionUnhandledSignature, "don't know how to serialize ", dereference(block));
				}
			}
		}
	}
	return (pnvmIterIndex(o)) - origWritePosition;
}


/*	
	This sets the error code to 'err' only if the current error code is Success.
	This is done to prevent overriding specific error by more general one by caller function,
	which failed due to a failure of called function (which set the specific error code).
	
	Note that this flag is reset to Success at the beginning of each step. Error code should
	be handled in the main loop.
	
	Return saved error code after assignment.
	 */

EXPORT(Error_t) setError(Error_t err) {
	;
	if ((err == ErrorSuccess) || (error == ErrorSuccess)) {
		error = err;
	}
	return error;
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter) {
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

static bool setInvalidResult(PNVMToken & result) {
	assert(interpreterProxy->isKindOf(result,'PNVMToken'));
	pnvmTokenMakeInvalid(result);
	return 0;
}


/*	
	Utility function for writing item to generic iterator.
	It does type checking and retypes iterator to correct one.
	Token or placeitem values must be referenced with 'makePointer()'.
	 */

static void setValueItemat(void *item, PNVMItemIterator & i) {
	PNVMPlaceHead *place;

	assert(((signature(pnvmIterHeaderBlock(i))) != TypeSignString) || ((interpreterProxy->isKindOf(item,'Character')) || (interpreterProxy->isKindOf(item,'Number'))));
	assert(((signature(pnvmIterHeaderBlock(i))) != TypeSignArray) || (interpreterProxy->isKindOf(item,'PNVMToken')));
	assert(((signature(pnvmIterHeaderBlock(i))) != TypeSignTuple) || (interpreterProxy->isKindOf(item,'PNVMToken')));
	assert(((signature(pnvmIterHeaderBlock(i))) != TypeSignNetInst) || (interpreterProxy->isKindOf(item,'PNVMPlaceHead')));
	assert(((signature(pnvmIterHeaderBlock(i))) != TypeSignPlace) || (interpreterProxy->isKindOf(item,'PNVMPlaceItem')));
	if ((signature(pnvmIterHeaderBlock(i))) == TypeSignString) {
		pnvmIterSetItem(pnvmIterString(i), dereference(((char const *) item)));
	} else {
		if ((signature(pnvmIterHeaderBlock(i))) == TypeSignArray) {
			pnvmIterSetItem(pnvmIterArray(i), dereference(((PNVMToken *) item)));
		} else {
			if ((signature(pnvmIterHeaderBlock(i))) == TypeSignTuple) {
				pnvmIterSetItem(pnvmIterTuple(i), dereference(((PNVMToken *) item)));
			} else {
				if ((signature(pnvmIterHeaderBlock(i))) == TypeSignNetInst) {
					place = ((PNVMPlaceHead *) item);
					pnvmIterSetItem(pnvmIterNetInst(i), place);
				} else {
					if ((signature(pnvmIterHeaderBlock(i))) == TypeSignPlace) {
						pnvmIterSetItem(pnvmIterPlace(i), dereference(((PNVMPlaceItem *) item)));
					} else {
						dieWithmsgwith(ErrorExecutionUnhandledSignature, "unhandled block type ", dereference(pnvmIterHeaderBlock(i)));
					}
				}
			}
		}
	}
}


/*	
	Make one step of interpreter.
		1st		- check input buffer and output of platform
		2nd		- process calendar events
		3rd		- try to fire any transition of all net instances
		4th		- if any holes in code or net template table arised, squash them
				- prevent code fragmentation and keep the loop swift
	 */

static Error_t step(void) {
	bool templateTableHoley;
	sqInt tmplId;
	sqInt i;
	sqInt src;
	sqInt dest;

	categorylevelmessage(LoggingEvent, "pnvmExecuting", "info", ,(,("------------ STEP ", stepCounter), " ------------"));

	/* reset error flag */

	nothingChanged = 1;
	setError(ErrorSuccess);
	if (!((inputOutput()) == ErrorSuccess)) {
		categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", "input output failed");
		return error;
	}
	updateTime();
	calendarEvent();
	templateTableHoley = 0;
	tmplId = 0;
	while ((tmplId < numberOfNetTemplates) && ((tmplId < MaxNetTemplates) && (!(error != ErrorSuccess)))) {

		/* for every template: process its instances */

		if ((netTemplateTable[tmplId]) == null) {
			templateTableHoley = 1;
		} else {

			/* 
			template could be unloaded during this step
			that's why we need to check for nil
			 */

			processTemplateInstances(netTemplateTable[tmplId]);
		}
		tmplId += 1;
	}
	if (codeWithHoles) {

		/* squash code blocks together */

		fillCodeHoles();
	}
	if (templateTableHoley) {

		/* squash net templates together */

		/* begin squashNetTemplateTable */
		dest = 0;
		src = 0;
		for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
			while ((netTemplateTable[src]) == null) {
				src += 1;
			}
			if (!(dest == src)) {
				netTemplateTable[dest] = (netTemplateTable[src]);
				netTemplateTable[src] = null;
			}
			dest += 1;
			src += 1;
		}
	}
	stepCounter += 1;
	categorylevelmessage(LoggingEvent, "pnvmExecuting", "debug", "leaving step");
	return error;
}


/*	
	Gets the error description for error code.
	Arduino can not have this much error messages compiled in binary - they occupy
	data segment (SRAM), which is precious. Arduino will just send error code over
	serial line.
	 */

EXPORT(char const *) strError(Error_t err) {
	char const * arr[ErrorGenericLast + (ErrorParsingLast - ErrorParsingFirst) + (ErrorExecutionLast - ErrorExecutionFirst) + (ErrorIOLast - ErrorIOFirst)] = { NULL };
	sqInt offset;
	char const *res;

	assert(interpreterProxy->isKindOf(err,'Number'));
	res = null;
	
# ifndef TARGET_ARDUINO
	;
	arr[ErrorUnspecified] = "unspecified error";
	arr[ErrorNoMemory] = "not memory";
	arr[ErrorOutOfRange] = "index out of range";
	arr[ErrorCollectionFull] = "collection full";
	offset = ErrorGenericLast - ErrorParsingFirst;
	arr[offset + ErrorParsingTemplate] = "failed to parse net template";
	arr[offset + ErrorParsingTemplateSymbols] = "failed to parse template symbols";
	arr[offset + ErrorParsingNames] = "failed to parse names";
	arr[offset + ErrorParsingUplinks] = "failed to parse uplinks";
	arr[offset + ErrorParsingInit] = "failed to parse init transition";
	arr[offset + ErrorParsingTransitions] = "failed to parse transitions";
	arr[offset + ErrorParsingUplink] = "failed to parse uplink transition";
	arr[offset + ErrorParsingTransition] = "failed to parse transition";
	arr[offset + ErrorParsingTransitionCode] = "failed to parse transition elements";
	arr[offset + ErrorParsingExpression] = "failed to expression";
	arr[offset + ErrorParsingSymbol] = "failed to parse symbol";
	arr[offset + ErrorParsingToken] = "failed to parse token";
	arr[offset + ErrorParsingCollection] = "failed to parse collection";
	arr[offset + ErrorParsingString] = "failed to parse string";
	arr[offset + ErrorParsingNetInst] = "failed to parse net instance";
	arr[offset + ErrorParsingPlace] = "failed to parse net instance place";
	arr[offset + ErrorParsingNetInstValue] = "failed to parse value of net instance";
	arr[offset + ErrorNoSuchPlace] = "no such place in net template of instance";
	offset = (ErrorGenericLast + (ErrorParsingLast - ErrorParsingFirst)) - ErrorExecutionFirst;
	arr[offset + ErrorExecutionUnspecified] = "generic execution error";
	arr[offset + ErrorTemplatesDatabaseFull] = "net template database full";
	arr[offset + ErrorNoSuchUplink] = "no such uplink in given net template";
	arr[offset + ErrorNoSuchTemplate] = "no such template in database";
	arr[offset + ErrorCalendarEmpty] = "calendar empty";
	arr[offset + ErrorExecutionUnhandledOperator] = "requested operator not missing implementation";
	arr[offset + ErrorExecutionUnhandledTransitionElement] = "unexpected transition element";
	arr[offset + ErrorInitFailed] = "failed to execute init transition";
	offset = (((ErrorGenericLast + (ErrorParsingLast - ErrorParsingFirst)) + (ErrorExecutionLast - ErrorExecutionFirst)) + (ErrorIOLast - ErrorIOFirst)) - ErrorIOLast;
	res = arr[err];
	
# endif
	return res;
}

static char * stringToCStr(PNVMStringHead const *str) {
	char *res;

	assert(interpreterProxy->isKindOf(str,'PNVMStringHead'));
	res = ((char *) (malloc(pnvmValueItemCount(str) + 1)));
	PNVMStringIter i = pnvmValueIterator((PNVMStringHead *) str);
	while (!pnvmIterAtEnd(i)) {res[pnvmIterIndex(i)] = pnvmIterNext(i);}
	res[pnvmIterIndex(i)] = 0;
	return res;
}


/*	
	Swap two items of two blocks without any change to reference counts.
	First block may be identical with second one. In case, that they are no identical,
	the second block must be tail.
	
	:param i1: Index to the item of block b1.
	:param i2: Index to the item of block b2.
	:param isFirstBlockHead: Whether the first block is header block.
	
	*Note* this code treats both blocks as last tail blocks.
	 */

static void swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(sqInt i1, void *b1, sqInt i2, void *b2, sqInt sig, sqInt isHead) {
	void *item;

	;
	
#define swapWithCorrectTypes(block1Type, block2Type, itemType, i1, b1, i2, b2) \
		itemType item = dereference((block1Type *) b1)[i1]; \
		dereference((block1Type *) b1)[i1] = dereference((block2Type *) b2)[i2]; \
		dereference((block2Type *) b2)[i2] = item
	
#define swapHeadOrTailTypes(type, itemType) \
		if (b1 == b2) { \
			if (isHead) { \
				swapWithCorrectTypes(PNVM ## type ##Head, PNVM ## type ##Head, itemType, i1, b1, i2, b2); \
			} else { \
				swapWithCorrectTypes(PNVM ## type ##Tail, PNVM ## type ##Tail, itemType, i1, b1, i2, b2); \
			} \
		} else { \
			if (isHead) { \
				swapWithCorrectTypes(PNVM ## type ##Head, PNVM ## type ##Tail, itemType, i1, b1, i2, b2); \
			} else { \
				swapWithCorrectTypes(PNVM ## type ##Tail, PNVM ## type ##Tail, itemType, i1, b1, i2, b2); \
			} \
		}
	switch (sig) {
		case TypeSignArray:	swapHeadOrTailTypes(Array, PNVMToken); break;
#ifndef TARGET_ARDUINO		
		case TypeSignTuple:	swapHeadOrTailTypes(Tuple, PNVMToken); break;
#endif
		case TypeSignString:	swapHeadOrTailTypes(String, char); break;
		case TypeSignNetInst:	swapHeadOrTailTypes(NetInst, PNVMPlaceHead*); break;
		case TypeSignPlace:	swapHeadOrTailTypes(Place, PNVMPlaceItem); break;
	}
}


/*	
	Remove instance from array of template instances.
	 */

EXPORT(void) unmanageNetInstance(PNVMNetInstHead *inst) {
	PNVMArrayIter i;
	PNVMTemplate *tmpl;

	assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead'));

	/* we may be in the cleanup procedure -> instances array may already be freed */

	tmpl = pnvmNetInstTemplate(inst);
	if (!((pnvmTemplateInstances(tmpl)) == null)) {
		i = pnvmValueIterator(pnvmTemplateInstances(tmpl));
		while ((!(pnvmIterAtEnd(i))) && ((pnvmTokenNetRef(pnvmIterValue(i))) != inst)) {
			pnvmIterNext(i);
		}
		if (pnvmIterAtEnd(i)) {
			categorylevelmessage(LoggingEvent, "pnvmExecuting", "error", ,(,("could not find net instance in template instances of '", asPlainString(pnvmTemplateName(tmpl))), "'"));
		} else {
			removeItemFromBlockAt(pnvmIterAsItemIterator(i));
		}
	}
}


/*	time is set to current unix time in milliseconds */

static void updateTime(void) {
	sqInt dt;

	currentTime = millis();
}


/*	
	Utility function for writing item to generic iterator.
	It does type checking and retypes iterator to correct one.
	Token or placeitem values must be referenced with 'makePointer()'.
	 */

static void writeValueItemat(void *item, PNVMItemIterator & i) {
	setValueItemat(item, i);
	pnvmIterNext(i);
}


#ifdef SQUEAK_BUILTIN_PLUGIN


void* PNVM_exports[][3] = {
	{"PNVM", "primitiveInstantiateTemplate", (void*)primitiveInstantiateTemplate},
	{"PNVM", "primitiveCurrentTime", (void*)primitiveCurrentTime},
	{"PNVM", "primitiveStepsExecuted", (void*)primitiveStepsExecuted},
	{"PNVM", "initializeOMModule", (void*)initializeOMModule},
	{"PNVM", "strError", (void*)strError},
	{"PNVM", "getModuleName", (void*)getModuleName},
	{"PNVM", "primitiveInputString", (void*)primitiveInputString},
	{"PNVM", "cstrToString", (void*)cstrToString},
	{"PNVM", "setInterpreter", (void*)setInterpreter},
	{"PNVM", "primitiveNumberOfNetTemplates", (void*)primitiveNumberOfNetTemplates},
	{"PNVM", "primitiveCodeIteratorAt", (void*)primitiveCodeIteratorAt},
	{"PNVM", "primitiveCleanupModule", (void*)primitiveCleanupModule},
	{"PNVM", "inputString", (void*)inputString},
	{"PNVM", "primitiveCodeSize", (void*)primitiveCodeSize},
	{"PNVM", "primitiveCalFront", (void*)primitiveCalFront},
	{"PNVM", "primitiveInputCStr", (void*)primitiveInputCStr},
	{"PNVM", "setError", (void*)setError},
	{"PNVM", "primitiveOutputPopMessage", (void*)primitiveOutputPopMessage},
	{"PNVM", "primitiveMakePlatformTemplateplaceCountplacessymbolscodeLengthtransitions", (void*)primitiveMakePlatformTemplateplaceCountplacessymbolscodeLengthtransitions},
	{"PNVM", "primitiveParseNetTemplate", (void*)primitiveParseNetTemplate},
	{"PNVM", "unmanageNetInstance", (void*)unmanageNetInstance},
	{"PNVM", "canAllocateBlock", (void*)canAllocateBlock},
	{"PNVM", "primitiveRenderAsString", (void*)primitiveRenderAsString},
	{"PNVM", "primitiveOutputBufferEmpty", (void*)primitiveOutputBufferEmpty},
	{"PNVM", "primitiveSerializeTokento", (void*)primitiveSerializeTokento},
	{"PNVM", "primitiveSerializeValueto", (void*)primitiveSerializeValueto},
	{"PNVM", "primitiveCleanup", (void*)primitiveCleanup},
	{"PNVM", "primitiveFailed", (void*)primitiveFailed},
	{"PNVM", "failed", (void*)failed},
	{"PNVM", "primitiveNetTemplateAt", (void*)primitiveNetTemplateAt},
	{"PNVM", "getError", (void*)getError},
	{"PNVM", "primitiveOutputPopCStr", (void*)primitiveOutputPopCStr},
	{"PNVM", "primitiveNothingChanged", (void*)primitiveNothingChanged},
	{"PNVM", "primitiveStep", (void*)primitiveStep},
	{"PNVM", "primitiveCalIsEmpty", (void*)primitiveCalIsEmpty},
	{"PNVM", "primitiveLoadNetTemplate", (void*)primitiveLoadNetTemplate},
	{"PNVM", "initializeModule", (void*)initializeModule},
	{"PNVM", "primitiveStringToCStr", (void*)primitiveStringToCStr},
	{NULL, NULL, NULL}
};


#endif /* ifdef SQ_BUILTIN_PLUGIN */

