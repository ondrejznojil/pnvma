#include "pnvm_plugin.h"
#ifndef TARGET_ARDUINO
    #include <ctype.h>
#endif
#ifndef PLATFORM_CODE
    #define PLATFORM_CODE {0}
#endif

/* Smalltalk from Squeak4.6 with VMMaker 4.12.3 translated as C source on 25 June 2016 3:47:46 pm */
/* Automatically generated by
    SmartSyntaxPluginCodeGenerator VMMaker-dtl.319 uuid: d058d88c-331d-47ef-b178-fd26ca3de120
   from
    PNVM * SmallDEVS-PNVM-MM.11 uuid: f8490799-7849-4e98-9ee7-ad2070c4934d
 */





/* Default EXPORT macro that does nothing (see comment in sq.h): */

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
/* Configuration options */
/* Platform specific definitions */




/*** Constants ***/
#define HighestPin 16
#define LowestPin 0
#define MaxNetTemplates 10

/*** Function Prototypes ***/
static void appendActiontoHistoryWith(PNVMTupleHead *a, PNVMArrayIter & o);
static int appendNetTemplate(PNVMTemplate *tmpl);
static Error_t bindVariableswithParamsmappinghistory(PNVMTupleHead *vars, PNVMTupleHead const *params, PNVMTupleHead const *mapping, PNVMArrayIter & history);
static PNVMEvent * calFront(void);
static PNVMEvent * calPop(void);
static void calRemoveEvent(PNVMEvent *event);
static PNVMEvent * calScheduletimestoPlaceofInstat(PNVMToken & token, int n, int placeId, PNVMNetInstHead *netInst, Time_t time);
static void calendarEvent(void);
static PNVMItemIterator changeBlockSizeOfto(PNVMHeaderBlock *block, unsigned int size);
static bool charisOneOf(int c, char const *str);
static bool charIsBlank(int c);
static PNVMArrayIter cleanLastAttemptsFromPos(PNVMArrayIter & i);
static void cleanupOMModule(void);
static PNVMArrayIter clearVariableAssignments(PNVMArrayIter & history);
static int cmpPointerwith(PNVMHeaderBlock const *a, PNVMHeaderBlock const *b);
static int cmpStringwith(PNVMStringHead const *a, PNVMStringHead const *b);
static int cmpTokenwith(PNVMToken const & a, PNVMToken const & b);
static int codeGetVariableCount(char const * & codeptr);
static void codeSeekSkipExpression(char const * & codeptr);
static void codeSeekSkipTransition(char const * & codeptr);
static void codeSeekSkipTransitionElement(char const * & codeptr);
static void codeSeekSkipTransitionElements(char const * & codeptr);
static void codeSeekSkipVariables(char const * & codeptr);
static int codeStoreOffsettoRef(char const *codeptr, char const *& ref);
static int copyValueItemsFromto(PNVMItemIterator & src, PNVMItemIterator & dest);
static int copyValueNitemsFromto(int n, PNVMItemIterator & src, PNVMItemIterator & dest);
static PNVMToken createNetInstanceFrom(PNVMTemplate *tmpl);
static bool evalAddto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalAndto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalAssignatCodewithVariablestohistory(PNVMToken const & tokenA, PNVMToken & tokenB, char const * & codeptr, PNVMTupleHead *vars, PNVMToken & result, PNVMArrayIter & history);
static bool evalConcatenateto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalDividedto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalGetto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalIsEqualToto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalIsGreaterThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalIsSmallerThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalMinusto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalModuloto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalOrto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalPushBacktohistory(PNVMToken & tokenA, PNVMToken & tokenB, PNVMToken & result, PNVMArrayIter & history);
static bool evalTimesto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalXorto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evalCreateNetInstto(PNVMToken const & token, PNVMToken & result);
static bool evalDumpto(PNVMNetInstHead const *inst, PNVMToken & result);
static bool evalHeadto(PNVMToken const & token, PNVMToken & result);
static bool evalIsArrayto(PNVMToken const & token, PNVMToken & result);
static bool evalIsIntegerto(PNVMToken const & token, PNVMToken & result);
static bool evalIsNetRefto(PNVMToken const & token, PNVMToken & result);
static bool evalIsStringto(PNVMToken const & token, PNVMToken & result);
static bool evalIsTrue(PNVMToken const & token);
static bool evalIsTupleto(PNVMToken const & token, PNVMToken & result);
static bool evalIsValidto(PNVMToken const & token, PNVMToken & result);
static bool evalLoadNetInstto(PNVMToken const & token, PNVMToken & result);
static bool evalLoadTemplatetohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history);
static bool evalNewto(char elem, PNVMToken & result);
static bool evalNotto(PNVMToken const & token, PNVMToken & result);
static bool evalReadPinto(PNVMToken const & token, PNVMToken & result);
static bool evalSendtohistory(PNVMToken & token, PNVMToken & result, PNVMArrayIter & history);
static bool evalTailto(PNVMToken const & token, PNVMToken & result);
static bool evalUnloadtohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history);
static bool evalWriteAtValueto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result);
static bool evaluateExpressionAtontowithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMToken & result, PNVMTupleHead *vars, PNVMArrayIter & history);
static bool executeDownlinkonwithParameterslastAttempthistory(PNVMStringHead const *name, PNVMNetInstHead *inst, PNVMTupleHead *params, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executeDownlinkAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executeOneTransitionElementAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executePutTokenAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history);
static bool executeSchedulePutAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history);
static bool executeTakeTokenAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static bool executeTransitionElementsAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history);
static int fillCodeHoles(void);
static PNVMTemplate * findNetTemplate(PNVMStringHead const *name);
static char const * findUplinkin(PNVMStringHead const *name, PNVMTemplate const *tmpl);
static char * getCodeIteratorAt(int pos);
static CodeLength_t getCodeSize(void);
static PNVMToken getTokenForValueOnPosinTemplatewithVariables(char const * & codeptr, PNVMTemplate const *tmpl, PNVMTupleHead *vars);
static Error_t initializeNetInstance(PNVMNetInstHead *inst);
static bool inputMessage(char const *message);
static Error_t inputOutput(void);
static PNVMNetInstHead * instantiateTemplate(int tmplId);
static int loadNetTemplate(char const *  code);
static PNVMToken manageNetInstance(PNVMNetInstHead *inst);
static uint32_t memLoadLong(char const *mem);
static uint16_t memLoadShort(char const *mem);
static char * memStoreLongto(uint32_t value, char *mem);
static char * memStoreShortto(uint16_t value, char *mem);
static PNVMStringHead * outputPopMessage(void);
static void outputValue(PNVMToken const & token);
static PNVMArrayHead * parseArrayallowNetInst(PNVMStringIter & i, int allowNetInst);
static PNVMStringHead * parseCString(char const * & str);
static int parseCodeto(PNVMStringIter & i, char **outptr);
static int parseCollectionstartingWithendingWithtoallowNetInst(PNVMStringIter & i, int start, int end, PNVMItemIterator & o, int allowNetInst);
static int parseExpCharfromto(int character, PNVMStringIter & i, char **outptr);
static int parseExpressionto(PNVMStringIter & i, char **outptr);
static int parseInitto(PNVMStringIter & i, char **outptr);
static int parseIntegerto(PNVMStringIter & i, char **outptr);
static int parseLongIntegerto(PNVMStringIter & i, char **outptr);
static PNVMStringHead * parseName(PNVMStringIter & i);
static int parseNameto(PNVMStringIter & i, char **outptr);
static PNVMTupleHead * parseNames(PNVMStringIter & i);
static int parseNamesto(PNVMStringIter & i, char **outptr);
static PNVMToken parseNetInstValueofTemplate(PNVMStringIter & i, PNVMTemplate const *tmpl);
static PNVMNetInstHead * parseNetInstance(PNVMStringIter & i);
static PNVMTemplate * parseNetTemplate(PNVMStringIter & i);
static PNVMToken parseNumber(PNVMStringIter & i);
static PNVMPlaceHead * parsePlaceofTemplateto(PNVMStringIter & i, PNVMTemplate const *tmpl, PNVMNetInstIter & netInstIter);
static int parsePosIntegerto(PNVMStringIter & i, char **outptr);
static void parseSkipBlanks(PNVMStringIter & iterator);
static int parseSkipBlanksexpecting(PNVMStringIter & iterator, int character);
static int parseSkipBlanksuntil(PNVMStringIter & iterator, int character);
static int parseSkipBlanksuntilOneOf(PNVMStringIter & iterator, char const *string);
static int parseSkipBlanksComma(PNVMStringIter & i);
static int parseSkipBlanksLBto(PNVMStringIter & i, char **outptr);
static int parseSkipBlanksRBto(PNVMStringIter & i, char **outptr);
static int parseStoreOffsettoPtr(char *off, char **ptr);
static PNVMStringHead * parseString(PNVMStringIter & i);
static PNVMToken parseSymbolallowNetInst(PNVMStringIter & i, int allowNetInst);
static PNVMTupleHead * parseSymbols(PNVMStringIter & i);
static PNVMToken parseToken(PNVMStringHead *str);
static int parseTransitionto(PNVMStringIter & i, char **outptr);
static int parseTransitionsto(PNVMStringIter & i, char **outptr);
static PNVMTupleHead * parseTupleallowNetInst(PNVMStringIter & i, int allowNetInst);
static int parseUplinkto(PNVMStringIter & i, char **outptr);
static int parseUplinksto(PNVMStringIter & i, char **outptr);
static int parseValueto(PNVMStringIter & i, char **outptr);
static int placeIndexin(PNVMStringHead const *name, PNVMTemplate const *tmpl);
static Error_t processTemplateInstances(PNVMTemplate *tmpl);
static Error_t processTemplateInstancesonTransitionwithVariables(PNVMArrayHead *instances, char const *codeptr, PNVMTupleHead *vars);
static Error_t processTransitiononNetInstwithVariables(char const *codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars);
static int putNtokenstoPlaceofNetInst(int number, PNVMToken & token, int placeId, PNVMNetInstHead *inst);
static void releaseHistory(PNVMArrayHead *history);
static void releaseItemAtPos(PNVMItemIterator & i);
static PNVMItemIterator releaseItemsFromPos(PNVMItemIterator & i);
static void releaseItemsWithBlocksFromPos(PNVMItemIterator & i);
static PNVMItemIterator removeItemFromBlockAt(PNVMItemIterator & i);
static int removeNetTemplateonIndex(PNVMTemplate *tmpl, int index);
static PNVMStringHead * renderAsString(PNVMStringHead const *str);
static int renderAsStringto(PNVMStringHead const *str, PNVMStringIter & o);
static void restoreActionAssignwithVariables(PNVMTupleIter ai, PNVMTupleHead *vars);
static void restoreActionCreateInstance(PNVMTupleIter ai);
static void restoreActionLoadTemplate(PNVMTupleIter ai);
static void restoreActionPushBack(PNVMTupleIter ai);
static void restoreActionPut(PNVMTupleIter ai);
static void restoreActionSchedulePut(PNVMTupleIter ai);
static void restoreActionSend(PNVMTupleIter ai);
static void restoreActionTake(PNVMTupleIter ai);
static void restoreActionUnload(PNVMTupleIter ai);
static PNVMArrayIter restoreHistoryFromPoswithVariables(PNVMArrayIter & i, PNVMTupleHead *vars);
static void restoreTransactionActionwithVariables(PNVMTupleHead *a, PNVMTupleHead *vars);
static int serializeNameto(PNVMStringHead const *name, PNVMStringIter & o);
static int serializeNetInstto(PNVMNetInstHead const *inst, PNVMStringIter & o);
static int serializeNetInstValueofTemplateto(PNVMToken const & token, PNVMTemplate *tmpl, PNVMStringIter & o);
static int serializeNumberto(int num, PNVMStringIter & o);
static int serializeTokento(PNVMToken const & token, PNVMStringIter & o);
static int serializeValueto(PNVMHeaderBlock const *block, PNVMStringIter & o);
static bool setInvalidResult(PNVMToken & result);
static void setValueItemat(void *item, PNVMItemIterator & i);
static Error_t step(void);
static char * stringToCStr(PNVMStringHead const *str);
static void swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(int i1, void *b1, int i2, void *b2, int sig, int isHead);
static void updateTime(void);
static void writeValueItemat(void *item, PNVMItemIterator & i);
/*** Variables ***/
static PNVMEvent * calendarHead;
static PNVMEvent * calendarTail;
static bool codeWithHoles;
static Time_t currentTime;
static Error_t error;
static PNVMArrayHead * inputBuffer;

        /* static const char * moduleName = "PNVM 25 June 2016" */;
static char netTemplateCode[NetTemplateCodeSize] = PLATFORM_CODE;
static PNVMTemplate * netTemplateTable[MaxNetTemplates];
static bool nothingChanged;
static int numberOfNetTemplates;
static PNVMArrayHead * outputBuffer;
static int stepCounter;



/*	
    History is an array of actions that modified state of arbitrary net instance, calendar
    or output buffer during execution of single transition on single instance.
    
    One transition element can generate zero o more such actions.
    
    In case that some transition element fails, we need to restore the state of all objects
    before the execution of transition element started.
    
    Action is stored as tuple having as the first element character, that determines type
    of action. This character is usually the same as the element kind or expression
    operation, that triggered the action. After this character follow parameters.
    
    :param o: iterator pointing at the end of history array
     */

static void appendActiontoHistoryWith(PNVMTupleHead *a, PNVMArrayIter & o) {
    PNVMToken tmp;
    PNVMTupleIter i;

    /* assert(interpreterProxy->isKindOf(a,'PNVMTupleHead')); */
    assert((pnvmValueItemCount(a)) > 0);
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    assert(pnvmIterAtEnd(o));
    /* assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(o)),'PNVMArrayHead')); */
    i = pnvmValueIterator(a);
    assert((pnvmTokenType(pnvmIterValue(i))) == TOKEN_TYPE_INTEGER);
    assert(charisOneOf(pnvmTokenInteger(pnvmIterValue(i)), "POYlicasu:"));
	LOG4CXX_DEBUG(exlog, "appending action " << dereference(a) << ", to history " << dereference(pnvmIterHeaderBlock(o)) << " at index " << pnvmIterIndex(o))
    tmp = pnvmNewPointer(a);
    pnvmIterWrite(o, tmp);
    pnvmTokenMakeInvalid(tmp);
}


/*	
    netTemplateTable can contain holes. We iterate until we find empty place and we take it.
    Return index of template.
        -1 if there is no space left
     */

static int appendNetTemplate(PNVMTemplate *tmpl) {
    int index;

    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    if (numberOfNetTemplates >= MaxNetTemplates) {
        setError(ErrorTemplatesDatabaseFull);
        return -1;
    }
    index = 0;
    while (!((netTemplateTable[index]) == NULL)) {
        index += 1;
    }
    netTemplateTable[index] = tmpl;
    numberOfNetTemplates += 1;
    return index;
}


/*	
    This assigns binded params from downlink execution to variables local to current
    transition according to mapping.
    
    :param params: Array of parameters passed to successful uplink call.
    :param mapping: is a tuple containing indexes to variables array for each uplink's parameter.
    :param history: will be filled with assignment actions for each newly binded variable.
     */

static Error_t bindVariableswithParamsmappinghistory(PNVMTupleHead *vars, PNVMTupleHead const *params, PNVMTupleHead const *mapping, PNVMArrayIter & history) {
    PNVMToken tmp;
    PNVMTupleIter ai;
    PNVMTupleIter pi;
    PNVMTupleIter mi;
    PNVMTupleIter vi;
    PNVMTupleHead *action;

    /* assert(interpreterProxy->isKindOf(mapping,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(params,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    mi = pnvmValueIterator(((PNVMTupleHead *) mapping));
    vi = pnvmValueIterator(vars);
    pi = pnvmValueIterator(((PNVMTupleHead *) params));
    tmp = pnvmNewToken();
    while (!((pnvmIterAtEnd(mi)) || (error != ErrorSuccess))) {
        if (pnvmTokenIsValid(pnvmIterValue(mi))) {
            pnvmIterSeek(vi, pnvmTokenInteger(pnvmIterNext(mi)));
            if (!(pnvmTokenIsValid(pnvmIterValue(vi)))) {

                /* first let's make a note in history */

                if (((action = pnvmTupleNew())) == NULL) {
					LOG4CXX_ERROR(exlog, "failed to allocate tuple for history action")
                    return ErrorNoMemory;
                }
                ai = pnvmValueIterator(action);
                pnvmTokenSetInteger(tmp, ((int)':'));
                pnvmIterWrite(ai, tmp);
                pnvmTokenSetInteger(tmp, pnvmIterIndex(vi));
                pnvmIterWrite(ai, tmp);
                appendActiontoHistoryWith(action, history);
                pnvmIterSetItem(vi, pnvmIterValue(pi));
            }
            pnvmIterNext(pi);
        }
    }
    return error;
}


/*	
    Return pointer to the first event in calendar.
    Does not modify calendar in any way.
     */

static PNVMEvent * calFront(void) {
    unlessdieWithmsg(!(calendarHead == NULL), ErrorCalendarEmpty, "calendar is empty");
    return calendarHead;
}


/*	
    Removes first event from calendar and returns it.
     */

static PNVMEvent * calPop(void) {
    PNVMEvent *event;

    unlessdieWithmsg(!(calendarHead == NULL), ErrorCalendarEmpty, "calendar is empty");
    event = calendarHead;
    if ((pnvmEventNext(event)) != NULL) {
        pnvmEventSetPrev(pnvmEventNext(event), NULL);
        calendarHead = pnvmEventNext(event);
    } else {
        calendarHead = NULL;
        calendarTail = NULL;
    }
    return event;
}


/*	
    Removes event at any position in calendar.
    Event must precisely match.
     */

static void calRemoveEvent(PNVMEvent *event) {
    /* assert(interpreterProxy->isKindOf(event,'PNVMEvent')); */
    unlessdieWithmsg(!(calendarHead == NULL), ErrorCalendarEmpty, "calendar is empty");
    if (calendarHead == event) {
        calendarHead = pnvmEventNext(event);
        if (!(calendarHead == NULL)) {
            pnvmEventSetPrev(calendarHead, NULL);
        }
    } else {
        pnvmEventSetNext(pnvmEventPrev(event), pnvmEventNext(event));
    }
    if (calendarTail == event) {
        calendarTail = pnvmEventPrev(event);
        if (!(calendarTail == NULL)) {
            pnvmEventSetNext(calendarTail, NULL);
        }
    } else {
        pnvmEventSetPrev(pnvmEventNext(event), pnvmEventPrev(event));
    }
}


/*	
    Create a new event and insert it into calendar sorted by time.
    
    :param time is absolute time in milliseconds
    
    Return created instance of Event.
     */

static PNVMEvent * calScheduletimestoPlaceofInstat(PNVMToken & token, int n, int placeId, PNVMNetInstHead *netInst, Time_t time) {
    PNVMEvent *newEvent;
    PNVMEvent *ptr;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(netInst,'PNVMNetInstHead')); */
    if (((newEvent = pnvmEventNewtimestoPlaceofInstscheduledAt(token, n, placeId, netInst, time))) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate new event")
        return NULL;
    }
    if (calendarHead == NULL) {
        calendarHead = newEvent;
        calendarTail = newEvent;
    } else {
        ptr = calendarHead;
        while (((pnvmEventTime(ptr)) <= time) && ((pnvmEventNext(ptr)) != NULL)) {
            ptr = pnvmEventNext(ptr);
        }
        if ((pnvmEventTime(ptr)) <= time) {

            /* insert at the end */

            pnvmEventSetPrev(newEvent, ptr);
            pnvmEventSetNext(ptr, newEvent);
            calendarTail = newEvent;
        } else {

            /* insert before - in the middle */

            pnvmEventSetNext(newEvent, ptr);
            pnvmEventSetPrev(newEvent, pnvmEventPrev(ptr));
            if ((pnvmEventPrev(ptr)) == NULL) {
                calendarHead = newEvent;
            } else {
                pnvmEventSetNext(pnvmEventPrev(ptr), newEvent);
            }
            pnvmEventSetPrev(ptr, newEvent);
        }
    }
    return newEvent;
}


/*	
    Run all the events in calendar scheduled for current time.
     */

static void calendarEvent(void) {
    PNVMEvent *event;

	LOG4CXX_DEBUG(exlog, "entering calendarEvent")
    while ((!(calendarHead == NULL)) && ((pnvmEventTime(calFront())) <= currentTime)) {
        event = calPop();
		LOG4CXX_INFO(exlog, "running event " << dereference(event))
        putNtokenstoPlaceofNetInst(pnvmEventNumber(event), pnvmEventToken(event), pnvmEventPlaceId(event), pnvmEventNetInstance(event));
        nothingChanged = 0;
        pnvmValueDelete(event);
    }
    if (calendarHead == NULL) {
		LOG4CXX_INFO(exlog, "calendar is empty")
    } else {
		LOG4CXX_INFO(exlog, "calendar not empty")
    }
	LOG4CXX_DEBUG(exlog, "leaving calendarEvent")
}


/*	
    Make a check, whether there is a free block in pool of blocks.
    There can be up to MaxBlockCount blocks allocated at once.
    Smalltalk uses its own statistics defined as class variables of PNVMObjectMemory.
    C implementation uses memblock library for this purpose.
     */

bool canAllocateBlock(void) {
    int res;

    
# ifdef USE_MEMBLOCK
    res = MEMBLOCK_GetFreeMem() >= AllocationBlockSize;
# else
    res = 1;
# endif  // USE_MEMBLOCK
    
    return res;
}


/*	
    In case the desired size is bigger, than current one, we initialize new items, append
    neccessary blocks and change the item count to size.
    
    In case the desired size is smaller, we release all items past the size boundary with
    all tail blocks, that are no longer needed.
    
    Returns valid iterator to the end of value.
     */

static PNVMItemIterator changeBlockSizeOfto(PNVMHeaderBlock *block, unsigned int size) {
    PNVMPlaceHead *place;
    PNVMItemIterator iter;
    PNVMPlaceItem placeItem;
    PNVMToken token;
    int sig;

    /* assert(interpreterProxy->isKindOf(block,'PNVMHeaderBlock')); */
    ;
    token = pnvmNewToken();
    placeItem = pnvmPlaceItemNewof(0, pnvmNewToken());
    place = NULL;
    if ((pnvmValueItemCount(block)) > size) {
        iter = pnvmValueIterator(block);
        pnvmIterSeek(iter, size);
        return releaseItemsFromPos(iter);
    } else {
        if ((pnvmValueItemCount(block)) < size) {
            iter = pnvmValueIterator(block);
            pnvmIterSeekEnd(iter);
            sig = signature(block);
            while (((((unsigned int) (pnvmIterIndex(iter)))) < size) && (!(error != ErrorSuccess))) {
                if (sig == SIGN_STRING) {
                    pnvmIterWrite(pnvmIterString(iter), 0);
                } else {
                    if (sig == SIGN_TUPLE) {
                        pnvmIterWrite(pnvmIterTuple(iter), token);
                    } else {
                        if (sig == SIGN_ARRAY) {
                            pnvmIterWrite(pnvmIterArray(iter), token);
                        } else {
                            if (sig == SIGN_PLACE) {
                                pnvmIterWrite(pnvmIterPlace(iter), placeItem);
                            } else {
                                if (sig == SIGN_NET_INSTANCE) {

                                    /* do no allocate a place - it may be created in parser */

                                    pnvmIterWrite(pnvmIterNetInst(iter), place);
                                }
                            }
                        }
                    }
                }
            }
            return iter;
        }
    }
    iter = pnvmValueIterator(block);
    pnvmIterSeekEnd(iter);
    return iter;
}

static bool charisOneOf(int c, char const *str) {
    /* assert((interpreterProxy->isKindOf(c,'Character')) || (interpreterProxy->isKindOf(c,'Number'))); */
    /* assert(interpreterProxy->isKindOf(str,'String')); */
    return strchr(str, c);
}

static bool charIsBlank(int c) {
    /* assert(interpreterProxy->isKindOf(c,'Character')); */
    return strchr(" \n\r\t\f\v", c);
}

static PNVMArrayIter cleanLastAttemptsFromPos(PNVMArrayIter & i) {
	LOG4CXX_DEBUG(exlog, "cleaning last attempts " << dereference(pnvmIterHeaderBlock(i)) << " from pos " << pnvmIterIndex(i))
    releaseItemsFromPos(pnvmIterAsItemIterator(i));
    return i;
}


/*	
    Release all resources.
     */

static void cleanupOMModule(void) {
    PNVMEvent *event;
    int i;
    PNVMTemplate *tmpl;
    int index;
    PNVMArrayHead *instances;


    /* clear calendar */

    while (!(calendarHead == NULL)) {
        event = calPop();
        pnvmValueDelete(event);
    }
    if ((numberOfNetTemplates > 0) && ((pnvmTemplateInstances(tmpl = netTemplateTable[0])) != NULL)) {
        instances = pnvmTemplateInstances(tmpl);
        if ((pnvmValueItemCount(instances)) > 0) {
            pnvmTokenMakeInvalid((dereference(instances))[0]);
        }
    }

    /* delete templates */

    index = 0;
    for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
        tmpl = netTemplateTable[i];
        if (!((pnvmTemplateInstances(tmpl)) == NULL)) {
            pnvmValueDelete(pnvmTemplateInstances(tmpl));
            pnvmTemplateSetInstances(tmpl, NULL);
        }
        pnvmValueDelete(pnvmTemplateSymbols(tmpl));
        pnvmTemplateSetSymbols(tmpl, NULL);
        pnvmValueDelete(pnvmTemplatePlaces(tmpl));
        pnvmTemplateSetPlaces(tmpl, NULL);
        pnvmValueDelete(pnvmTemplateName(tmpl));
        pnvmTemplateSetName(tmpl, NULL);
        pnvmValueDelete(tmpl);
        netTemplateTable[i] = NULL;
        index += 1;
        while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == NULL)) {
            index += 1;
        }
    }
    numberOfNetTemplates = 0;
    error = ErrorSuccess;
    ;
}


/*	
    When calling uplink transition from transition of some other net instance, we make
    a new variable array, that is passed to downlink function. But the history array for
    embedded execution of uplink stays the same. Thus all these assignments made
    in uplink call are not relevant for our transition. That's why we need to remove all
    of them.
    
    *Note* this does not modify current position of history iterator.
     */

static PNVMArrayIter clearVariableAssignments(PNVMArrayIter & history) {
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    while (!(pnvmIterAtEnd(history))) {
        if ((pnvmTokenInteger((dereference(((PNVMArrayHead *) (pnvmTokenPointer(pnvmIterValue(history))))))[0])) == (((int)':'))) {
            removeItemFromBlockAt(pnvmIterAsItemIterator(history));
        }
    }
    return history;
}


/*	
    return:
        a < b -> -1
        a > b -> 1
        otherwise -> 0
     */

static int cmpPointerwith(PNVMHeaderBlock const *a, PNVMHeaderBlock const *b) {
    int res;
    PNVMItemIterator ib;
    PNVMItemIterator ia;
    PNVMEvent const *eventB;
    PNVMEvent const *eventA;

    /* assert(interpreterProxy->isKindOf(a,'PNVMHeaderBlock')); */
    /* assert(interpreterProxy->isKindOf(b,'PNVMHeaderBlock')); */
    if (a == b) {
        return 0;
    }
    if ((signature(a)) < (signature(b))) {
        return -1;
    }
    if ((signature(a)) > (signature(b))) {
        return 1;
    }
    if (pnvmTypeIndexable(a)) {
        if ((signature(a)) == SIGN_STRING) {
            return cmpStringwith(((PNVMStringHead *) a), ((PNVMStringHead *) b));
        } else {
            if ((pnvmValueItemCount(a)) < (pnvmValueItemCount(b))) {
                return -1;
            }
            if ((pnvmValueItemCount(a)) > (pnvmValueItemCount(b))) {
                return 1;
            }
        }
        ia = pnvmValueIterator(((PNVMHeaderBlock *) a));
        ib = pnvmValueIterator(((PNVMHeaderBlock *) b));
        while (!((pnvmIterAtEnd(ia)) || (pnvmIterAtEnd(ib)))) {
            if ((signature(a)) == SIGN_STRING) {
                if ((pnvmIterValue(pnvmIterString(ia))) < (pnvmIterValue(pnvmIterString(ib)))) {
                    return -1;
                }
                if ((pnvmIterValue(pnvmIterString(ia))) > (pnvmIterValue(pnvmIterString(ib)))) {
                    return 1;
                }
            } else {
                if ((signature(a)) == SIGN_TUPLE) {
                    res = cmpTokenwith(pnvmIterValue(pnvmIterTuple(ia)), pnvmIterValue(pnvmIterTuple(ib)));
                    if (res != 0) {
                        return res;
                    }
                } else {
                    if ((signature(a)) == SIGN_ARRAY) {
                        res = cmpTokenwith(pnvmIterValue(pnvmIterArray(ia)), pnvmIterValue(pnvmIterArray(ib)));
                        if (res != 0) {
                            return res;
                        }
                    } else {
                        dieWithmsgwith(ErrorExecutionUnhandledSignature, "unsupported data block for comparison: ", dereference(a));
                    }
                }
            }
            pnvmIterNext(ia);
            pnvmIterNext(ib);
        }
        if ((pnvmIterAtEnd(ia)) && (!(pnvmIterAtEnd(ib)))) {
            return -1;
        }
        if ((!(pnvmIterAtEnd(ia))) && (pnvmIterAtEnd(ib))) {
            return 1;
        }
        pnvmIterNext(ia);
        pnvmIterNext(ib);
    } else {
        if ((signature(a)) == SIGN_TEMPLATE) {
            res = cmpPointerwith(pnvmTemplateName(((PNVMTemplate const *) a)), pnvmTemplateName(((PNVMTemplate const *) b)));
            if (res != 0) {
                return res;
            }
        } else {
            if ((signature(a)) == SIGN_EVENT) {
                eventA = ((PNVMEvent const *) a);
                eventB = ((PNVMEvent const *) a);
                if ((pnvmEventTime(eventA)) < (pnvmEventTime(eventB))) {
                    return -1;
                }
                if ((pnvmEventTime(eventA)) > (pnvmEventTime(eventB))) {
                    return 1;
                }
                if ((pnvmEventNetInstance(eventA)) < (pnvmEventNetInstance(eventB))) {
                    return -1;
                }
                if ((pnvmEventNetInstance(eventA)) > (pnvmEventNetInstance(eventB))) {
                    return 1;
                }
                if ((pnvmEventPlaceId(eventA)) < (pnvmEventPlaceId(eventB))) {
                    return -1;
                }
                if ((pnvmEventPlaceId(eventA)) > (pnvmEventPlaceId(eventB))) {
                    return 1;
                }
                if (((res = cmpTokenwith(pnvmEventToken(eventA), pnvmEventToken(eventB)))) != 0) {
                    return res;
                }
                if ((pnvmEventNumber(eventA)) < (pnvmEventNumber(eventB))) {
                    return -1;
                }
                if ((pnvmEventNumber(eventA)) > (pnvmEventNumber(eventB))) {
                    return 1;
                }
            } else {
                dieWithmsgwith(ErrorExecutionUnhandledSignature, "unknown type signature: ", signature(a));
            }
        }
    }
    return 0;
}


/*	
    return:
        a < b -> -1
        a > b -> 1
        otherwise -> 0
     */

static int cmpStringwith(PNVMStringHead const *a, PNVMStringHead const *b) {
    PNVMStringIter ib;
    PNVMStringIter ia;

    /* assert(interpreterProxy->isKindOf(a,'PNVMStringHead')); */
    /* assert(interpreterProxy->isKindOf(b,'PNVMStringHead')); */
    if (a == b) {
        return 0;
    }
    ia = pnvmValueIterator(((PNVMStringHead *) a));
    ib = pnvmValueIterator(((PNVMStringHead *) b));
    while (!((pnvmIterAtEnd(ia)) || (pnvmIterAtEnd(ib)))) {
        if ((pnvmIterValue(ia)) < (pnvmIterValue(ib))) {
            return -1;
        }
        if ((pnvmIterValue(ia)) > (pnvmIterValue(ib))) {
            return 1;
        }
        if ((pnvmIterAtEnd(ia)) && (!(pnvmIterAtEnd(ib)))) {
            return -1;
        }
        if ((!(pnvmIterAtEnd(ia))) && (pnvmIterAtEnd(ib))) {
            return 1;
        }
        pnvmIterNext(ia);
        pnvmIterNext(ib);
    }
    if ((pnvmIterAtEnd(ia)) && (!(pnvmIterAtEnd(ib)))) {
        return -1;
    }
    if ((!(pnvmIterAtEnd(ia))) && (pnvmIterAtEnd(ib))) {
        return 1;
    }
    return 0;
}


/*	
    return:
        a < b -> -1
        a > b -> 1
        otherwise -> 0
     */

static int cmpTokenwith(PNVMToken const & a, PNVMToken const & b) {
    /* assert(interpreterProxy->isKindOf(a,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(b,'PNVMToken')); */
    if ((pnvmTokenType(a)) < (pnvmTokenType(b))) {
        return -1;
    }
    if ((pnvmTokenType(a)) > (pnvmTokenType(b))) {
        return 1;
    }
    if ((pnvmTokenType(a)) == TOKEN_TYPE_INTEGER) {
        if ((pnvmTokenInteger(a)) < (pnvmTokenInteger(b))) {
            return -1;
        }
        if ((pnvmTokenInteger(a)) > (pnvmTokenInteger(b))) {
            return 1;
        }
    } else {
        if ((pnvmTokenType(a)) == TOKEN_TYPE_NET_REF) {

            /* in case of net reference, just compare the address */

            if (pnvmTokenNetRef(a) < pnvmTokenNetRef(b)) {
                return -1;
            }
            if (pnvmTokenNetRef(a) > pnvmTokenNetRef(b)) {
                return 1;
            }
            return 0;
        } else {

            /* pointer to value */

            if ((!(pnvmTokenIsValid(a))) && (pnvmTokenIsValid(b))) {
                return -1;
            }
            if ((pnvmTokenIsValid(a)) && (!(pnvmTokenIsValid(b)))) {
                return 1;
            }
            if ((!(pnvmTokenIsValid(a))) && (!(pnvmTokenIsValid(b)))) {
                return 0;
            }
            return cmpPointerwith(pnvmTokenPointer(a), pnvmTokenPointer(b));
        }
    }
    return 0;
}


/*	
    :param codeptr gets modified.
        After return tt points just behind the closing bracket of variables.
     */

static int codeGetVariableCount(char const * & codeptr) {
    int c;
    int num;

    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    num = 0;
    while (!(((c = codeptr[0])) == (((int)')')))) {
        if (isalpha(c)) {
            num += 1;
            while (!(charisOneOf((c = codeptr[0]), ",)"))) {
                codeptr++;
            }
        }
        if (c == (((int)','))) {
            codeptr++;
        }
    }
    codeptr++;
    return num;
}


/*	
    Skip expression of G or A transition elements.
    It shifts codeptr after the expression's closing bracket.
     */

static void codeSeekSkipExpression(char const * & codeptr) {
    int j;
    int numparams;
    int c;

    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    c = *codeptr;
    codeptr++;
    if (charisOneOf(c, "VSI")) {
        codeptr++;
        codeptr++;
        codeptr++;
    } else {
        if ((c == 'd') || ((c == 'n') && (charisOneOf(codeptr[0], "sat")))) {

            /* parameter-less operators */

            codeptr++;
            if (c == 'n') {
                codeptr++;
            }
        } else {

            /* unary or binary operators */

            numparams = 0;
            if ((charisOneOf(c, "!phtlcsu")) || ((c == 'i') && (charisOneOf(codeptr[0], "(visatn")))) {

                /* unary operator */

                if ((c == 'i') && ((codeptr[0]) != (((int)'(')))) {
                    codeptr++;
                }
                numparams = 1;
            } else {

                /* binary operators */

                assert(charisOneOf(c, "=<>&|^o:,+-*%/#a"));
                numparams = 2;
            }
            for (j = 1; j <= numparams; j += 1) {
                codeSeekSkipExpression(codeptr);
            }
            codeptr++;
        }
    }
}

static void codeSeekSkipTransition(char const * & codeptr) {
    int kind;

    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    assert(charisOneOf(codeptr[0], "UIT"));
    kind = *codeptr;
    if ((kind == 'U') || (kind == 'T')) {

        /* skip transition name */

        while (!((codeptr[0]) == (((int)'(')))) {
            codeptr++;
        }
    }
    if (kind == 'U') {

        /* skip parameters */

        codeSeekSkipVariables(codeptr);
    }
    if ((kind == 'U') || (kind == 'T')) {

        /* skip local variables */

        codeSeekSkipVariables(codeptr);
    }
    codeSeekSkipTransitionElements(codeptr);
    assert((codeptr[0]) == (((int)')')));
    codeptr++;
}

static void codeSeekSkipTransitionElement(char const * & codeptr) {
    int elem;
    int paramCount;

    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    elem = *codeptr++;
    if (charisOneOf(elem, "POY")) {
        if (elem == (((int)'Y'))) {
            codeStoreOffsettoRef((((codeptr + 2) + 2) + 3) + 4, codeptr);
        } else {
            codeStoreOffsettoRef(((codeptr + 2) + 2) + 3, codeptr);
        }
    } else {
        if (elem == (((int)'D'))) {
            while ((*codeptr++) > 0) {
            }
            codeptr++;
            codeptr++;
            paramCount = memLoadShort(codeptr);
            codeStoreOffsettoRef((codeptr + (3 * paramCount)) + 2, codeptr);
        } else {

            /* skip expressions */

            assert(charisOneOf(elem, "AG"));
            assert((codeptr[0]) == (((int)'(')));
            codeSeekSkipExpression(codeptr);
        }
    }
    codeptr++;
}

static void codeSeekSkipTransitionElements(char const * & codeptr) {
    while (!((codeptr[0]) == (((int)')')))) {
        codeSeekSkipTransitionElement(codeptr);
    }
}

static void codeSeekSkipVariables(char const * & codeptr) {
    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    while (!((*codeptr++) == (((int)')')))) {
    }
}

static int codeStoreOffsettoRef(char const *codeptr, char const *& ref) {
    int ret;

    ret = codeptr - ref;
    ref = codeptr;
    return ret;
}


/*	
    Return number of items written.
    Both iterators get modified.
     */

static int copyValueItemsFromto(PNVMItemIterator & src, PNVMItemIterator & dest) {
    return copyValueNitemsFromto(pnvmValueItemCount(pnvmIterHeaderBlock(src)), src, dest);
}


/*	
    Retrun number of items copied.
    Both iterators get modified.
     */

static int copyValueNitemsFromto(int n, PNVMItemIterator & src, PNVMItemIterator & dest) {
    int count;

    assert((signature(pnvmIterHeaderBlock(src))) == (signature(pnvmIterHeaderBlock(dest))));
    count = 0;
    while ((!(pnvmIterAtEnd(src))) && (count < n)) {
        writeValueItemat(pnvmIterNext(src), dest);
        count += 1;
    }
    return count;
}


/*	
    Instance is created and appended to template instance list.
    Instance should be initialized by caller.
    
    :param tmplNo is a zero-based index to netTemplateTable
    
    Return created instance in token.
     */

static PNVMToken createNetInstanceFrom(PNVMTemplate *tmpl) {
    PNVMPlaceHead *place;
    PNVMToken res;
    PNVMNetInstIter instIter;
    PNVMNetInstHead *inst;

    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
	LOG4CXX_INFO(exlog, "creating instance of template " << dereference(tmpl))
    if (((inst = pnvmNetInstNew(tmpl))) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate new net instance")
        return pnvmNewToken();
    }
    changeBlockSizeOfto(inst, pnvmTemplatePlaceCount(tmpl));
    if (error != ErrorSuccess) {
		LOG4CXX_ERROR(exlog, "failed to resize net instance")
        pnvmValueDelete(inst);
        return pnvmNewToken();
    }
    instIter = pnvmValueIterator(inst);
    while (!(pnvmIterAtEnd(instIter))) {
        if (((place = pnvmPlaceNew())) == NULL) {
			LOG4CXX_ERROR(exlog, "failed to allocate new place")
            pnvmValueDelete(inst);
            return pnvmNewToken();
        }
        pnvmIterWrite(instIter, place);
    }
    if (!(pnvmTokenIsValid(res = manageNetInstance(inst)))) {
		LOG4CXX_ERROR(exlog, "failed to manage net instance")
        pnvmValueDelete(inst);
    }
    return res;
}


/*	
    Converts NULL-terminated c string to string value.
     */

PNVMStringHead * cstrToString(char const *cstr) {
    int i;
    PNVMStringHead *res;
    PNVMStringIter o;

    if (((res = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to new string for convertion from c-string")
        return NULL;
    }
    o = pnvmValueIterator(res);
    i = 0;
    while (cstr[i]) {
        pnvmIterWrite(o, cstr[i]);
        i += 1;
    }
    return res;
}

static bool evalAddto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    int res;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER) && ((pnvmTokenType(tokenB)) == TOKEN_TYPE_INTEGER))) {
		LOG4CXX_INFO(exlog, "failed to add two values")
        return setInvalidResult(result);
    }
    res = (pnvmTokenInteger(tokenA)) + (pnvmTokenInteger(tokenB));
    pnvmTokenSetInteger(result, res);
	LOG4CXX_INFO(exlog, "" << pnvmTokenInteger(result) << " = " << pnvmTokenInteger(tokenA) << " + " << pnvmTokenInteger(tokenB))
    return 1;
}

static bool evalAndto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (evalIsTrue(tokenA)) {
        pnvmTokenAssign(result, tokenB);
    } else {
        pnvmTokenAssign(result, tokenA);
    }
	LOG4CXX_INFO(exlog, "and evaluates to: " << evalIsTrue(result))
    return 1;
}


/*	
    This evaluation is special.
    The first operand can either be a valid integer token holding index to vars
    or invalid token (in code represented by Vxx). We need to get index to
    vars to assign to them. That's why we need code position.
    
    :param tokenA either integer token or invalid token
    :param tokenB value to be assigned to variable
    :param codeptr points to the opening bracket of the first operand.
        Only needed, whan tokenA is not valid.
        
    Return tokenB.
     */

static bool evalAssignatCodewithVariablestohistory(PNVMToken const & tokenA, PNVMToken & tokenB, char const * & codeptr, PNVMTupleHead *vars, PNVMToken & result, PNVMArrayIter & history) {
    PNVMTupleIter vi;
    PNVMTupleIter ai;
    PNVMTupleHead *action;
    PNVMToken tmp;
    int varId;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    if (!((pnvmTokenIsValid(tokenB)) && (((pnvmTokenIsValid(tokenA)) && ((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER)) || (!(pnvmTokenIsValid(tokenA)))))) {
		LOG4CXX_ERROR(exlog, "second operand must be valid and first must not for assignment")
        return setInvalidResult(result);
    }
    if (pnvmTokenIsValid(tokenA)) {
        varId = pnvmTokenInteger(tokenA);
    } else {
        if (!((*codeptr++) == (((int)'V')))) {
			LOG4CXX_ERROR(exlog, "first operand must be variable")
            return setInvalidResult(result);
        }
        varId = memLoadShort(codeptr);
    }
    if ((varId < 0) || ((((unsigned int) varId)) >= (pnvmValueItemCount(vars)))) {
		LOG4CXX_ERROR(exlog, "variables index out of range")
        return setInvalidResult(result);
    }
    vi = pnvmValueIterator(vars);
    pnvmIterSeek(vi, varId);
    if (pnvmTokenIsValid(pnvmIterValue(vi))) {
		LOG4CXX_ERROR(exlog, "can not assign to binded variable at index " << varId)
        return setInvalidResult(result);
    }
    pnvmIterSetItem(vi, tokenB);
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to create tuple to store history action")
        return setInvalidResult(result);
    }
    ai = pnvmValueIterator(action);
    tmp = pnvmNewInteger(((int)':'));
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, varId);
    pnvmIterWrite(ai, tmp);
    appendActiontoHistoryWith(action, history);
	LOG4CXX_INFO(exlog, "V" << varId << " := " << tokenB)
    pnvmTokenAssign(result, tokenB);
    codeptr++;
    return 1;
}

static bool evalConcatenateto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    PNVMTupleHead *blockBt;
    PNVMTupleHead *blockAt;
    PNVMStringIter o;
    PNVMArrayHead *blockBa;
    PNVMArrayHead *blockAa;
    PNVMArrayHead *resa;
    PNVMStringHead *blockB;
    PNVMStringIter i;
    PNVMArrayIter ia;
    PNVMStringHead *res;
    PNVMStringHead *blockA;
    PNVMArrayIter oa;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!((pnvmTokenIsValid(tokenA)) && ((pnvmTokenIsValid(tokenB)) && (((pnvmTokenType(tokenA)) == TOKEN_TYPE_POINTER) && ((pnvmTokenType(tokenB)) == TOKEN_TYPE_POINTER))))) {
		LOG4CXX_ERROR(exlog, "failed to concatenate: operands must be strings")
        return setInvalidResult(result);
    }
    blockA = ((PNVMStringHead *) (pnvmTokenPointer(tokenA)));
    blockB = ((PNVMStringHead *) (pnvmTokenPointer(tokenB)));
    blockAa = ((PNVMArrayHead *) (pnvmTokenPointer(tokenA)));
    blockBa = ((PNVMArrayHead *) (pnvmTokenPointer(tokenB)));
    blockAt = ((PNVMTupleHead *) (pnvmTokenPointer(tokenA)));
    blockBt = ((PNVMTupleHead *) (pnvmTokenPointer(tokenB)));
    if (!((((signature(pnvmTokenPointer(tokenA))) == SIGN_STRING) && ((signature(pnvmTokenPointer(tokenB))) == SIGN_STRING)) || (((signature(pnvmTokenPointer(tokenA))) == SIGN_ARRAY) && ((signature(pnvmTokenPointer(tokenB))) == SIGN_ARRAY)))) {
		LOG4CXX_ERROR(exlog, "failed to concatenate: operands must be strings or arrays")
        return setInvalidResult(result);
    }
    if ((signature(pnvmTokenPointer(tokenA))) == SIGN_STRING) {
        if (((res = pnvmStringNew())) == NULL) {
			LOG4CXX_ERROR(exlog, "failed to allocate string for concatenation")
            return setInvalidResult(result);
        }
        o = pnvmValueIterator(res);
        i = pnvmValueIterator(blockA);
        while (!(pnvmIterAtEnd(i))) {
            pnvmIterWrite(o, pnvmIterNext(i));
        }
        i = pnvmValueIterator(blockB);
        while (!(pnvmIterAtEnd(i))) {
            pnvmIterWrite(o, pnvmIterNext(i));
        }
        pnvmTokenSetPointer(result, res);
		LOG4CXX_INFO(exlog, "" << asPlainString(((PNVMStringHead *) (pnvmTokenPointer(result)))) << " = " << asPlainString(((PNVMStringHead *) (pnvmTokenPointer(tokenA)))) << ", " << asPlainString(((PNVMStringHead *) (pnvmTokenPointer(tokenB)))))
    }
    if ((signature(pnvmTokenPointer(tokenA))) == SIGN_ARRAY) {
        if (((resa = pnvmArrayNew())) == NULL) {
			LOG4CXX_ERROR(exlog, "failed to allocate array for concatenation")
            return setInvalidResult(result);
        }
        oa = pnvmValueIterator(resa);
        ia = pnvmValueIterator(blockAa);
        while (!(pnvmIterAtEnd(ia))) {
            pnvmIterWrite(oa, pnvmIterNext(ia));
        }
        ia = pnvmValueIterator(blockBa);
        while (!(pnvmIterAtEnd(ia))) {
            pnvmIterWrite(oa, pnvmIterNext(ia));
        }
        pnvmTokenSetPointer(result, resa);
		LOG4CXX_INFO(exlog, "" << ((PNVMArrayHead *) (pnvmTokenPointer(result))) << " = " << ((PNVMArrayHead *) (pnvmTokenPointer(tokenA))) << ", " << ((PNVMArrayHead *) (pnvmTokenPointer(tokenB))))
    }
    return 1;
}

static bool evalDividedto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    int res;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER) && ((pnvmTokenType(tokenB)) == TOKEN_TYPE_INTEGER))) {
		LOG4CXX_INFO(exlog, "failed to divide")
        return setInvalidResult(result);
    }
    res = (pnvmTokenInteger(tokenA)) / (pnvmTokenInteger(tokenB));
    pnvmTokenSetInteger(result, res);
	LOG4CXX_INFO(exlog, pnvmTokenInteger(result) << " = " << pnvmTokenInteger(tokenA) << " / " << pnvmTokenInteger(tokenB))
    return 1;
}


/*	get value on index from indexable value */

static bool evalGetto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    PNVMHeaderBlock const *col;
    PNVMItemIterator i;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_POINTER) && ((pnvmTokenIsValid(tokenA)) && (pnvmTypeIndexable(pnvmTokenPointer(tokenA)))))) {
		LOG4CXX_ERROR(exlog, "failed to index unindexable value " << tokenA)
        return setInvalidResult(result);
    }
    if (!((pnvmTokenType(tokenB)) == TOKEN_TYPE_INTEGER)) {
		LOG4CXX_ERROR(exlog, "collection is indexable only by integers")
        return setInvalidResult(result);
    }
    col = pnvmTokenPointer(tokenA);
    if (((pnvmTokenInteger(tokenB)) < 0) || ((pnvmTokenInteger(tokenB)) >= (((int) (pnvmValueItemCount(col)))))) {
		LOG4CXX_ERROR(exlog, "index out of range")
        return setInvalidResult(result);
    }
    i = pnvmValueIterator(((PNVMHeaderBlock *) col));
    pnvmIterSeek(i, pnvmTokenInteger(tokenB));
    pnvmTokenAssign(result, ((signature(col)) == SIGN_ARRAY
        ? pnvmIterValue(pnvmIterArray(i))
        : ((signature(col)) == SIGN_TUPLE
    ? pnvmIterValue(pnvmIterTuple(i))
    : ((signature(col)) == SIGN_STRING
    ? pnvmNewInteger(pnvmIterValue(pnvmIterString(i)))
    : pnvmNewToken()))));
	LOG4CXX_INFO(exlog, "" << result << " = " << tokenA << "[" << pnvmTokenInteger(tokenB) << "]")
    return 1;
}

static bool evalIsEqualToto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if ((cmpTokenwith(tokenA, tokenB)) == 0) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
	LOG4CXX_INFO(exlog, "" << pnvmTokenInteger(result) << " = " << tokenA << " == " << tokenB)
    return 1;
}

static bool evalIsGreaterThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if ((cmpTokenwith(tokenA, tokenB)) > 0) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
	LOG4CXX_INFO(exlog, "" << pnvmTokenInteger(result) << " = " << tokenA << " > " << tokenB)
    return 1;
}

static bool evalIsSmallerThanto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if ((cmpTokenwith(tokenA, tokenB)) < 0) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
	LOG4CXX_INFO(exlog, "" << pnvmTokenInteger(result) << " = " << tokenA << " < " << tokenB)
    return 1;
}

static bool evalMinusto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    int res;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER) && ((pnvmTokenType(tokenB)) == TOKEN_TYPE_INTEGER))) {
		LOG4CXX_INFO(exlog, "operands must be numbers for aithmetic operation")
        return setInvalidResult(result);
    }
    res = (pnvmTokenInteger(tokenA)) - (pnvmTokenInteger(tokenB));
    pnvmTokenSetInteger(result, res);
	LOG4CXX_INFO(exlog, pnvmTokenInteger(result) << " = " << pnvmTokenInteger(tokenA) << " - " << pnvmTokenInteger(tokenB))
    return 1;
}

static bool evalModuloto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER) && ((pnvmTokenType(tokenB)) == TOKEN_TYPE_INTEGER))) {
		LOG4CXX_INFO(exlog, "operands must be numbers for arithmetic operation")
        return 0;
    }
    pnvmTokenSetInteger(result, (pnvmTokenInteger(tokenA)) % (pnvmTokenInteger(tokenB)));
	LOG4CXX_INFO(exlog, "" << pnvmTokenInteger(result) << " = " << pnvmTokenInteger(tokenA) << " % " << pnvmTokenInteger(tokenB))
    return 1;
}

static bool evalOrto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (evalIsTrue(tokenA)) {
        pnvmTokenAssign(result, tokenA);
    } else {
        pnvmTokenAssign(result, tokenB);
    }
	LOG4CXX_INFO(exlog, "" << pnvmTokenValue(result) << " = " << pnvmTokenValue(tokenA) << " || " << pnvmTokenValue(tokenB))
    return 1;
}


/*	
    appends value to modifiable collection such as
        * string
        * array
    Note: that tokenA is really modified! That means the value is modified for all referents.
    This can be issue especially for symbols (user probably expects the symbols to be constants).
    Should be fixed -> sequences should have copy-on-write semantics.
    
    Result is the first argument.
     */

static bool evalPushBacktohistory(PNVMToken & tokenA, PNVMToken & tokenB, PNVMToken & result, PNVMArrayIter & history) {
    PNVMToken tmp;
    PNVMItemIterator i;
    PNVMTupleIter ai;
    PNVMTupleHead *action;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(result,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_POINTER) && ((pnvmTokenIsValid(tokenA)) && (((signature(pnvmTokenPointer(tokenA))) == SIGN_STRING) || ((signature(pnvmTokenPointer(tokenA))) == SIGN_ARRAY))))) {
		LOG4CXX_ERROR(exlog, "failed to append to unindexable or non-modifiable value " << tokenA)
        return setInvalidResult(result);
    }
    if (!(pnvmTokenIsValid(tokenB))) {
		LOG4CXX_ERROR(exlog, "second operand must be valid to append to collection")
        return setInvalidResult(result);
    }
    i = pnvmValueIterator(pnvmTokenPointer(tokenA));
    pnvmIterSeekEnd(i);
    if ((signature(pnvmIterHeaderBlock(i))) == SIGN_STRING) {
        pnvmIterSetItem(pnvmIterString(i), pnvmTokenInteger(tokenB));
    } else {
        pnvmIterSetItem(pnvmIterArray(i), tokenB);
    }
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
        return setInvalidResult(result);
    }
    ai = pnvmValueIterator(action);
    tmp = pnvmNewInteger(((int)'a'));
    pnvmIterWrite(ai, tmp);
    pnvmIterWrite(ai, tokenA);
    appendActiontoHistoryWith(action, history);
    pnvmTokenAssign(result, tokenA);
	LOG4CXX_INFO(exlog, "" << dereference(pnvmTokenPointer(tokenA)) << ".push_back(" << tokenB << ")")
    return 1;
}

static bool evalTimesto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    int res;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!(((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER) && ((pnvmTokenType(tokenB)) == TOKEN_TYPE_INTEGER))) {
		LOG4CXX_INFO(exlog, "operands must be numbers for aithmetic operation")
        return setInvalidResult(result);
    }
    res = (pnvmTokenInteger(tokenA)) * (pnvmTokenInteger(tokenB));
    pnvmTokenSetInteger(result, res);
	LOG4CXX_INFO(exlog, pnvmTokenInteger(result) << " = " << pnvmTokenInteger(tokenA) << " * " << pnvmTokenInteger(tokenB))
    return 1;
}

static bool evalXorto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (evalIsTrue(tokenA)) {
        return evalNotto(tokenB, result);
    } else {
        pnvmTokenAssign(result, tokenB);
    }
	LOG4CXX_INFO(exlog, "" << result << " = " << tokenA << " ^ " << tokenB)
    return 1;
}


/*	
    Result is a net instance.
    
    :param token is a string with net template name.
     */

static bool evalCreateNetInstto(PNVMToken const & token, PNVMToken & result) {
    PNVMToken tmp;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (!((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && ((signature(pnvmTokenPointer(token))) == SIGN_STRING)))) {
		LOG4CXX_ERROR(exlog, "token must be a string with template name")
        return setInvalidResult(result);
    }
    tmpl = findNetTemplate(((PNVMStringHead *) (pnvmTokenPointer(token))));
    if (tmpl == NULL) {
		LOG4CXX_ERROR(exlog, "could not find template named " << asPlainString(((PNVMStringHead *) (pnvmTokenPointer(token)))))
        return setInvalidResult(result);
    }
    tmp = createNetInstanceFrom(tmpl);
    initializeNetInstance(pnvmTokenNetRef(tmp));
    pnvmTokenAssign(result, tmp);
    pnvmTokenMakeInvalid(tmp);
	LOG4CXX_INFO(exlog, "created new net instance from template " << dereference(pnvmTemplateName(tmpl)))
    return 1;
}


/*	
    This evaluates unary operator 'dump'.
    
    :param inst is a net instance to serialize
    
    Result is a string containing serialized instance.
     */

static bool evalDumpto(PNVMNetInstHead const *inst, PNVMToken & result) {
    PNVMStringIter o;
    PNVMStringHead *str;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    if (((str = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate new string for dump")
        return setInvalidResult(result);
    }
    o = pnvmValueIterator(str);
    if ((serializeNetInstto(inst, o)) < 0) {
		LOG4CXX_ERROR(exlog, "failed to serialize net instance " << dereference(inst))
        return setInvalidResult(result);
    }
    pnvmTokenSetPointer(result, str);
	LOG4CXX_INFO(exlog, "instance " << dereference(inst) << " dumped")
    return 1;
}

static bool evalHeadto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (!(((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && (pnvmTokenIsValid(token)))) {
		LOG4CXX_ERROR(exlog, "can not get head from not indexable or invalid value")
        return setInvalidResult(result);
    }
    if ((pnvmValueItemCount(pnvmTokenPointer(token))) < 1) {
		LOG4CXX_ERROR(exlog, "collection is empty")
        return setInvalidResult(result);
    }
    if ((signature(pnvmTokenPointer(token))) == SIGN_STRING) {
        pnvmTokenSetInteger(result, (dereference(((PNVMStringHead *) (pnvmTokenPointer(token)))))[0]);
    } else {
        if ((signature(pnvmTokenPointer(token))) == SIGN_ARRAY) {
            pnvmTokenAssign(result, (dereference(((PNVMArrayHead *) (pnvmTokenPointer(token)))))[0]);
        } else {
            if ((signature(pnvmTokenPointer(token))) == SIGN_TUPLE) {
                pnvmTokenAssign(result, (dereference(((PNVMTupleHead *) (pnvmTokenPointer(token)))))[0]);
            } else {
				LOG4CXX_INFO(exlog, "can not apply head() on " << token)
                return 0;
            }
        }
    }
	LOG4CXX_INFO(exlog, "" << result << " = head(" << token << ")")
    return 1;
}

static bool evalIsArrayto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if ((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && ((signature(pnvmTokenPointer(token))) == SIGN_ARRAY))) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
    return 1;
}

static bool evalIsIntegerto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if ((pnvmTokenType(token)) == TOKEN_TYPE_INTEGER) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
    return 1;
}

static bool evalIsNetRefto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if ((pnvmTokenType(token)) == TOKEN_TYPE_NET_REF) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
    return 1;
}

static bool evalIsStringto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if ((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && ((signature(pnvmTokenPointer(token))) == SIGN_STRING))) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
    return 1;
}

static bool evalIsTrue(PNVMToken const & token) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if ((pnvmTokenType(token)) == TOKEN_TYPE_INTEGER) {
        return (pnvmTokenInteger(token)) != 0;
    }
    if ((pnvmTokenType(token)) == TOKEN_TYPE_NET_REF) {
        return 1;
    }
    if (!(pnvmTokenIsValid(token))) {
        return 0;
    }
    if ((pnvmTypeIndexable(pnvmTokenPointer(token))) && ((pnvmValueItemCount(pnvmTokenPointer(token))) > 0)) {
        return 1;
    }
    if (!(pnvmTypeIndexable(pnvmTokenPointer(token)))) {
        return 1;
    }
    return 0;
}

static bool evalIsTupleto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if ((pnvmTokenIsValid(token)) && (((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && ((signature(pnvmTokenPointer(token))) == SIGN_TUPLE))) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
    return 1;
}

static bool evalIsValidto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (pnvmTokenIsValid(token)) {
        pnvmTokenSetInteger(result, 1);
    } else {
        pnvmTokenSetInteger(result, 0);
    }
    return 1;
}


/*	
    Evaluates $i operator.
    Result is a net instance.
    We don't need to store the action in history, garbage collection will do the work.
    
    :param token is a string with serialized net instance.
     */

static bool evalLoadNetInstto(PNVMToken const & token, PNVMToken & result) {
    PNVMToken tmp;
    PNVMStringIter i;
    PNVMNetInstHead *inst;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (!(((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && ((pnvmTokenIsValid(token)) && ((signature(pnvmTokenPointer(token))) == SIGN_STRING)))) {
		LOG4CXX_ERROR(exlog, "token must be string for template parsing")
        return setInvalidResult(result);
    }
    i = pnvmValueIterator(((PNVMStringHead *) (pnvmTokenPointer(token))));
    if (!(((inst = parseNetInstance(i))) == NULL)) {
        if (!(pnvmTokenIsValid(tmp = manageNetInstance(inst)))) {
			LOG4CXX_ERROR(exlog, "failed to manage instance")
            pnvmValueDelete(inst);
            return 0;
        }
        pnvmTokenAssign(result, tmp);
		LOG4CXX_INFO(exlog, "loaded new net instance of template '" << dereference(pnvmTemplateName(pnvmNetInstTemplate(inst))) << "' from string")
        return 1;
    }
	LOG4CXX_ERROR(exlog, "failed to parse net instance")
    return setInvalidResult(result);
}


/*	
    Result is a boolean. 1 for successful load and 0 on failure.
    
    :param token is a string with net template code.
     */

static bool evalLoadTemplatetohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history) {
    PNVMToken tmp;
    PNVMStringIter i;
    PNVMTemplate *tmpl;
    PNVMTupleIter ai;
    int index;
    PNVMTupleHead *action;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    if (!(((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && ((pnvmTokenIsValid(token)) && ((signature(pnvmTokenPointer(token))) == SIGN_STRING)))) {
		LOG4CXX_ERROR(exlog, "token must be string for template parsing")
        return setInvalidResult(result);
    }
    if (numberOfNetTemplates >= MaxNetTemplates) {
		LOG4CXX_ERROR(exlog, "not enough space for another net template")
        return setInvalidResult(result);
    }
    i = pnvmValueIterator(((PNVMStringHead *) (pnvmTokenPointer(token))));
    if (!(((tmpl = parseNetTemplate(i))) == NULL)) {
        index = appendNetTemplate(tmpl);
		LOG4CXX_INFO(exlog, "loaded new net template '" << dereference(tmpl) << "' as id " << index)
        pnvmTokenSetInteger(result, 1);
        if (((action = pnvmTupleNew())) == NULL) {
            pnvmValueDelete(pnvmTemplateName(tmpl));
            pnvmValueDelete(pnvmTemplateSymbols(tmpl));
            pnvmValueDelete(pnvmTemplatePlaces(tmpl));
            pnvmValueDelete(tmpl);
			LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
            return setInvalidResult(result);
        }
        ai = pnvmValueIterator(action);
        tmp = pnvmNewInteger(((int)'l'));
        pnvmIterWrite(ai, tmp);
        pnvmTokenSetInteger(tmp, index);
        pnvmIterWrite(ai, tmp);
        pnvmTokenSetPointer(tmp, tmpl);
        pnvmIterWrite(ai, tmp);
        appendActiontoHistoryWith(action, history);
        return 1;
    }
	LOG4CXX_ERROR(exlog, "failed to parse net template")
    pnvmTokenSetInteger(result, 0);
    return 1;
}


/*	
    This evaluates unary operator creating instance of particular type.
    
    :param elem is a last character of operator determining type of value to be created.
     */

static bool evalNewto(char elem, PNVMToken & result) {
    assert(charisOneOf(elem, "sat"));
    if (elem == 's') {
        pnvmTokenSetPointer(result, pnvmStringNew());
    } else {
        if (elem == 'a') {
            pnvmTokenSetPointer(result, pnvmArrayNew());
        } else {
            if (elem == 't') {
                pnvmTokenSetPointer(result, pnvmTupleNew());
            } else {
                dieWithmsgwith(ErrorExecutionUnhandledOperator, "unhandled second character of new operator: ", elem);
            }
        }
    }
    if ((pnvmTokenPointer(result)) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate object for operator 'n" << elem << "' while evaluating transition expression.")
        return setInvalidResult(result);
    }
    return 1;
}

static bool evalNotto(PNVMToken const & token, PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (evalIsTrue(token)) {
        pnvmTokenSetInteger(result, 0);
    } else {
        pnvmTokenSetInteger(result, 1);
    }
	LOG4CXX_INFO(exlog, "" << pnvmTokenInteger(result) << " = ! " << token)
    return 1;
}

static bool evalReadPinto(PNVMToken const & token, PNVMToken & result) {
    int res;
    int at;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (!((pnvmTokenType(token)) == TOKEN_TYPE_INTEGER)) {
		LOG4CXX_ERROR(exlog, "failed to read from pin: pin needs to be specified by integer")
        return setInvalidResult(result);
    }
    at = pnvmTokenInteger(token);
    if ((at < LowestPin) || (at > HighestPin)) {
		LOG4CXX_ERROR(exlog, "pin index is out of bounds (" << at << ")")
        return setInvalidResult(result);
    }
    res = 0;
    res = digitalRead(at);
    pnvmTokenSetInteger(result, res);
	LOG4CXX_INFO(exlog, pnvmTokenInteger(result) << " = digitalInput(" << at << ")")
    return 1;
}

static bool evalSendtohistory(PNVMToken & token, PNVMToken & result, PNVMArrayIter & history) {
    PNVMToken tmp;
    PNVMTupleIter ai;
    PNVMTupleHead *action;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (!(pnvmTokenIsValid(token))) {
		LOG4CXX_ERROR(exlog, "can not send invalid value")
        return setInvalidResult(result);
    }
    outputValue(token);
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
        return setInvalidResult(result);
    }
    ai = pnvmValueIterator(action);
    tmp = pnvmNewInteger(((int)'s'));
    pnvmIterWrite(ai, tmp);
    pnvmIterWrite(ai, token);
    appendActiontoHistoryWith(action, history);
    pnvmTokenAssign(result, token);
	LOG4CXX_INFO(exlog, "token " << result << " sent to output buffer")
    return 1;
}

static bool evalTailto(PNVMToken const & token, PNVMToken & result) {
    PNVMItemIterator i;
    PNVMItemIterator o;
    PNVMHeaderBlock *tail;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    tail = NULL;
    if (!(((pnvmTokenType(token)) == TOKEN_TYPE_POINTER) && (pnvmTokenIsValid(token)))) {
		LOG4CXX_ERROR(exlog, "can not get head from not indexable or invalid value")
        return setInvalidResult(result);
    }
    if ((pnvmValueItemCount(pnvmTokenPointer(token))) < 1) {
		LOG4CXX_ERROR(exlog, "collection is empty")
        return setInvalidResult(result);
    }
    i = pnvmValueIterator(((PNVMHeaderBlock *) (pnvmTokenPointer(token))));
    if ((signature(pnvmTokenPointer(token))) == SIGN_STRING) {
        tail = pnvmStringNew();
    } else {
        if ((signature(pnvmTokenPointer(token))) == SIGN_ARRAY) {
            tail = pnvmArrayNew();
        } else {
            if ((signature(pnvmTokenPointer(token))) == SIGN_TUPLE) {
                tail = pnvmTupleNew();
            } else {
                dieWithmsgwith(ErrorExecutionUnhandledSignature, "unexpected kind of block: ", dereference(pnvmTokenPointer(token)));
            }
        }
    }
    if (tail == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tail for value")
        return setInvalidResult(result);
    }
    o = pnvmValueIterator(tail);
    pnvmIterNext(i);
    copyValueItemsFromto(i, o);
    pnvmTokenSetPointer(result, tail);
	LOG4CXX_INFO(exlog, "" << result << " = tail(" << token << ")")
    return 1;
}


/*	
    Evaluates $i operator.
    Result is a boolean saying, whether the unload was successful.
    
    :param token is a string with name of template to unload.
     */

static bool evalUnloadtohistory(PNVMToken const & token, PNVMToken & result, PNVMArrayIter & history) {
    PNVMToken tmp;
    PNVMTemplate *tmpl;
    PNVMTupleIter ai;
    int index;
    PNVMStringHead *name;
    PNVMTupleHead *action;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    if (((pnvmTokenType(token)) != TOKEN_TYPE_POINTER) || ((signature(pnvmTokenPointer(token))) != SIGN_STRING)) {
		LOG4CXX_ERROR(exlog, "failed to unload template, operand must be a string")
        return setInvalidResult(result);
    }
    name = ((PNVMStringHead *) (pnvmTokenPointer(token)));
    tmpl = findNetTemplate(name);
    pnvmValueDelete(name);
    if (tmpl == NULL) {
		LOG4CXX_ERROR(exlog, "failed to find net template with name '" << asPlainString(name) << "'")
        pnvmTokenSetInteger(result, 0);
        return 1;
    }
    if (((pnvmTemplateInstances(tmpl)) != NULL) && ((pnvmValueItemCount(pnvmTemplateInstances(tmpl))) > 0)) {
		LOG4CXX_ERROR(exlog, "can not unload template with alive instances")
        pnvmTokenSetInteger(result, 0);
        return 1;
    }
    index = 0;
    while (!((netTemplateTable[index]) == tmpl)) {
        index += 1;
    }
    pnvmTokenSetInteger(result, 1);
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
        return setInvalidResult(result);
    }
    ai = pnvmValueIterator(action);
    tmp = pnvmNewInteger(((int)'u'));
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, index);
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetPointer(tmp, tmpl);
    pnvmIterWrite(ai, tmp);
    appendActiontoHistoryWith(action, history);
    numberOfNetTemplates -= 1;
    netTemplateTable[index] = NULL;
	LOG4CXX_INFO(exlog, "unloaded net template '" << pnvmTemplateName(tmpl) << "' from index=" << index)
    return 1;
}

static bool evalWriteAtValueto(PNVMToken const & tokenA, PNVMToken const & tokenB, PNVMToken & result) {
    int at;
    int value;

    /* assert(interpreterProxy->isKindOf(tokenA,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tokenB,'PNVMToken')); */
    if (!((pnvmTokenType(tokenA)) == TOKEN_TYPE_INTEGER)) {
		LOG4CXX_ERROR(exlog, "failed to write to pin: pin needs to be specified by integer")
        return setInvalidResult(result);
    }
    at = pnvmTokenInteger(tokenA);
    if ((at < LowestPin) || (at > HighestPin)) {
		LOG4CXX_ERROR(exlog, "pin index is out of bounds (" << at << ")")
        return setInvalidResult(result);
    }
    value = evalIsTrue(tokenB);
    digitalWrite(at, value ? HIGH:LOW);
    pnvmTokenAssign(result, tokenB);
	LOG4CXX_INFO(exlog, "written " << value << " to pin " << at)
    return 1;
}


/*	
    It recursively evaluates expression and returns boolean.
    Some parameters are short-circuit evaluated.
    
    :param codeptr is modified. It's placed to the end of expression if the result is true.
        Otherwise it's value is undefined.
    :param history only gets new items. It's caller's responsibility to restore it upon failure.
    :param result will be filled with the result of expression's evaluation.
    
    Returns true upon successful evaluation.
     */

static bool evaluateExpressionAtontowithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMToken & result, PNVMTupleHead *vars, PNVMArrayIter & history) {
    char elem;
    char elem2;
    PNVMToken tmp;
    int satisfied;
    char const *  codeptrOrig;
    PNVMToken op2;
    PNVMToken op1;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(codeptr,'CArrayAccessor')); */
    /* assert(interpreterProxy->isKindOf(result,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    assert((codeptr[0]) == (((int)'(')));
	LOG4CXX_DEBUG(exlog, "entering evaluateExpressionAt:on:to:withVariables:history:")
    codeptrOrig = codeptr + 0;
    satisfied = 0;
    elem = codeptr[1];
    elem2 = 0;
    tmpl = pnvmNetInstTemplate(inst);
    if (elem == 'd') {

        /* dump memory - TODO */

        codeptr++;
        codeptr++;
        codeptr++;
        return evalDumpto(inst, result);
    }
    if (elem == 'n') {
        elem2 = codeptr[2];
        codeStoreOffsettoRef(codeptr + 4, codeptr);
        return evalNewto(elem2, result);
    }
    if (charisOneOf(elem, "ISV")) {

        /* one of symbol, integer or variable */

        codeptr++;
        tmp = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
        pnvmTokenAssign(result, tmp);
        pnvmTokenMakeInvalid(tmp);
        codeptr++;
		LOG4CXX_DEBUG(exlog, "leaving evaluateExpressionAt:on:to:withVariables:history: with success")
        return 1;
    }
    codeptr++;
    codeptr++;
    if (charisOneOf(elem, "!phtlicsu")) {
        if ((elem == 'i') && (charisOneOf(codeptr[0], "vistan"))) {

            /* 2-character operator */

            elem2 = codeptr[0];
            ;
            codeptr++;
        }
    }

    /* let's get the first operand */

    op1 = pnvmNewToken();
    if (!(evaluateExpressionAtontowithVariableshistory(codeptr, inst, op1, vars, history))) {
		LOG4CXX_DEBUG(exlog, "leaving evaluateExpressionAt:on:to:withVariables:history: with failure")
        return 0;
    }
    if (elem == '!') {

        /* not */

        satisfied = evalNotto(op1, result);
    } else {
        if (elem == 'p') {

            /* read pin */

            satisfied = evalReadPinto(op1, result);
        } else {
            if (elem == 'h') {

                /* get head from collection */

                satisfied = evalHeadto(op1, result);
            } else {
                if (elem == 't') {

                    /* get tail from collection */

                    satisfied = evalTailto(op1, result);
                } else {
                    if (elem == 'l') {

                        /* load net template from string */

                        satisfied = evalLoadTemplatetohistory(op1, result, history);
                    } else {
                        if (elem == 'u') {

                            /* unload net template */

                            satisfied = evalUnloadtohistory(op1, result, history);
                        } else {
                            if (elem == 'c') {

                                /* create net instance */

                                satisfied = evalCreateNetInstto(op1, result);
                            } else {
                                if (elem == 's') {

                                    /* send value to output buffer */

                                    satisfied = evalSendtohistory(op1, result, history);
                                } else {
                                    if ((elem == 'i') && (elem2 == 0)) {

                                        /* load net instance from string */

                                        satisfied = evalLoadNetInstto(op1, result);
                                    } else {
                                        if ((elem == 'i') && (elem2 == 'v')) {

                                            /* is value valid? */

                                            satisfied = evalIsValidto(op1, result);
                                        } else {
                                            if ((elem == 'i') && (elem2 == 'i')) {

                                                /* is value integer? */

                                                satisfied = evalIsIntegerto(op1, result);
                                            } else {
                                                if ((elem == 'i') && (elem2 == 's')) {

                                                    /* is value string? */

                                                    satisfied = evalIsStringto(op1, result);
                                                } else {
                                                    if ((elem == 'i') && (elem2 == 't')) {

                                                        /* is value tuple? */

                                                        satisfied = evalIsTupleto(op1, result);
                                                    } else {
                                                        if ((elem == 'i') && (elem2 == 'a')) {

                                                            /* is value array? */

                                                            satisfied = evalIsArrayto(op1, result);
                                                        } else {
                                                            if ((elem == 'i') && (elem2 == 'n')) {

                                                                /* is value net instance? */

                                                                satisfied = evalIsNetRefto(op1, result);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (charisOneOf(elem, "!phtlcsiu")) {
        pnvmTokenMakeInvalid(op1);
        codeptr++;
        return satisfied;
    }
    if ((elem == '&') || (elem == '|')) {

        /* short-circuit evaluated operands */

        if (((elem == '&') && (!(evalIsTrue(op1)))) || ((elem == '|') && (evalIsTrue(op1)))) {

            /* caller expects us to parse the whole expression */

            codeSeekSkipExpression(codeptr);
            codeptr++;
            pnvmTokenAssign(result, op1);
			LOG4CXX_DEBUG(exlog, "" << elem << " evaluates to first operand: " << op1)
            pnvmTokenMakeInvalid(op1);
			LOG4CXX_DEBUG(exlog, "leaving evaluateExpressionAt:on:to:withVariables:history: with success")
            return 1;
        }
    }
    op2 = pnvmNewToken();
    if (!(evaluateExpressionAtontowithVariableshistory(codeptr, inst, op2, vars, history))) {
		LOG4CXX_DEBUG(exlog, "leaving evaluateExpressionAt:on:to:withVariables:history: with failure")
        pnvmTokenMakeInvalid(op1);
        return 0;
    }
    assert((codeptr[0]) == (((int)')')));
    codeptr++;
    if (elem == ':') {
        codeptrOrig++;
        codeptrOrig++;

        /* release only the second argument */
        /* first one belongs to variables */

        satisfied = evalAssignatCodewithVariablestohistory(op1, op2, codeptrOrig, vars, result, history);
        pnvmTokenMakeInvalid(op2);
        return satisfied;
    } else {
        if (elem == ',') {
            satisfied = evalConcatenateto(op1, op2, result);
        } else {
            if (elem == '+') {
                satisfied = evalAddto(op1, op2, result);
            } else {
                if (elem == '-') {
                    satisfied = evalMinusto(op1, op2, result);
                } else {
                    if (elem == '*') {
                        satisfied = evalTimesto(op1, op2, result);
                    } else {
                        if (elem == '/') {
                            satisfied = evalDividedto(op1, op2, result);
                        } else {
                            if (elem == '%') {
                                satisfied = evalModuloto(op1, op2, result);
                            } else {
                                if (elem == '=') {
                                    satisfied = evalIsEqualToto(op1, op2, result);
                                } else {
                                    if (elem == '<') {
                                        satisfied = evalIsSmallerThanto(op1, op2, result);
                                    } else {
                                        if (elem == '>') {
                                            satisfied = evalIsGreaterThanto(op1, op2, result);
                                        } else {
                                            if (elem == '&') {
                                                satisfied = evalAndto(op1, op2, result);
                                            } else {
                                                if (elem == '|') {
                                                    satisfied = evalOrto(op1, op2, result);
                                                } else {
                                                    if (elem == '^') {
                                                        satisfied = evalXorto(op1, op2, result);
                                                    } else {
                                                        if (elem == 'o') {
                                                            satisfied = evalWriteAtValueto(op1, op2, result);
                                                        } else {
                                                            if (elem == '#') {
                                                                satisfied = evalGetto(op1, op2, result);
                                                            } else {
                                                                if (elem == 'a') {
                                                                    satisfied = evalPushBacktohistory(op1, op2, result, history);
                                                                } else {
                                                                    dieWithmsgwith(ErrorExecutionUnhandledOperator, "unhandled expression operator: ", elem);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pnvmTokenMakeInvalid(op1);
    pnvmTokenMakeInvalid(op2);
    return satisfied;
}


/*	
    Makes uplink call to another instance. This is a generic function callable either from
    interpreter itself or from transition code of some other net instance.
    
    :param name: name of uplink transition in targeted instance
    :param inst: target net instance
    :param params: tuple containing uplink parameters. Free parameters may be binded
        after the successful execution of this call.
    :param lastAttempt: iterator to array of attempts.
        On the first call this points at the end of array.
    :param history: iterator pointing at the end of history array.
     */

static bool executeDownlinkonwithParameterslastAttempthistory(PNVMStringHead const *name, PNVMNetInstHead *inst, PNVMTupleHead *params, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
    PNVMTupleIter pi;
    PNVMTupleIter vi;
    int satisfied;
    char const *codeptr;
    PNVMTupleHead *vars;
    unsigned int paramN;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(name,'PNVMStringHead')); */
    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(params,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    tmpl = pnvmNetInstTemplate(inst);
	LOG4CXX_INFO(exlog, "executeDownlink: " << asPlainString(name) << " on: (instance of " << asPlainString(pnvmTemplateName(tmpl)) << ") withParameters:lastAttempt:history:")
    if (((codeptr = findUplinkin(name, tmpl))) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to find uplink " << asPlainString(name) << " in template " << dereference(tmpl))
        return 0;
    }

    /* (U */
    /* this also skips parameters */

    codeptr = (codeptr + 2) + (pnvmValueItemCount(name));
    paramN = codeGetVariableCount(codeptr);
    if (paramN != (pnvmValueItemCount(params))) {
		LOG4CXX_ERROR(exlog, "number of parameters does not match for uplink " << asPlainString(name))
        return 0;
    }
    if (((vars = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple for variables")
        return 0;
    }
    vi = pnvmValueIterator(vars);
    pi = pnvmValueIterator(params);
    while (!(pnvmIterAtEnd(pi))) {
        pnvmIterWrite(vi, pnvmIterNext(pi));
    }
    changeBlockSizeOfto(vars, (codeGetVariableCount(codeptr)) + paramN);
    if ((satisfied = executeTransitionElementsAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) {

        /* first remove the assignments to temporary variables from history */

        clearVariableAssignments(history);
        pnvmIterSeekStart(vi);
        pnvmIterSeekStart(pi);
        while (!(pnvmIterAtEnd(pi))) {

            /* write variables to free parameters */

            if (!(pnvmTokenIsValid(pnvmIterValue(pi)))) {
                pnvmIterSetItem(pi, pnvmIterValue(vi));
            }
            pnvmIterNext(pi);
            pnvmIterNext(vi);
        }
    }
    pnvmValueDelete(vars);
	LOG4CXX_INFO(exlog, "leaving executeDownlink: " << asPlainString(name) << " on: (instance of " << dereference(tmpl) << ") withParameters:lastAttempt:history: (success=" << satisfied << ")")
    return satisfied;
}


/*	
    This executes $D element of transition code.
    Expected format of code (D <uplinkNameNullTerminated> <receiver>
        <paramCount> <param-0> <param-1> ... <param-(paramCount - 1)>).
    
    :param codeptr points after the $D elem.
    :param lastAttempt must point to the end upon the first invocation.
        If invocation succeeds, it will contain new array of attempts for uplink's transition code.
     */

static bool executeDownlinkAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
    PNVMTupleHead *mapping;
    PNVMArrayHead *nestedAttempts;
    PNVMTupleIter pi;
    PNVMTupleIter vi;
    PNVMStringHead *name;
    PNVMNetInstHead *receiver;
    int paramCount;
    PNVMTupleIter mi;
    PNVMTupleHead *params;
    PNVMToken tmp;
    bool satisfied;
    PNVMArrayIter nli;
    PNVMToken param;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator')); */
	LOG4CXX_DEBUG(exlog, "entering executeDownlinkAt:on:withVariables:lastAttempt:history:")

    /* skips name including 0 */

    tmpl = pnvmNetInstTemplate(inst);
    if (((name = parseCString(codeptr))) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to parse name of net template")
        return 0;
    }
    vi = pnvmValueIterator(vars);
    pnvmIterSeek(vi, memLoadShort(codeptr));
    if (!((pnvmTokenType(pnvmIterValue(vi))) == TOKEN_TYPE_NET_REF)) {

        /* variable must be instance */

		LOG4CXX_ERROR(exlog, "expected net instance in variable")
        pnvmValueDelete(name);
		LOG4CXX_DEBUG(exlog, "leaving executeDownlinkAt:on:withVariables:lastAttempt:history: with failure")
        return 0;
    }
    receiver = pnvmTokenNetRef(pnvmIterValue(vi));
    codeptr++;
    codeptr++;
    if (((mapping = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocated tuple for parameters mapping")
        return 0;
    }
    mi = pnvmValueIterator(mapping);
    if (((params = pnvmTupleNew())) == NULL) {
        pnvmValueDelete(mapping);
		LOG4CXX_ERROR(exlog, "failed to allocated tuple for downlink parameters")
        return 0;
    }
    pi = pnvmValueIterator(params);
    paramCount = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    tmp = pnvmNewToken();
    while (paramCount > 0) {
        param = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
        if (((codeptr - 3)[0]) == (((int)'V'))) {

            /* write index of previous variable to mapping for later reassignment */

            pnvmTokenSetInteger(tmp, memLoadShort(codeptr - 2));
            pnvmIterWrite(mi, tmp);
        } else {

            /* not a variable - do not assign to it on binding */

            pnvmTokenMakeInvalid(tmp);
            pnvmIterWrite(mi, tmp);
        }
        pnvmIterWrite(pi, param);
        pnvmTokenMakeInvalid(param);
        paramCount -= 1;
    }
    codeptr++;
    if (pnvmIterAtEnd(lastAttempt)) {

        /* first attempt to execute downlink; let's create new storage for attempts */

        if (((nestedAttempts = pnvmArrayNew())) == NULL) {
            pnvmValueDelete(params);
            pnvmValueDelete(mapping);
			LOG4CXX_ERROR(exlog, "failed to allocated array for downlink's last attempts")
            return 0;
        }
        tmp = pnvmNewPointer(nestedAttempts);
        pnvmIterWrite(lastAttempt, tmp);
        pnvmTokenMakeInvalid(tmp);
    } else {
        assert((pnvmTokenType(pnvmIterValue(lastAttempt))) == TOKEN_TYPE_POINTER);
        /* assert(interpreterProxy->isKindOf((pnvmTokenPointer(pnvmIterValue(lastAttempt))),'PNVMTupleHead')); */
        nestedAttempts = ((PNVMArrayHead *) (pnvmTokenPointer(pnvmIterValue(lastAttempt))));
    }
    nli = pnvmValueIterator(nestedAttempts);
    satisfied = executeDownlinkonwithParameterslastAttempthistory(name, receiver, params, nli, history);
    pnvmValueDelete(name);
    if (!(satisfied)) {
        pnvmValueDelete(params);
        pnvmValueDelete(mapping);
		LOG4CXX_DEBUG(exlog, "leaving executeDownlinkAt:on:withVariables:lastAttempt:history: with failure")
        return 0;
    }
    bindVariableswithParamsmappinghistory(vars, params, mapping, history);
    pnvmValueDelete(params);
    pnvmValueDelete(mapping);
	LOG4CXX_DEBUG(exlog, "leaving executeDownlinkAt:on:withVariables:lastAttempt:history: with success")
    return 1;
}


/*	
    Execute one transition element on instance. This should only be called from:
        executeTransitionElementsAt:on:withVariables:lastAttempt:history:
    
    :param: lastAttempt: is an iterator to attempts of execution. If it points at the end of
        array, we know that this is the first time we are invoked. So the first attempt is made.
        Otherwise the iterator points at the information we left there last time we were called.
        It represents attempt from which we should continue in search for some other variable
        binding.
        
        If there are more options to execute this element, we store information about current
        attempt made at the current position of iterator.
    :param: history: will be extended for any actions modifying interpreter state.
        We don't care about cleaning/restoring it here. That's taken care of by parent function.
    
    Return true, if the element has been executed successfully.
     */

static bool executeOneTransitionElementAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
    PNVMToken tmp;
    char elem;
    char const *i;
    bool satisfied;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    assert((codeptr[0]) == (((int)'(')));
	LOG4CXX_DEBUG(exlog, "entering executeOneTransitionElementAt:on:withVariables:lastAttempt:history:")
    elem = codeptr[1];
    ;
    if ((elem == 'G') || (elem == 'A')) {

        /* recursively process guard or action expression - just one way to do it */

        tmp = pnvmNewToken();
        i = codeptr + 2;
        satisfied = evaluateExpressionAtontowithVariableshistory(i, inst, tmp, vars, history);
        codeStoreOffsettoRef(i + 1, codeptr);

        /* release the result of expression if any */

        satisfied = satisfied && ((elem != 'G') || (evalIsTrue(tmp)));
        pnvmTokenMakeInvalid(tmp);
		LOG4CXX_DEBUG(exlog, "leaving executeOneTransitionElementAt:on:withVariables:lastAttempt:history: " << " (success=" << satisfied << ")")
        return satisfied;
    }
    codeptr++;
    codeptr++;
    if (elem == 'D') {
        return executeDownlinkAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history);
    }
    if (elem == 'P') {
        return executeTakeTokenAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history);
    }
    if (elem == 'O') {
        return executePutTokenAtonwithVariableshistory(codeptr, inst, vars, history);
    }
    if (elem == 'Y') {
        return executeSchedulePutAtonwithVariableshistory(codeptr, inst, vars, history);
    }
    dieWithmsgwith(ErrorExecutionUnhandledTransitionElement, "unhandled code element: ", elem);
    return 0;
}


/*	
    Put amount of tokens to place (O <placeId> <amount> {V,S,I} <value>).
    There is just one way to do it -> no need for another attempts.
    
    :param codePos points after the $O elem.
     */

static bool executePutTokenAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history) {
    PNVMTupleIter ai;
    PNVMTupleHead *action;
    PNVMToken tmp;
    PNVMToken value;
    int placeId;
    int amount;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    assert((codeptr[-1]) == (((int)'O')));
	LOG4CXX_DEBUG(exlog, "entering executePutTokenAt:on:withVariables:history:")
    tmpl = pnvmNetInstTemplate(inst);
    placeId = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    amount = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    value = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
    if (!(pnvmTokenIsValid(value))) {
		LOG4CXX_ERROR(exlog, "attempt to write free variable to place")
		LOG4CXX_DEBUG(exlog, "leaving executePutTokenAt:on:withVariables:history: with failure")
        return 0;
    }
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
        return 0;
    }
    ai = pnvmValueIterator(action);
    tmp = pnvmNewInteger(((int)'O'));
    pnvmIterWrite(ai, tmp);
    tmp = pnvmNewNetRef(inst);
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, placeId);
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, amount);
    pnvmIterWrite(ai, tmp);
    pnvmIterWrite(ai, value);
    appendActiontoHistoryWith(action, history);
    putNtokenstoPlaceofNetInst(amount, value, placeId, inst);
    pnvmTokenMakeInvalid(value);
    codeptr++;
	LOG4CXX_DEBUG(exlog, "leaving executePutTokenAt:on:withVariables:history: with success")
    return 1;
}


/*	
    Delay the insertion of <amount> tokens to place.
    Expected code format: (Y <placeId> <amount> {V,S,I} <value> <time>).
    There is just one way to do it -> no need for more attempts.
    
    :param codePos points after the $Y elem.
     */

static bool executeSchedulePutAtonwithVariableshistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & history) {
    PNVMTupleIter ai;
    PNVMTupleHead *action;
    PNVMToken tmp;
    PNVMToken value;
    int placeId;
    int amount;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    assert((codeptr[-1]) == (((int)'Y')));
	LOG4CXX_DEBUG(exlog, "entering executeSchedulePutAt:on:withVariables:history:")
    tmpl = pnvmNetInstTemplate(inst);
    placeId = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    amount = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    value = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
    if (!(pnvmTokenIsValid(value))) {
		LOG4CXX_ERROR(exlog, "attempt to write free variable to place")
		LOG4CXX_DEBUG(exlog, "leaving executeSchedulePutAt:on:withVariables:history: with failure")
        return 0;
    }
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
        return 0;
    }
    ai = pnvmValueIterator(action);
    tmp = pnvmNewInteger(((int)'Y'));
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetPointer(tmp, calScheduletimestoPlaceofInstat(value, amount, placeId, inst, (memLoadLong(codeptr)) + currentTime));
    if (!(pnvmTokenIsValid(tmp))) {
		LOG4CXX_ERROR(exlog, "failed to schedule event")
        pnvmValueDelete(action);
        return 0;
    }
    pnvmIterWrite(ai, tmp);
    pnvmTokenMakeInvalid(tmp);
	LOG4CXX_INFO(exlog, "scheduled insertion of " << amount << " of tokens " << value << " to place " << placeId << " of instance " << inst << " at time: " << memLoadLong(codeptr))
    appendActiontoHistoryWith(action, history);
    codeStoreOffsettoRef(codeptr + 5, codeptr);
    pnvmTokenMakeInvalid(value);
	LOG4CXX_DEBUG(exlog, "leaving executeSchedulePutAt:on:withVariables:history: with success")
    return 1;
}


/*	
    Remove amount of tokens from place (P <placeId> <amount> {V,SI} <value>).
    There is many ways to select a token (number of items in place).
    
    :param codePos points after the $P elem.
     */

static bool executeTakeTokenAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
    PNVMPlaceIter pi;
    PNVMPlaceHead *place;
    PNVMTupleIter vi;
    PNVMTupleIter ai;
    PNVMNetInstIter ni;
    PNVMTupleHead *action;
    int attempt;
    int valueId;
    PNVMToken tmp;
    PNVMToken value;
    int placeId;
    unsigned int amount;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator')); */
    assert((codeptr[-1]) == (((int)'P')));
	LOG4CXX_DEBUG(exlog, "entering executeTakeTokenAt:on:withVariables:lastAttempt:history:")
    tmpl = pnvmNetInstTemplate(inst);
    placeId = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    amount = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    value = getTokenForValueOnPosinTemplatewithVariables(codeptr, tmpl, vars);
    ni = pnvmValueIterator(inst);
    pnvmIterSeek(ni, placeId);
    place = pnvmIterValue(ni);
    pi = pnvmValueIterator(place);
    attempt = 0;
    if (!(pnvmIterAtEnd(lastAttempt))) {
        unlessdieWithmsgwith((pnvmTokenType(pnvmIterValue(lastAttempt))) == TOKEN_TYPE_INTEGER, ErrorExecutionUnspecified, "unexpected last attempt: ", pnvmIterValue(lastAttempt));
        attempt = (pnvmTokenInteger(pnvmIterValue(lastAttempt))) + 1;
    }
    if ((((unsigned int) attempt)) >= (pnvmValueItemCount(pnvmIterHeaderBlock(pi)))) {
        pnvmTokenMakeInvalid(value);
		LOG4CXX_DEBUG(exlog, "leaving executeTakeTokenAt:on:withVariables:lastAttempt:history:" << " with failure (no more items to try)")
        return 0;
    }
    tmp = pnvmNewInteger(attempt);
    pnvmIterWrite(lastAttempt, tmp);
    pnvmIterSeek(pi, attempt);
    if ((pnvmPlaceItemNumber(pnvmIterValue(pi))) < amount) {

        /* required amount of tokens not present */

        pnvmTokenMakeInvalid(value);
		LOG4CXX_DEBUG(exlog, "leaving executeTakeTokenAt:on:withVariables:lastAttempt:history:" << " with failure (required amount of tokens not present)")
        return 0;
    }
    if ((pnvmTokenIsValid(value)) && ((cmpTokenwith(value, pnvmPlaceItemToken(pnvmIterValue(pi)))) != 0)) {

        /* token must match precise value given by code */

        pnvmTokenMakeInvalid(value);
		LOG4CXX_DEBUG(exlog, "leaving executeTakeTokenAt:on:withVariables:lastAttempt:history:" << " with failure (token must match precise value given by code)")
        return 0;
    }
    if (!(pnvmTokenIsValid(value))) {

        /* store the token in vars */

        valueId = memLoadShort(codeptr - 2);
		LOG4CXX_INFO(exlog, "storing token " << pnvmPlaceItemToken(pnvmIterValue(pi)) << " in variable " << valueId)
        vi = pnvmValueIterator(vars);
        pnvmIterSeek(vi, valueId);
        if (((action = pnvmTupleNew())) == NULL) {
			LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
            return 0;
        }
        ai = pnvmValueIterator(action);
        pnvmTokenSetInteger(tmp, ((int)':'));
        pnvmIterWrite(ai, tmp);
        pnvmTokenSetInteger(tmp, valueId);
        pnvmIterWrite(ai, tmp);
        appendActiontoHistoryWith(action, history);
        pnvmIterWrite(vi, pnvmPlaceItemToken(pnvmIterValue(pi)));
    }
    if (((action = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store history action")
        return 0;
    }
    ai = pnvmValueIterator(action);
    pnvmTokenSetInteger(tmp, ((int)'P'));
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetNetRef(tmp, inst);
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, placeId);
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, pnvmIterIndex(pi));
    pnvmIterWrite(ai, tmp);
    pnvmTokenSetInteger(tmp, amount);
    pnvmIterWrite(ai, tmp);
    pnvmIterWrite(ai, pnvmPlaceItemToken(pnvmIterValue(pi)));
    appendActiontoHistoryWith(action, history);
    if (((pnvmPlaceItemNumber(pnvmIterValue(pi))) - amount) == 0) {
		LOG4CXX_INFO(exlog, "removing " << amount << " of tokens " << pnvmPlaceItemToken(pnvmIterValue(pi)) << " from place " << placeId << " of instance " << dereference(inst))
        removeItemFromBlockAt(pnvmIterAsItemIterator(pi));
    } else {
        pnvmPlaceItemDecBy(pnvmIterValue(pi), amount);
		LOG4CXX_INFO(exlog, "decreased number of tokens " << pnvmPlaceItemToken(pnvmIterValue(pi)) << " from place " << placeId << " of instance " << inst << " by " << amount << " to " << pnvmPlaceItemNumber(pnvmIterValue(pi)))
    }
    pnvmTokenMakeInvalid(value);
    codeptr++;
	LOG4CXX_DEBUG(exlog, "leaving executeTakeTokenAt:on:withVariables:lastAttempt:history: with success")
    return 1;
}


/*	
    This is a recursive function executing transition elements. Function executes one transition
    element and if it is successful, it nests a level down.
    This is done rerursevely until all transition elements are finished.
    
    Check for transition elements end is at the beggining of function.
    
    Main principle
    =========
    If the executed transition and all of the following were executed successfully do the following:
        1.	Keep the lastAttemps, which may or may not be changed by nested execution.
            We may be called again by our parent to continue from the last attempt in finding
            next possible variable binding.
        2.	Keep the history. History will be cleared by invoker if the whole transition is successful.
        3.	Return true.
    If the first transition (the one at our level) fails:
        1.	There are no other options left, so let's delete lastAttempts from our position
            (the position in array of attempts we have been given). Parent may try to call
            us with different variables binded, so we may make some more attempts in
            the future from the same position in attempts array.
        2.	Restore history from our position to state before we were called.
        3.	Return false.
    If the first transition succeeds, be the nested ones don't:
        1.	Let's restore history from our position, before calling first transition again.
        2.	If there are more attempts to try in the first transition, let's call it again and
            nest down once more with different binding. We know, that there are more
            attempts to try if the first transition shifted lastAttempt iterator.
        3.	Repeat 1. and 2. until either first transition fails -> no more attemts to try, or
            nested execution succeeds.
     */

static bool executeTransitionElementsAtonwithVariableslastAttempthistory(char const * & codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars, PNVMArrayIter & lastAttempt, PNVMArrayIter & history) {
    char const *codeptrBackup;
    int lastAttemptOrigPos;
    int attemptsToTry;
    int historyOrigPos;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(history,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(lastAttempt,'PNVMItemIterator')); */
    assert(charisOneOf(codeptr[0], "()"));
	LOG4CXX_DEBUG(exlog, "entering executeTransitionElementsAt:on:withVariables:lastAttempt:history:")
    if ((codeptr[0]) == (((int)')'))) {

        /* we have reached the end of elements; transition is complete */

		LOG4CXX_DEBUG(exlog, "leaving executeTransitionElementsAt:on:withVariables:lastAttempt:history:" << " with success (no more transition elements)")
        return 1;
    }
    historyOrigPos = pnvmIterIndex(history);
    lastAttemptOrigPos = pnvmIterIndex(lastAttempt);
    attemptsToTry = 1;
    codeptrBackup = codeptr + 0;
    while (attemptsToTry) {

        /* restore position of last attempt iterator */

        pnvmIterSeek(lastAttempt, lastAttemptOrigPos);
        if (((attemptsToTry = executeOneTransitionElementAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) && (executeTransitionElementsAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) {

            /* transition has been successfuly completed, caller should clean up the history */

			LOG4CXX_DEBUG(exlog, "leaving executeTransitionElementsAt:on:withVariables:lastAttempt:history: with success")
            return 1;
        }
        attemptsToTry = attemptsToTry && ((pnvmIterIndex(lastAttempt)) > lastAttemptOrigPos);
        codeStoreOffsettoRef(codeptrBackup, codeptr);
        pnvmIterSeek(history, historyOrigPos);
        restoreHistoryFromPoswithVariables(history, vars);
    }
    pnvmIterSeek(lastAttempt, lastAttemptOrigPos);
    cleanLastAttemptsFromPos(lastAttempt);
	LOG4CXX_DEBUG(exlog, "leaving executeTransitionElementsAt:on:withVariables:lastAttempt:history: with failure")
    return 0;
}


/*	
    Can be called to check, whether the serious error occured.
    
    Return Boolean.
     */

bool failed(void) {
    return error != ErrorSuccess;
}


/*	
    Shifts code lying after the hole created by removal of some net template.
    If holes were allowed, free memory would get soon fragmented.
    Returns new code length.
     */

static int fillCodeHoles(void) {
    int i;
    PNVMTemplate *tmpl;
    int ci;
    int index;
    int codeSize;
    int ciLimiT;

    index = 0;
    codeSize = 0;
    for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
        tmpl = netTemplateTable[index];
        if (codeSize < (pnvmTemplateCodeOffset(tmpl))) {
            pnvmTemplateSetTransitions(tmpl, codeSize + ((pnvmTemplateTransitions(tmpl)) - (pnvmTemplateCodeOffset(tmpl))));
            for (ci = 0, ciLimiT = ((pnvmTemplateCodeLength(tmpl)) - 1); ci <= ciLimiT; ci += 1) {
                netTemplateCode[codeSize] = (netTemplateCode[(pnvmTemplateCodeOffset(tmpl)) + ci]);
                codeSize += 1;
            }
            pnvmTemplateSetCodeOffset(tmpl, codeSize - (pnvmTemplateCodeLength(tmpl)));
        } else {
            codeSize += pnvmTemplateCodeLength(tmpl);
        }
        index += 1;
        while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == NULL)) {
            index += 1;
        }
    }
    return codeSize;
}

static PNVMTemplate * findNetTemplate(PNVMStringHead const *name) {
    int i;
    int index;

    index = 0;
    for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
        if ((cmpStringwith(name, pnvmTemplateName(netTemplateTable[index]))) == 0) {
            return netTemplateTable[i];
        }
        index += 1;
        while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == NULL)) {
            index += 1;
        }
    }
	LOG4CXX_ERROR(exlog, "failed to find template: " << asPlainString(name))
    return NULL;
}


/*	
    Try to find uplink in net template code.
    Uplink is searched by its name.
    
    If uplink is found, return pointer pointing at the opening bracket just before $U.
    Otherwise nil is returned.
     */

static char const * findUplinkin(PNVMStringHead const *name, PNVMTemplate const *tmpl) {
    PNVMStringHead *tmp;
    PNVMStringIter o;
    char const *uplinkStart;
    char const *codeptr;

    /* assert(interpreterProxy->isKindOf(name,'PNVMStringHead')); */
    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    if (((tmp = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate temporary string for uplink name")
        return NULL;
    }
    o = pnvmValueIterator(tmp);
    codeptr = getCodeIteratorAt((pnvmTemplateCodeOffset(tmpl)) + 2);
    while ((codeptr[0]) == (((int)'('))) {

        /* save the position for later return */

        uplinkStart = codeptr + 0;
        codeptr++;
        if (!((codeptr[0]) == (((int)'U')))) {
			LOG4CXX_ERROR(exlog, "failed to find uplink " << asPlainString(name) << " in template " << dereference(tmpl))
            pnvmValueDelete(tmp);
            return NULL;
        }
        codeptr++;
        pnvmIterSeekStart(o);
        while (!((codeptr[0]) == (((int)'(')))) {
            pnvmIterWrite(o, *codeptr++);
        }
        if ((cmpStringwith(name, tmp)) == 0) {

            /* success, the uplink is found */

            pnvmValueDelete(tmp);
            return uplinkStart;
        }
        codeSeekSkipVariables(codeptr);
        codeSeekSkipVariables(codeptr);
        codeSeekSkipTransitionElements(codeptr);
        assert((codeptr[0]) == (((int)')')));
        codeptr++;
        changeBlockSizeOfto(tmp, 0);
    }
    assert((codeptr[0]) == (((int)')')));
    codeptr++;
    pnvmValueDelete(tmp);
    return NULL;
}

static char * getCodeIteratorAt(int pos) {
    return &netTemplateCode[pos];
}

static CodeLength_t getCodeSize(void) {
    int i;
    PNVMTemplate const *tmpl;
    int index;
    CodeLength_t size;

    size = 0;
    index = 0;
    for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
        tmpl = netTemplateTable[index];
        if (((pnvmTemplateCodeOffset(tmpl)) + (pnvmTemplateCodeLength(tmpl))) > size) {
            size = (pnvmTemplateCodeOffset(tmpl)) + (pnvmTemplateCodeLength(tmpl));
        }
        index += 1;
        while ((i < (numberOfNetTemplates - 1)) && ((netTemplateTable[index]) == NULL)) {
            index += 1;
        }
    }
    return size;
}


/*	
    Return error flag. setError: shall be used to set it. Errors are defined in PNVMConstants >> initialize class method.
    Their text description can be obtained with strError:.
     */

Error_t getError(void) {
    return error;
}


/*	Note: This is hardcoded so it can be run from Squeak.
    The module name is used for validating a module *after*
    it is loaded to check if it does really contain the module
    we're thinking it contains. This is important! */



/*	
    Returns token depending on value kind determined by char on codePos followed by index.
    First character can be:
        S - symbol of net template
        I - integer constant
        V - in case of free variable it returns invalid token;
            otherwise variable from vars indexed by following number is returned

    :param codeptr points to the first character (C, I, V).
        After the execution it's shifted behind last character read.
     */

static PNVMToken getTokenForValueOnPosinTemplatewithVariables(char const * & codeptr, PNVMTemplate const *tmpl, PNVMTupleHead *vars) {
    unsigned short valueId;
    PNVMTupleIter ti;

    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
    /* assert(interpreterProxy->isKindOf(codeptr,'CArrayAccessor')); */
    assert(charisOneOf(codeptr[0], "SIV"));
    codeptr++;
    valueId = memLoadShort(codeptr);
    codeptr++;
    codeptr++;
    if ((codeptr[-3]) == (((int)'S'))) {

        /* template symbol */

        ti = pnvmValueIterator(((PNVMTupleHead *) (pnvmTemplateSymbols(tmpl))));
        pnvmIterSeek(ti, valueId);
        return pnvmTokenClone(pnvmIterValue(ti));
    } else {
        if ((codeptr[-3]) == (((int)'I'))) {

            /* constant integer value */

            return pnvmNewInteger(((short) valueId));
        } else {

            /* variable (free or used) */

            ti = pnvmValueIterator(vars);
            pnvmIterSeek(ti, valueId);
            return pnvmTokenClone(pnvmIterValue(ti));
        }
    }
}


void initializeModule(void) {
    initializeOMModule();
    ;
    inputBuffer = pnvmArrayNew();

    /* time of current event in unix time in milliseconds */

    outputBuffer = pnvmArrayNew();
    updateTime();
    nothingChanged = 0;
    stepCounter = 0;
}

static Error_t initializeNetInstance(PNVMNetInstHead *inst) {
    PNVMTupleHead *vars;
    PNVMTemplate *tmpl;
    PNVMArrayHead *arrtmp;
    PNVMArrayIter lastAttempt;
    char const *codeptr;
    PNVMArrayIter history;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
	LOG4CXX_DEBUG(exlog, "entering initializeNetInstance:")
    tmpl = pnvmNetInstTemplate(inst);

    /* find initialization transition */

    codeptr = getCodeIteratorAt((pnvmTemplateCodeOffset(tmpl)) + 2);
    while (!((codeptr[0]) == (((int)'(')))) {
        codeptr++;
    }
    while (!((codeptr[1]) == (((int)'I')))) {
        codeSeekSkipTransition(codeptr);
    }
    assert((codeptr[0]) == (((int)'(')));
    codeptr++;
    codeptr++;
    if (((vars = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate variables")
        return setError(ErrorNoMemory);
    }
    if (((arrtmp = pnvmArrayNew())) == NULL) {
        pnvmValueDelete(vars);
		LOG4CXX_ERROR(exlog, "failed to allocate array for history")
        return setError(ErrorNoMemory);
    }
    history = pnvmValueIterator(arrtmp);
    if (((arrtmp = pnvmArrayNew())) == NULL) {
        pnvmValueDelete(vars);
        pnvmValueDelete(pnvmIterHeaderBlock(history));
		LOG4CXX_ERROR(exlog, "failed to allocate array for lastAttempt")
        return setError(ErrorNoMemory);
    }
    lastAttempt = pnvmValueIterator(arrtmp);
    if (!(executeTransitionElementsAtonwithVariableslastAttempthistory(codeptr, inst, vars, lastAttempt, history))) {
        dieWithmsgwith(ErrorInitFailed, "failed to run initialization code for template: ", dereference(tmpl));
    }
    pnvmValueDelete(vars);
    pnvmValueDelete(pnvmIterHeaderBlock(history));
    pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
	LOG4CXX_DEBUG(exlog, "leaving initializeNetInstance:")
    return error;
}


/*	object memory contains net instances */

void initializeOMModule(void) {
    ;
    codeWithHoles = 0;
    numberOfNetTemplates = 0;
    calendarHead = NULL;
    calendarTail = NULL;
    error = ErrorSuccess;
}


/*	
    Append token to input buffer for interpreter to handle.

    :param message is a serialized token.
    
    Return true if token has been correctly parsed and enqueued.
     */

static bool inputMessage(char const *message) {
    PNVMStringHead *tmp;
    PNVMArrayIter i;
    PNVMToken parsedToken;

	LOG4CXX_INFO(iolog, "incoming: '" << message << "'")
    i = pnvmValueIterator(inputBuffer);
    pnvmIterSeekEnd(i);
    tmp = cstrToString(message);
    if (tmp == NULL) {
		LOG4CXX_ERROR(iolog, "failed to convert cstr to string")
        return 0;
    }
    parsedToken = parseToken(tmp);
    if (!(pnvmTokenIsValid(parsedToken))) {
        pnvmValueDelete(tmp);
        return 0;
    }
    pnvmIterWrite(i, parsedToken);
    pnvmValueDelete(tmp);
    pnvmTokenMakeInvalid(parsedToken);
    return 1;
}


/*	
    Step of input/output subsystem. 
    If input packet received from serial input is complete,
    it attempts to invoke input uplink of first net instance in PNVM.
    It also attempts to invoke output uplink of the main net and if it successes,
    it starts to process serial output.
     */

static Error_t inputOutput(void) {
    PNVMArrayIter ibi;
    PNVMTupleHead *params;
    PNVMArrayHead *arrtmp;
    PNVMStringHead *name;
    PNVMTupleIter pi;
    PNVMArrayIter lastAttempt;
    PNVMNetInstHead *inst;
    PNVMArrayIter history;

    assert(numberOfNetTemplates > 0);
    assert((pnvmTemplateInstances(netTemplateTable[0])) != NULL);
    assert((pnvmValueItemCount(pnvmTemplateInstances(netTemplateTable[0]))) > 0);
	LOG4CXX_DEBUG(exlog, "entering inputOutput")
    inst = pnvmTokenNetRef((dereference(pnvmTemplateInstances(netTemplateTable[0])))[0]);
    params = pnvmTupleNew();
    if (params == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate allocate tuple for parameters")
        return setError(ErrorNoMemory);
    }
    changeBlockSizeOfto(params, 1);
    pi = pnvmValueIterator(params);
    if (((arrtmp = pnvmArrayNew())) == NULL) {
        pnvmValueDelete(params);
		LOG4CXX_ERROR(exlog, "failed to allocate temporary array for last attempts")
        return setError(ErrorNoMemory);
    }
    lastAttempt = pnvmValueIterator(arrtmp);
    if (((arrtmp = pnvmArrayNew())) == NULL) {
        pnvmValueDelete(params);
        pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		LOG4CXX_ERROR(exlog, "failed to allocate temporary array for history")
        return setError(ErrorNoMemory);
    }
    history = pnvmValueIterator(arrtmp);
    name = cstrToString("input");
    if (name == NULL) {
        pnvmValueDelete(params);
        pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
        pnvmValueDelete(pnvmIterHeaderBlock(history));
        return setError(ErrorNoMemory);
    }

    /* for all items in input buffer execute input downlink */

    ibi = pnvmValueIterator(inputBuffer);
    while (!((pnvmIterAtEnd(ibi)) || (error != ErrorSuccess))) {

        /* assign the input token to the first and only parameter */

        pnvmIterSetItem(pi, pnvmIterValue(ibi));
		LOG4CXX_INFO(iolog, "inputOutput - calling input downlink on token " << pnvmIterValue(ibi))
        if (executeDownlinkonwithParameterslastAttempthistory(name, inst, params, lastAttempt, history)) {

            /* downlink successful */

            removeItemFromBlockAt(pnvmIterAsItemIterator(ibi));
            nothingChanged = 0;
        } else {

            /* check, whether called functions did clean up properly */

            unlessdieWithmsg((pnvmIterAtEnd(lastAttempt)) && (pnvmIterAtStart(lastAttempt)), ErrorExecutionUnspecified, "lastAttempts must be cleared for failed transition");
            unlessdieWithmsg((pnvmIterAtEnd(history)) && (pnvmIterAtStart(history)), ErrorExecutionUnspecified, "history must be cleared for failed transition");
            pnvmIterNext(ibi);
        }
        pnvmTokenMakeInvalid(pnvmIterValue(pi));
        pnvmIterSeekStart(history);
        changeBlockSizeOfto(pnvmIterHeaderBlock(history), 0);
        pnvmIterSeekStart(lastAttempt);
        changeBlockSizeOfto(pnvmIterHeaderBlock(lastAttempt), 0);
    }
    pnvmValueDelete(name);
    if (error != ErrorSuccess) {
        pnvmValueDelete(params);
        pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
        pnvmValueDelete(pnvmIterHeaderBlock(history));
        return error;
    }
    name = cstrToString("output");
    if (name == NULL) {
        pnvmValueDelete(params);
        pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
        pnvmValueDelete(pnvmIterHeaderBlock(history));
        return setError(ErrorNoMemory);
    }
    if (executeDownlinkonwithParameterslastAttempthistory(name, inst, params, lastAttempt, history)) {

        /* output uplink may have empty body */

        if (pnvmTokenIsValid(pnvmIterValue(pi))) {
			LOG4CXX_INFO(iolog, "inputOutput - output downlink produced a value " << pnvmIterValue(pi))
            outputValue(pnvmIterValue(pi));
            nothingChanged = 0;
        }
    } else {
        unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(lastAttempt))) == 0, ErrorExecutionUnspecified, "lastAttempts must be cleared for failed transition");
        unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(history))) == 0, ErrorExecutionUnspecified, "history must be cleared for failed transition");
    }
    pnvmValueDelete(name);
    pnvmValueDelete(pnvmIterHeaderBlock(history));
    pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
    pnvmValueDelete(params);
	LOG4CXX_DEBUG(exlog, "leaving inputOutput")
    return error;
}


/*	
    Append token to input buffer for interpreter to handle.

    :param message is a serialized token given as String.
    
    Return true if token has been correctly parsed and enqueued.
     */

bool inputString(PNVMStringHead *message) {
    PNVMArrayIter i;
    PNVMToken parsedToken;

    /* assert(interpreterProxy->isKindOf(message,'PNVMStringHead')); */
	LOG4CXX_INFO(iolog, "incoming: '" << asPlainString(message) << "'")
    i = pnvmValueIterator(inputBuffer);
    pnvmIterSeekEnd(i);
    parsedToken = parseToken(message);
    if (!(pnvmTokenIsValid(parsedToken))) {
		LOG4CXX_ERROR(iolog, "failed to parse input message")
        return 0;
    }
    pnvmIterWrite(i, parsedToken);
    pnvmTokenMakeInvalid(parsedToken);
    return 1;
}


/*	
    This should be used for the first instantiation of the first net template.
    Return instance.
    
    :param tmplId: Index of template in netTemplateTable.
     */

static PNVMNetInstHead * instantiateTemplate(int tmplId) {
    PNVMNetInstHead *inst;
    PNVMToken token;

    token = createNetInstanceFrom(netTemplateTable[tmplId]);
    inst = pnvmTokenNetRef(token);
    initializeNetInstance(inst);
    pnvmTokenMakeInvalid(token);
    return inst;
}


/*	
    This should be used for the first net template (platform).
    
    :param code is plain c-string
    
    Return template id.
     */

static int loadNetTemplate(char const *  code) {
    PNVMStringIter iter;
    PNVMTemplate *tmpl;
    PNVMStringHead *str;

    /* assert(interpreterProxy->isKindOf(code,'CArrayAccessor')); */
    /* assert(interpreterProxy->isKindOf((object(code)),'String')); */
    str = cstrToString(code);
    if (str == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate temporary string for net template code")
        return -1;
    }
    iter = pnvmValueIterator(str);
    tmpl = parseNetTemplate(iter);
    unlessdieWithmsg(tmpl != NULL, ErrorParsingTemplate, "failed to parse net template");
    if (tmpl == NULL) {
        return -1;
    }
    pnvmValueDelete(str);
    return appendNetTemplate(tmpl);
}


/*	
    Adds instance to the list of instances of template.
    Only this way it can be recognized by interpreter for its transitions to be executed.
    Interpreter iterates over all instances referenced by templates.
    
    There is one special net instance. The first instance of the first net template. It's reference
    count is set to 1 upon call to this function to ensure it's never released. Otherwise reference
    count is decreased by 1 for any other instance so that they can be garbage collected,
    when rc decreases	to zero.
        
    Return instance in PNVMToken.
     */

static PNVMToken manageNetInstance(PNVMNetInstHead *inst) {
    PNVMArrayIter i;
    PNVMTemplate *tmpl;
    PNVMToken res;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    tmpl = pnvmNetInstTemplate(inst);
    if ((pnvmTemplateInstances(tmpl)) == NULL) {
        pnvmTemplateSetInstances(tmpl, pnvmArrayNew());
        if ((pnvmTemplateInstances(tmpl)) == NULL) {
			LOG4CXX_ERROR(exlog, "failed to allocate array for template instances")
            return pnvmNewToken();
        }
    }
    i = pnvmValueIterator(pnvmTemplateInstances(tmpl));
    res = pnvmNewNetRef(inst);
    pnvmIterSeekEnd(i);
    pnvmIterWrite(i, res);
    if (!(((pnvmNetInstTemplate(inst)) == (netTemplateTable[0])) && ((pnvmValueItemCount(pnvmTemplateInstances(tmpl))) == 1))) {

        /* 
            Let's decrease reference count to ensure it's garbage collected, when template
            is the only referent..
             */

        pnvmValueUnreference(inst);
    }
    return res;
}

static uint32_t memLoadLong(char const *mem) {
    uint32_t res;

    res = ((uint32_t) (((unsigned char) (mem[3]))));
    res = (res << 8) | (((uint32_t) (((unsigned char) (mem[2])))));
    res = (res << 8) | (((uint32_t) (((unsigned char) (mem[1])))));
    res = (res << 8) | (((uint32_t) (((unsigned char) (mem[0])))));
    return res;
}


/*	
    mem is an address to memory, where 2 bytes (s1, s0) are stored;
    where s1*256 + s0 = short value
    this returnes obtained value
     */

static uint16_t memLoadShort(char const *mem) {
    uint16_t res;

    res = (mem[1]) * 256;
    res = res | (((uint16_t) (((unsigned char) (mem[0])))));
    return res;
}

static char * memStoreLongto(uint32_t value, char *mem) {
    uint32_t tmp;

    tmp = value;
    *(uint32_t *) mem = tmp;
    return mem + 4;
}


/*	
    mem is an address to memory, where 2 bytes (s1, s0) are to be stored;
    where s1*256 + s0 = value
    return position in memory after stored value
     */

static char * memStoreShortto(uint16_t value, char *mem) {
    *(uint16_t *) mem = value;
    return mem + 2;
}


/*	
    Removes first inserted item in output buffer, makes a string object
    out of it and returns it.
    
    If error occurs, nil is returned.
     */

static PNVMStringHead * outputPopMessage(void) {
    PNVMStringHead *tmp;
    PNVMArrayIter iter;
    PNVMStringIter o;

    unlessdieWithmsg(!((pnvmValueItemCount(outputBuffer)) == 0), ErrorOutputBufferEmpty, "can not pop message out of empty output buffer");
    if ((pnvmValueItemCount(outputBuffer)) == 0) {
        return NULL;
    }
    iter = pnvmValueIterator(outputBuffer);
    if (((tmp = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate temporary string for serialization of token")
        return NULL;
    }
    o = pnvmValueIterator(tmp);
    if ((serializeTokento(pnvmIterValue(iter), o)) < 0) {
		LOG4CXX_ERROR(iolog, "failed to serialize output token")
        setError(ErrorSerializationFailed);
        return NULL;
    }
    removeItemFromBlockAt(pnvmIterAsItemIterator(iter));
    return tmp;
}


/*	
    Appends token to output buffer.
    It will be sent to receiver in the next invocation of inputOutput.
     */

static void outputValue(PNVMToken const & token) {
    PNVMArrayIter o;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    o = pnvmValueIterator(outputBuffer);
    pnvmIterSeekEnd(o);
    pnvmIterWrite(o, ((PNVMToken &) token));
}

static PNVMArrayHead * parseArrayallowNetInst(PNVMStringIter & i, int allowNetInst) {
    PNVMItemIterator iter;
    PNVMArrayIter ai;
    PNVMArrayHead *res;

    /* assert(interpreterProxy->isKindOf(allowNetInst,'Boolean')); */
    if (((res = pnvmArrayNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate new array for parsed array")
        return NULL;
    }
    ai = pnvmValueIterator(res);
    iter = pnvmIterAsItemIterator(ai);
    if (!(parseCollectionstartingWithendingWithtoallowNetInst(i, '{', '}', iter, allowNetInst))) {
        pnvmValueDelete(res);
        setError(ErrorParsingCollection);
        return NULL;
    }
    return res;
}


/*	
    Parse NULL-terminated string.
    
    :param str gets shifter after NULL-terminating character
     */

static PNVMStringHead * parseCString(char const * & str) {
    PNVMStringHead *res;
    PNVMStringIter o;

    /* assert(interpreterProxy->isKindOf(str,'CObjectAccessor')); */
    if (((res = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate string for serialization of string object")
        return NULL;
    }
    o = pnvmValueIterator(res);
    while ((((int)(str[0]))) > 0) {
        pnvmIterWrite(o, *str++);
    }
    str++;
    return res;
}


/*	
    Parse transition elements of net template:
            (P <placeId>, <amount>, <value>)
        |	(G <expression>)
        |	(D <name>, <varid>, <variableids>)
        |	(A <expression>)
        |	(O <placeId>, <amount>, <value>)
    
    TODO: check range of variable ids
     */

static int parseCodeto(PNVMStringIter & i, char **outptr) {
    char *out;
    int paramCount;
    char *paramPos;
    char **outacc;
    int c;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;

    /* function ends on one of the statements inside of this loop */

    outacc = &out;
    while (1) {
        parseSkipBlanksuntilOneOf(i, "()");
        if (!((!(pnvmIterAtEnd(i))) && (((c = pnvmIterValue(i))) != ')'))) break;
        if ((parseSkipBlanksLBto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "expected '('")
            setError(ErrorParsingTransitionCode);
            return -1;
        }
        out[0] = (((int)((c = pnvmIterNext(i)))));
        out++;
        if (c == 'P') {

            /* placeid */

            if ((parsePosIntegerto(i, outacc)) < 0) {
				LOG4CXX_ERROR(parselog, "failed to parse place id")
                setError(ErrorParsingTransitionCode);
                return -1;
            }
            if (!(parseSkipBlanksComma(i))) {
				LOG4CXX_ERROR(parselog, "expected ','")
                setError(ErrorParsingTransitionCode);
                return -1;
            }
            if ((parsePosIntegerto(i, outacc)) < 0) {
				LOG4CXX_ERROR(parselog, "failed to parse number of tokens")
                setError(ErrorParsingTransitionCode);
                return -1;
            }
            if (!(parseSkipBlanksComma(i))) {
				LOG4CXX_ERROR(parselog, "expected ','")
                setError(ErrorParsingTransitionCode);
                return -1;
            }
            if ((parseValueto(i, outacc)) < 0) {
				LOG4CXX_ERROR(parselog, "failed to parse token value")
                setError(ErrorParsingTransitionCode);
                return -1;
            }
        } else {

            /* guard function */

            if (c == 'G') {
                if ((parseExpressionto(i, outacc)) < 0) {
					LOG4CXX_ERROR(parselog, "failed to parse guard expression")
                    setError(ErrorParsingTransitionCode);
                    return -1;
                }
            } else {

                /* create net instance */

                if (c == 'C') {

                    /* place id */

                    if ((parsePosIntegerto(i, outacc)) < 0) {
						LOG4CXX_ERROR(parselog, "failed to parse place id")
                        setError(ErrorParsingTransitionCode);
                        return -1;
                    }
                    if ((parseExpressionto(i, outacc)) < 0) {
						LOG4CXX_ERROR(parselog, "failed to parse instance name expression")
                        setError(ErrorParsingTransitionCode);
                        return -1;
                    }
                } else {

                    /* downlink */

                    if (c == 'D') {

                        /* name of channel */

                        if ((parseNameto(i, outacc)) < 0) {
							LOG4CXX_ERROR(parselog, "failed to parse downlink's name")
                            setError(ErrorParsingTransitionCode);
                            return -1;
                        }
                        if (!(parseSkipBlanksComma(i))) {
							LOG4CXX_ERROR(parselog, "expected ','")
                            setError(ErrorParsingTransitionCode);
                            return -1;
                        }
                        out[0] = 0;
                        out++;
                        parseSkipBlanks(i);
                        if ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) == 'V')) {
                            pnvmIterNext(i);
                        }
                        if ((parsePosIntegerto(i, outacc)) < 0) {
							LOG4CXX_ERROR(parselog, "failed to parse net instance variable id")
                            setError(ErrorParsingTransitionCode);
                            return -1;
                        }
                        paramCount = 0;
                        paramPos = out;
                        out++;
                        out++;
                        while ((parseSkipBlanksuntilOneOf(i, ",)")) && ((pnvmIterValue(i)) != ')')) {
                            pnvmIterNext(i);
                            parseSkipBlanks(i);
                            if ((parseValueto(i, outacc)) < 0) {
								LOG4CXX_ERROR(parselog, "failed to parse variable id")
                                setError(ErrorParsingTransitionCode);
                                return -1;
                            }
                            paramCount += 1;
                        }
                        memStoreShortto(paramCount, paramPos);
                        if ((pnvmIterAtEnd(i)) || ((pnvmIterValue(i)) != ')')) {
							LOG4CXX_ERROR(parselog, "expected ')'")
                            setError(ErrorParsingTransitionCode);
                            return -1;
                        }
                    } else {

                        /* action, that must not fail */

                        if (c == 'A') {
                            if ((parseExpressionto(i, outacc)) < 0) {
								LOG4CXX_ERROR(parselog, "failed to parse action's expression")
                                setError(ErrorParsingTransitionCode);
                                return -1;
                            }
                        } else {

                            /* store tokens in place */

                            if (c == 'O') {

                                /* place id */

                                if ((parsePosIntegerto(i, outacc)) < 0) {
									LOG4CXX_ERROR(parselog, "failed to parse place id")
                                    setError(ErrorParsingTransitionCode);
                                    return -1;
                                }
                                if (!(parseSkipBlanksComma(i))) {
									LOG4CXX_ERROR(parselog, "expected ','")
                                    setError(ErrorParsingTransitionCode);
                                    return -1;
                                }
                                if ((parsePosIntegerto(i, outacc)) < 0) {
									LOG4CXX_ERROR(parselog, "failed to parse number of tokens")
                                    setError(ErrorParsingTransitionCode);
                                    return -1;
                                }
                                if (!(parseSkipBlanksComma(i))) {
									LOG4CXX_ERROR(parselog, "expected ','")
                                    setError(ErrorParsingTransitionCode);
                                    return -1;
                                }
                                if ((parseValueto(i, outacc)) < 0) {
									LOG4CXX_ERROR(parselog, "failed to parse token value")
                                    setError(ErrorParsingTransitionCode);
                                    return -1;
                                }
                            } else {

                                /* schedule event, that will store tokens in place */

                                if (c == 'Y') {

                                    /* placeid */

                                    if ((parsePosIntegerto(i, outacc)) < 0) {
										LOG4CXX_ERROR(parselog, "failed to parse place id")
                                        return -1;
                                    }
                                    if (!(parseSkipBlanksComma(i))) {
										LOG4CXX_ERROR(parselog, "expected ','")
                                        setError(ErrorParsingTransitionCode);
                                        return -1;
                                    }
                                    if ((parsePosIntegerto(i, outacc)) < 0) {
										LOG4CXX_ERROR(parselog, "failed to parse number of tokens")
                                        setError(ErrorParsingTransitionCode);
                                        return -1;
                                    }
                                    if (!(parseSkipBlanksComma(i))) {
										LOG4CXX_ERROR(parselog, "expected ','")
                                        setError(ErrorParsingTransitionCode);
                                        return -1;
                                    }
                                    if ((parseValueto(i, outacc)) < 0) {
										LOG4CXX_ERROR(parselog, "failed to parse token value")
                                        setError(ErrorParsingTransitionCode);
                                        return -1;
                                    }
                                    if (!(parseSkipBlanksComma(i))) {
										LOG4CXX_ERROR(parselog, "expected ','")
                                        setError(ErrorParsingTransitionCode);
                                        return -1;
                                    }
                                    if ((parseLongIntegerto(i, outacc)) < 0) {
										LOG4CXX_ERROR(parselog, "failed to parse time")
                                        setError(ErrorParsingTransitionCode);
                                        return -1;
                                    }
                                } else {

                                    /* unexpected type of symbol */

                                    setError(ErrorParsingTransitionCode);
                                    return -1;
                                }
                            }
                        }
                    }
                }
            }
        }
        if ((parseSkipBlanksRBto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "expected ')'")
            setError(ErrorParsingTransitionCode);
            return -1;
        }
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static int parseCollectionstartingWithendingWithtoallowNetInst(PNVMStringIter & i, int start, int end, PNVMItemIterator & o, int allowNetInst) {
    PNVMToken symbol;
    int expectItem;
    int c;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(start,'Character')); */
    /* assert(interpreterProxy->isKindOf(end,'Character')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(allowNetInst,'Boolean')); */
    if (!(parseSkipBlanksexpecting(i, start))) {
		LOG4CXX_ERROR(parselog, "expected " << start)
        setError(ErrorParsingCollection);
        return 0;
    }
    parseSkipBlanks(i);
    expectItem = 0;
    while ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) != end)) {
        symbol = parseSymbolallowNetInst(i, allowNetInst);
        if (!(pnvmTokenIsValid(symbol))) {
			LOG4CXX_ERROR(parselog, "failed to parse symbol")
            setError(ErrorParsingCollection);
            return 0;
        }
        writeValueItemat(makePointer(symbol), o);
        pnvmTokenMakeInvalid(symbol);
        parseSkipBlanks(i);
        if (!((charisOneOf(pnvmIterValue(i), ",/")) || ((pnvmIterValue(i)) == end))) {
			LOG4CXX_ERROR(parselog, "expected one of separators")
            setError(ErrorParsingCollection);
            return 0;
        }
        c = pnvmIterValue(i);
        if ((c == ',') || (c == '/')) {
            pnvmIterNext(i);
            parseSkipBlanks(i);
            expectItem = 1;
        } else {
            expectItem = 0;
        }
    }
    if (expectItem) {
		LOG4CXX_ERROR(parselog, "expected item")
        setError(ErrorParsingCollection);
        return 0;
    }
    if ((pnvmIterAtEnd(i)) || ((pnvmIterValue(i)) != end)) {
		LOG4CXX_ERROR(parselog, "expected " << end)
        setError(ErrorParsingCollection);
        return 0;
    }
    pnvmIterNext(i);
    return 1;
}


/*	
    Check, whether character on position 'i' matches expected 'character', and place it into output
    with 'outptr' iterator.
     */

static int parseExpCharfromto(int character, PNVMStringIter & i, char **outptr) {
    char *out;

    if (!((pnvmIterNext(i)) == character)) {
        return -1;
    }
    out = *outptr;
    out[0] = (((int)character));
    out++;
    *outptr = out;
    return 1;
}


/*	
    Parse expression of transition elements G or A.
    It expects input iterator 'i' to point at opening bracket of expression.
    On function exit, this iterator will point after the closing bracket.
    
    :param outptr: points to object memory, where the parsed result will be stored
     */

static int parseExpressionto(PNVMStringIter & i, char **outptr) {
    int j;
    char *out;
    int numparams;
    char **outacc;
    int c;

    out = *outptr;
    outacc = &out;
    if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected '('")
        setError(ErrorParsingExpression);
        return -1;
    }
    parseSkipBlanks(i);
    numparams = -1;
    if ((((c = pnvmIterValue(i))) == 'I') || ((c == 'S') || (c == 'V'))) {
        if ((parseValueto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "failed to parse variable")
            setError(ErrorParsingExpression);
            return -1;
        }
        numparams = 0;
    } else {
        pnvmIterNext(i);
        out[0] = (((int)c));
        out++;
        if (charisOneOf(c, "=<>&|^o:,+-*/%#a")) {
            numparams = 2;
        } else {

            /* parse unary operators */

            if (((c == '!') || ((c == 'p') || ((c == 'h') || ((c == 't') || (c == 'u'))))) || ((c == 'l') || ((c == 'c') || ((c == 's') || ((c == 'i') || (c == 'n')))))) {

                /* check whether it can be multicharacter operator */

                if (charisOneOf(c, "in")) {
                    if (((c == 'i') && ((charisOneOf(pnvmIterValue(i), "isatnv(")) || (charIsBlank(pnvmIterValue(i))))) || ((c == 'n') && ((charisOneOf(pnvmIterValue(i), "sat(")) || (charIsBlank(pnvmIterValue(i)))))) {

                        /* check, whether multicharacter operator is parameter-less */
                        /* (c = $t and: [i pnvmIterValue = $i]) ifTrue: [numparams := 0]. */
                        /* store one more character for 2-character operators */

                        if (((c == 'i') && (charisOneOf(pnvmIterValue(i), "isatnv"))) || ((c == 'n') && (charisOneOf(pnvmIterValue(i), "sat")))) {
                            out[0] = (((int)(pnvmIterNext(i))));
                            out++;
                            if (c == 'n') {
                                numparams = 0;
                            }
                        }
                    } else {
						LOG4CXX_ERROR(parselog, "unknown multicharacter operator")
                        setError(ErrorParsingExpression);
                        return -1;
                    }
                }
                if (numparams == -1) {
                    numparams = 1;
                }
            } else {

                /* parse parameter-less operators */

                if (c == 'd') {

                    /* dump */

                    numparams = 0;
                } else {

                    /* no matching operator found */

					LOG4CXX_ERROR(parselog, "not supported operator '" << c << "' found")
                    setError(ErrorParsingExpression);
                    return -1;
                }
            }
        }
    }
    assert(numparams >= 0);
    for (j = 1; j <= numparams; j += 1) {
        if ((parseExpressionto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "failed to parse nested argument number " << j)
            setError(ErrorParsingExpression);
            return -1;
        }
    }
    if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected ')'")
        setError(ErrorParsingExpression);
        return -1;
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static int parseInitto(PNVMStringIter & i, char **outptr) {
    char *out;
    int res;
    char **outacc;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    outacc = &out;
    if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected (")
        setError(ErrorParsingInit);
        return -1;
    }
    if ((parseExpCharfromto('I', i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected 'I'")
        setError(ErrorParsingInit);
        return -1;
    }
    if (((res = parseCodeto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse code")
        setError(ErrorParsingInit);
        return -1;
    }
    if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected )")
        setError(ErrorParsingInit);
        return -1;
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static int parseIntegerto(PNVMStringIter & i, char **outptr) {
    unsigned short tmp;
    char *out;
    PNVMToken token;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    token = parseNumber(i);
    if (!(pnvmTokenIsValid(token))) {
        return -1;
    }
    tmp = ((unsigned short) (pnvmTokenInteger(token)));
    ;
    out[0] = (tmp % 256);
    out++;
    out[0] = (((unsigned) tmp) >> 8);
    out++;
    parseStoreOffsettoPtr(out, outptr);
    return 2;
}

static int parseLongIntegerto(PNVMStringIter & i, char **outptr) {
    int negative;
    char *out;
    int c;
    long value;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    parseSkipBlanks(i);
    if (pnvmIterAtEnd(i)) {
		LOG4CXX_ERROR(parselog, "empty string")
        return -1;
    }
    negative = 0;
    if (((c = pnvmIterValue(i))) == '-') {
        negative = 1;
        pnvmIterNext(i);
        c = pnvmIterValue(i);
    }
    if ((pnvmIterAtEnd(i)) || ((c < '0') || (c > '9'))) {
		LOG4CXX_ERROR(parselog, "expected digit 0-9")
        return -1;
    }
    value = (((int)c)) - (((int)'0'));
    pnvmIterNext(i);
    if ((value == 0) && ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9')))) {
		LOG4CXX_ERROR(parselog, "junk after first 0")
        return -1;
    }
    while ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9'))) {
        value = (value * 10) + ((((int)c)) - (((int)'0')));
        pnvmIterNext(i);
    }
    if ((!(pnvmIterAtEnd(i))) && ((!(charIsBlank(c))) && (!(charisOneOf(c, "(,/)]}"))))) {
		LOG4CXX_ERROR(parselog, "invalid number terminator: " << c)
        return -1;
    }
    if (negative) {
        value = 0 - value;
    }
    memStoreLongto(value, out);
    parseStoreOffsettoPtr(out + 4, outptr);
    return 4;
}

static PNVMStringHead * parseName(PNVMStringIter & i) {
    PNVMStringHead *res;
    PNVMStringIter o;
    char c;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    parseSkipBlanks(i);
    if (pnvmIterAtEnd(i)) {
		LOG4CXX_ERROR(parselog, "string empty")
        return NULL;
    }
    c = pnvmIterNext(i);
    if (!(isalpha(c))) {
		LOG4CXX_ERROR(parselog, "expected alpha, not: '" << c << "'")
        return NULL;
    }
    if (((res = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate string for name")
        return NULL;
    }
    o = pnvmValueIterator(res);
    pnvmIterWrite(o, c);
    while ((!(pnvmIterAtEnd(i))) && ((isalnum(c = pnvmIterValue(i))) || (c == '_'))) {
        pnvmIterWrite(o, c);
        pnvmIterNext(i);
        c = pnvmIterValue(i);
    }
    if (!((charIsBlank(c)) || (charisOneOf(c, "[/(),")))) {
        pnvmValueDelete(res);
		LOG4CXX_ERROR(parselog, "expected blank or one of separators not: '" << c << "'")
        return NULL;
    }
    return res;
}


/*	
    Parse identifier in Net template definition or in net instance code.
    Identifier matches expression:
        [a-zA-Z][a-zA-Z0-9_]*
    It expects either space, parameter separator, closing or opening bracket after
    the identifier.
     */

static int parseNameto(PNVMStringIter & i, char **outptr) {
    char *out;
    int c;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    parseSkipBlanks(i);
    if (pnvmIterAtEnd(i)) {
		LOG4CXX_ERROR(parselog, "string empty")
        return -1;
    }
    c = pnvmIterNext(i);
    if (!(isalpha(c))) {
		LOG4CXX_ERROR(parselog, "expected alpha")
        return -1;
    }
    out[0] = (((int)c));
    out++;
    while ((!(pnvmIterAtEnd(i))) && ((isalnum(c = pnvmIterValue(i))) || (c == '_'))) {
        out[0] = (((int)c));
        out++;
        pnvmIterNext(i);
        c = pnvmIterValue(i);
    }
    if (!((charIsBlank(c)) || (charisOneOf(c, "/(),")))) {
		LOG4CXX_ERROR(parselog, "expected blank or separator, not: '" << c << "'")
        return -1;
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static PNVMTupleHead * parseNames(PNVMStringIter & i) {
    PNVMTupleHead *res;
    PNVMTupleIter o;
    PNVMStringHead *name;
    PNVMToken token;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    if (!(parseSkipBlanksexpecting(i, '('))) {
		LOG4CXX_ERROR(parselog, "expecting (")
        setError(ErrorParsingNames);
        return NULL;
    }
    parseSkipBlanks(i);
    if (((res = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple to store names")
        return NULL;
    }
    o = pnvmValueIterator(res);
    while (!((pnvmIterValue(i)) == ')')) {
        name = parseName(i);
        if (name == NULL) {
            pnvmValueDelete(res);
			LOG4CXX_ERROR(parselog, "failed to parse name")
            setError(ErrorParsingNames);
            return NULL;
        }
        token = pnvmNewPointer(name);
        pnvmIterWrite(o, token);
        pnvmTokenMakeInvalid(token);
        if (!(parseSkipBlanksuntilOneOf(i, "/),"))) {
            pnvmValueDelete(res);
			LOG4CXX_ERROR(parselog, "expected one of separators")
            setError(ErrorParsingNames);
            return NULL;
        }
        if (((pnvmIterValue(i)) == '/') || ((pnvmIterValue(i)) == ',')) {
            pnvmIterNext(i);
            parseSkipBlanks(i);
        }
    }
    if (!((pnvmIterNext(i)) == ')')) {
        pnvmValueDelete(res);
		LOG4CXX_ERROR(parselog, "expecting ')'")
        setError(ErrorParsingNames);
        return NULL;
    }
    return res;
}


/*	
    Parse sequence of identifiers to object memory.
    Sequence starts with $( and ends with $). Identifiers are separated with $, or $/.
     */

static int parseNamesto(PNVMStringIter & i, char **outptr) {
    char *out;
    char **outacc;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    outacc = &out;
    if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expecting (")
        setError(ErrorParsingNames);
        return -1;
    }
    parseSkipBlanks(i);
    while (!((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) == ')'))) {
        if ((parseNameto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "failed to parse name")
            setError(ErrorParsingNames);
            return -1;
        }
        if (!(parseSkipBlanksuntilOneOf(i, "/),"))) {
			LOG4CXX_ERROR(parselog, "expected one of separators")
            setError(ErrorParsingNames);
            return -1;
        }
        if (((pnvmIterValue(i)) == '/') || ((pnvmIterValue(i)) == ',')) {
            pnvmIterNext(i);
            parseSkipBlanks(i);
            out[0] = (((int)','));
            out++;
        }
    }
    if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expecting ')'")
        setError(ErrorParsingNames);
        return -1;
    }
    return parseStoreOffsettoPtr(out, outptr);
}


/*	
    parse token value in net instance string
    it can be:
        * number with or without I prefix
        * symbol of net template given as S <index>
        * any value, that can occur as symbol in net template code
        
    Returns token.
     */

static PNVMToken parseNetInstValueofTemplate(PNVMStringIter & i, PNVMTemplate const *tmpl) {
    PNVMTupleIter si;
    PNVMToken index;
    PNVMToken res;
    PNVMTupleHead const *symbols;
    int c;

    res = pnvmNewToken();
    parseSkipBlanks(i);
    c = pnvmIterValue(i);
    if (c == 'I') {
        pnvmIterNext(i);
        res = parseNumber(i);
        if (!(pnvmTokenIsValid(res))) {
            setError(ErrorParsingNetInstValue);
        }
    } else {
        if (c == 'S') {
            pnvmIterNext(i);
            if (!((pnvmTokenIsValid(index = parseNumber(i))) && ((pnvmTokenInteger(index)) >= 0))) {
				LOG4CXX_ERROR(parselog, "failed to parse positive integer")
                setError(ErrorParsingNetInstValue);
                return res;
            }
            symbols = pnvmTemplateSymbols(tmpl);
            if ((((unsigned int) (pnvmTokenInteger(index)))) >= (pnvmValueItemCount(pnvmTemplateSymbols(tmpl)))) {
				LOG4CXX_ERROR(parselog, "no such symbol with index=" << pnvmTokenInteger(index) << " in template: " << tmpl)
                setError(ErrorParsingNetInstValue);
                return res;
            }
            si = pnvmValueIterator(((PNVMTupleHead *) symbols));
            pnvmIterSeek(si, pnvmTokenInteger(index));
            res = pnvmIterValue(si);
        } else {
            res = parseSymbolallowNetInst(i, 1);
        }
    }
    return res;
}


/*	
    Format of net instance:
        (n net_template_name (p place_name (t <number> <symbol>) (t <number> <symbol>)) )
    
    Places can be serialized in arbitrary order. They only need to have name matching
    one in net template.
    
    :param i: string iterator with serialized net instance. It is shifted past the closing bracket of
        net instance code.

    Return instance of PNVMNetInstHead.
     */

static PNVMNetInstHead * parseNetInstance(PNVMStringIter & i) {
    PNVMPlaceHead *place;
    PNVMTemplate *tmpl;
    PNVMNetInstIter o;
    PNVMStringHead *name;
    PNVMNetInstHead *inst;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    if (!(parseSkipBlanksexpecting(i, '('))) {
		LOG4CXX_ERROR(parselog, "expected '('")
        setError(ErrorParsingNetInst);
        return NULL;
    }
    if ((pnvmIterAtEnd(i)) || ((pnvmIterNext(i)) != 'n')) {
		LOG4CXX_ERROR(parselog, "expected 'n'")
        setError(ErrorParsingNetInst);
        return NULL;
    }
    if (((name = parseName(i))) == NULL) {
		LOG4CXX_ERROR(parselog, "failed to parse name")
        setError(ErrorParsingNetInst);
        return NULL;
    }
    tmpl = findNetTemplate(name);
    pnvmValueDelete(name);
    if (tmpl == NULL) {
		LOG4CXX_ERROR(parselog, "no such net template: " << asPlainString(name))
        setError(ErrorNoSuchTemplate);
        return NULL;
    }
    parseSkipBlanks(i);
    if (((inst = pnvmNetInstNew(tmpl))) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate new net instance")
        return NULL;
    }
    changeBlockSizeOfto(inst, pnvmTemplatePlaceCount(tmpl));
    if (error != ErrorSuccess) {
        pnvmValueDelete(inst);
		LOG4CXX_ERROR(exlog, "failed to resize net instance")
        return NULL;
    }
    o = pnvmValueIterator(inst);
    parseSkipBlanks(i);
    while (!((pnvmIterValue(i)) == ')')) {
        if ((parsePlaceofTemplateto(i, tmpl, o)) == NULL) {
            pnvmValueDelete(inst);
			LOG4CXX_ERROR(parselog, "failed to parse net instance")
            setError(ErrorParsingNetInst);
            return NULL;
        }
        parseSkipBlanks(i);
    }
    pnvmIterSeekStart(o);
    while (!(pnvmIterAtEnd(o))) {
        if ((pnvmIterValue(o)) == NULL) {
            if (((place = pnvmPlaceNew())) == NULL) {
                pnvmValueDelete(inst);
				LOG4CXX_ERROR(exlog, "failed to allocate new place")
                return NULL;
            }
            pnvmIterSetItem(o, place);
        }
        pnvmIterNext(o);
    }
    pnvmIterNext(i);
    return inst;
}

static PNVMTemplate * parseNetTemplate(PNVMStringIter & i) {
    char *out;
    int parsed;
    PNVMTemplate *tmpl;
    int codeOffset;
    PNVMStringHead *name;
    PNVMTupleHead *symbols;
    PNVMTupleHead *places;
    int transitions;
    char **outacc;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    codeOffset = getCodeSize();
    out = getCodeIteratorAt(codeOffset);
    outacc = &out;
    if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected '('")
        setError(ErrorParsingTemplate);
        return NULL;
    }
    if ((parseExpCharfromto('N', i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected 'N'")
        setError(ErrorParsingTemplate);
        return NULL;
    }
    if (((name = parseName(i))) == NULL) {
		LOG4CXX_ERROR(parselog, "failed to parse name")
        setError(ErrorParsingTemplate);
        return NULL;
    }
    if (((symbols = parseSymbols(i))) == NULL) {
        pnvmValueDelete(name);
		LOG4CXX_ERROR(parselog, "failed to parse symbols")
        setError(ErrorParsingTemplateSymbols);
        return NULL;
    }
    if (((places = parseNames(i))) == NULL) {
        pnvmValueDelete(name);
        pnvmValueDelete(symbols);
		LOG4CXX_ERROR(parselog, "failed to parse names")
        setError(ErrorParsingNames);
        return NULL;
    }
    if (((parsed = parseUplinksto(i, outacc))) < 0) {
        pnvmValueDelete(name);
        pnvmValueDelete(places);
        pnvmValueDelete(symbols);
		LOG4CXX_ERROR(parselog, "failed to parse uplinks")
        setError(ErrorParsingUplinks);
        return NULL;
    }
    if (((parsed = parseInitto(i, outacc))) < 0) {
        pnvmValueDelete(name);
        pnvmValueDelete(places);
        pnvmValueDelete(symbols);
		LOG4CXX_ERROR(parselog, "failed to parse init transition")
        setError(ErrorParsingInit);
        return NULL;
    }
    transitions = codeOffset + (*outacc - getCodeIteratorAt(codeOffset));
    if (((parsed = parseTransitionsto(i, outacc))) < 0) {
        pnvmValueDelete(name);
        pnvmValueDelete(places);
        pnvmValueDelete(symbols);
		LOG4CXX_ERROR(parselog, "failed to parse transitions")
        setError(ErrorParsingTransitions);
        return NULL;
    }
    if ((parseSkipBlanksRBto(i, outacc)) < 0) {
        pnvmValueDelete(name);
        pnvmValueDelete(places);
        pnvmValueDelete(symbols);
		LOG4CXX_ERROR(parselog, "expected ')' at the end of net tmpl code")
        setError(ErrorParsingTemplate);
        return NULL;
    }
    if (((tmpl = pnvmTemplateNew())) == NULL) {
        pnvmValueDelete(name);
        pnvmValueDelete(places);
        pnvmValueDelete(symbols);
		LOG4CXX_ERROR(exlog, "failed to allocate net template")
        return NULL;
    }
    pnvmTemplateSetPlaceCount(tmpl, pnvmValueItemCount(places));
    pnvmTemplateSetName(tmpl, name);
    pnvmTemplateSetPlaces(tmpl, places);
    pnvmTemplateSetSymbols(tmpl, symbols);
    pnvmTemplateSetCodeOffset(tmpl, codeOffset);
    pnvmTemplateSetCodeLength(tmpl, *outacc - getCodeIteratorAt(codeOffset));
    pnvmTemplateSetTransitions(tmpl, transitions);
    return tmpl;
}

static PNVMToken parseNumber(PNVMStringIter & i) {
    int negative;
    PNVMToken res;
    int c;
    int value;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    res = pnvmNewToken();
    parseSkipBlanks(i);
    if (pnvmIterAtEnd(i)) {
		LOG4CXX_ERROR(parselog, "empty string")
        return res;
    }
    negative = 0;
    if (((c = pnvmIterValue(i))) == '-') {
        negative = 1;
        pnvmIterNext(i);
        c = pnvmIterValue(i);
    }
    if ((pnvmIterAtEnd(i)) || ((c < '0') || (c > '9'))) {
		LOG4CXX_ERROR(parselog, "expected digit 0-9")
        return res;
    }
    value = (((int)c)) - (((int)'0'));
    pnvmIterNext(i);
    if ((value == 0) && ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9')))) {
		LOG4CXX_ERROR(parselog, "junk after first 0")
        return res;
    }
    while ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) >= '0') && (c <= '9'))) {
        value = (value * 10) + ((((int)c)) - (((int)'0')));
        pnvmIterNext(i);
    }
    if ((!(pnvmIterAtEnd(i))) && ((!(charIsBlank(c))) && (!(charisOneOf(c, "(,/)]}"))))) {
		LOG4CXX_ERROR(parselog, "invalid number terminator: " << c)
        return res;
    }
    if (negative) {
        value = 0 - value;
    }
    pnvmTokenSetInteger(res, value);
    return res;
}


/*	
    Parse single place of serialized net instance.
    It's format is following:
        (p <name> <token0> <token1> ... )
    
    :param i: string iterator with serialized net instance.
    :param netInstIter: Iterator of net instance, which will acquire parsed place.
        Iterator will be seeked to correct position determined by index of place name in
        template places.
    
    Return created place.
     */

static PNVMPlaceHead * parsePlaceofTemplateto(PNVMStringIter & i, PNVMTemplate const *tmpl, PNVMNetInstIter & netInstIter) {
    PNVMToken tmp;
    PNVMPlaceHead *place;
    int index;
    PNVMPlaceIter o;
    PNVMStringHead *name;
    PNVMPlaceItem plcItem;
    char c;
    int number;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    /* assert(interpreterProxy->isKindOf(netInstIter,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(netInstIter)),'PNVMNetInstHead')); */
    c = 0;
    if (!(parseSkipBlanksexpecting(i, '('))) {
		LOG4CXX_ERROR(parselog, "expected '('")
        setError(ErrorParsingPlace);
        return NULL;
    }
    if ((pnvmIterAtEnd(i)) || ((pnvmIterNext(i)) != 'p')) {
		LOG4CXX_ERROR(parselog, "expected 'p'")
        setError(ErrorParsingPlace);
        return NULL;
    }
    if (((name = parseName(i))) == NULL) {
		LOG4CXX_ERROR(parselog, "failed to parse name of place")
        setError(ErrorParsingPlace);
        return NULL;
    }
    index = placeIndexin(name, tmpl);
    if (index < 0) {
        pnvmValueDelete(name);
		LOG4CXX_ERROR(parselog, "failed to find place " << asPlainString(name) << " in template " << dereference(tmpl))
        setError(ErrorNoSuchPlace);
        return NULL;
    }
    pnvmValueDelete(name);
    if (!(parseSkipBlanksuntilOneOf(i, "()"))) {
		LOG4CXX_ERROR(parselog, "expected '(' or ')'")
        setError(ErrorParsingPlace);
        return NULL;
    }
    if (((place = pnvmPlaceNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate new place")
        return NULL;
    }
    o = pnvmValueIterator(place);
    while ((!(pnvmIterAtEnd(i))) && (((c = pnvmIterNext(i))) != ')')) {
        if (!(c == '(')) {
			LOG4CXX_ERROR(parselog, "expected '('")
            setError(ErrorParsingPlace);
            return NULL;
        }
        if (!(((c = pnvmIterNext(i))) == 't')) {
			LOG4CXX_ERROR(parselog, "expected 't'")
            setError(ErrorParsingPlace);
            return NULL;
        }
        if (!(pnvmTokenIsValid(tmp = parseNumber(i)))) {
            pnvmValueDelete(place);
			LOG4CXX_ERROR(parselog, "failed to parse number of tokens of place")
            setError(ErrorParsingPlace);
            return NULL;
        }
        number = pnvmTokenInteger(tmp);
        if (!(parseSkipBlanksComma(i))) {
            pnvmValueDelete(place);
			LOG4CXX_ERROR(parselog, "expected ','")
            setError(ErrorParsingPlace);
            return NULL;
        }
        if (!(pnvmTokenIsValid(tmp = parseNetInstValueofTemplate(i, tmpl)))) {
            pnvmValueDelete(place);
			LOG4CXX_ERROR(parselog, "failed to parse token value of place")
            setError(ErrorParsingPlace);
            return NULL;
        }
        if (!(parseSkipBlanksexpecting(i, ')'))) {
            pnvmValueDelete(place);
			LOG4CXX_ERROR(parselog, "expected ')'")
            setError(ErrorParsingPlace);
            return NULL;
        }
        if (!(parseSkipBlanksuntilOneOf(i, "()"))) {
            pnvmValueDelete(place);
			LOG4CXX_ERROR(parselog, "expected one of '()'")
            setError(ErrorParsingPlace);
            return NULL;
        }
        plcItem = pnvmPlaceItemNewof(number, tmp);
        pnvmTokenMakeInvalid(tmp);
        pnvmIterWrite(o, plcItem);
        pnvmPlaceItemMakeInvalid(plcItem);
    }
    pnvmIterSeek(netInstIter, index);
    if (!((pnvmIterValue(netInstIter)) == NULL)) {
        pnvmValueDelete(pnvmIterValue(netInstIter));
    }
    pnvmIterSetItem(netInstIter, place);
    if (!(c == ')')) {
        pnvmValueDelete(place);
		LOG4CXX_ERROR(parselog, "expected ')'")
        setError(ErrorParsingPlace);
        return NULL;
    }
    return place;
}

static int parsePosIntegerto(PNVMStringIter & i, char **outptr) {
    char *out;
    PNVMToken token;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    token = parseNumber(i);
    if (!(pnvmTokenIsValid(token))) {
        return -1;
    }
    if ((pnvmTokenInteger(token)) < 0) {
		LOG4CXX_ERROR(parselog, "value is negative")
        return -1;
    }
    out[0] = ((((unsigned short) (pnvmTokenInteger(token)))) % 256);
    out++;
    out[0] = (((int) (((unsigned short) (pnvmTokenInteger(token)))) >> 8));
    out++;
    parseStoreOffsettoPtr(out, outptr);
    return 2;
}

static void parseSkipBlanks(PNVMStringIter & iterator) {
    /* assert(interpreterProxy->isKindOf(iterator,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(iterator)),'PNVMStringHead')); */
    while ((!(pnvmIterAtEnd(iterator))) && (charIsBlank(pnvmIterValue(iterator)))) {
        pnvmIterNext(iterator);
    }
}

static int parseSkipBlanksexpecting(PNVMStringIter & iterator, int character) {
    parseSkipBlanks(iterator);
    if (pnvmIterAtEnd(iterator)) {
        return 0;
    }
    if (!((pnvmIterValue(iterator)) == character)) {
        return 0;
    }
    pnvmIterNext(iterator);
    return 1;
}

static int parseSkipBlanksuntil(PNVMStringIter & iterator, int character) {
    parseSkipBlanks(iterator);
    return (pnvmIterValue(iterator)) == character;
}

static int parseSkipBlanksuntilOneOf(PNVMStringIter & iterator, char const *string) {
    /* assert(interpreterProxy->isKindOf(string,'String')); */
    parseSkipBlanks(iterator);
    if (pnvmIterAtEnd(iterator)) {
        return 0;
    }
    return strchr(string, pnvmIterValue(iterator)) != NULL;
}


/*	
    Skip blanks up to left bracket, which is stored to output buffer.
     */

static int parseSkipBlanksComma(PNVMStringIter & i) {
    if (!(parseSkipBlanksuntil(i, ','))) {
        return 0;
    }
    pnvmIterNext(i);
    return 1;
}


/*	
    Skip blanks up to left bracket, which is stored to output buffer.
     */

static int parseSkipBlanksLBto(PNVMStringIter & i, char **outptr) {
    parseSkipBlanks(i);
    return parseExpCharfromto('(', i, outptr);
}


/*	
    Skip blanks up to left bracket, which is stored to output buffer.
     */

static int parseSkipBlanksRBto(PNVMStringIter & i, char **outptr) {
    parseSkipBlanks(i);
    return parseExpCharfromto(')', i, outptr);
}


/*	
    This is for functions taking reference to pointer as argument and want
    to change it.
     */

static int parseStoreOffsettoPtr(char *off, char **ptr) {
    int ret;

    ret = -1;
    if (!(ptr == NULL)) {
        ret = off - (*ptr);
        *ptr = off;
    }
    return ret;
}

static PNVMStringHead * parseString(PNVMStringIter & i) {
    PNVMStringHead *res;
    PNVMStringIter o;
    char c;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    if (!(parseSkipBlanksexpecting(i, '"'))) {
		LOG4CXX_ERROR(parselog, "expected double quotes")
        setError(ErrorParsingString);
        return NULL;
    }
    if (((res = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate string for parsed string")
        return res;
    }
    o = pnvmValueIterator(res);
    while ((!(pnvmIterAtEnd(i))) && (((c = pnvmIterValue(i))) != '"')) {
        while ((!(pnvmIterAtEnd(i))) && ((((c = pnvmIterValue(i))) != '"') && (c != '\\'))) {
            pnvmIterWrite(o, c);
            pnvmIterNext(i);
        }
        if (c == '\\') {
            pnvmIterNext(i);
            if (pnvmIterAtEnd(i)) {
				LOG4CXX_ERROR(parselog, "unexpected EOS")
                pnvmValueDelete(res);
                setError(ErrorParsingString);
                return NULL;
            }
            c = pnvmIterNext(i);
            if (c == 'n') {
                c = '\n';
            } else {
                if (c == 't') {
                    c = '\t';
                } else {
                    if (c == 'r') {
                        c = '\r';
                    }
                }
            }
            pnvmIterWrite(o, c);
        }
    }
    if ((pnvmIterAtEnd(i)) || ((pnvmIterValue(i)) != '"')) {
		LOG4CXX_ERROR(parselog, "expected double quotes")
        pnvmValueDelete(res);
        setError(ErrorParsingString);
        return NULL;
    }
    pnvmIterNext(i);
    return res;
}


/*	
    Parse serialized symbol.
    
    :param i: Iterator to String object containing one of serialized symbols:
        integer, string, tuple, array, net instance
    :param allowNetInst: Boolean saying, whether to parse net instance.
        Net instances are not allowed in net template symbols, but they may
        occur in serialized net instance.
     */

static PNVMToken parseSymbolallowNetInst(PNVMStringIter & i, int allowNetInst) {
    PNVMHeaderBlock *tmp;
    PNVMNetInstHead *inst;
    int c;
    PNVMToken token;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(allowNetInst,'Boolean')); */
    parseSkipBlanks(i);
    token = pnvmNewToken();
    c = pnvmIterValue(i);
    if ((c == '-') || (isdigit(c))) {
        token = parseNumber(i);
        if (!(pnvmTokenIsValid(token))) {
			LOG4CXX_ERROR(parselog, "failed to parse number")
        }
    } else {
        if ((c == '(') && (allowNetInst)) {

            /* 
        If instance is embedded in place of another instance being parsed,
        we need to manage the embedded instance first. If parsing of
        outer instance fails, embedded will be unmanaged and released
        upon deletion of outer one.
         */

            if (((inst = parseNetInstance(i))) == NULL) {
				LOG4CXX_ERROR(exlog, "failed to parse embedded net instance")
                return token;
            }
            pnvmTokenAssign(token, manageNetInstance(inst));
            if (!(pnvmTokenIsValid(token))) {
				LOG4CXX_ERROR(exlog, "failed to manage net instance " << dereference(inst))
                return token;
            }
        } else {
            if (c == '"') {
                if (((tmp = parseString(i))) == NULL) {
					LOG4CXX_ERROR(parselog, "failed to parse string")
                } else {
                    pnvmTokenSetPointer(token, tmp);
                }
            } else {
                if (c == '[') {
                    if (((tmp = parseTupleallowNetInst(i, allowNetInst))) == NULL) {
						LOG4CXX_ERROR(parselog, "failed to parse tuple")
                    } else {
                        pnvmTokenSetPointer(token, tmp);
                    }
                } else {
                    if (c == '{') {
                        if (((tmp = parseArrayallowNetInst(i, allowNetInst))) == NULL) {
							LOG4CXX_ERROR(parselog, "failed to parse tuple")
                        } else {
                            pnvmTokenSetPointer(token, tmp);
                        }
                    } else {
						LOG4CXX_ERROR(parselog, "invalid symbol")
                    }
                }
            }
        }
    }
    if (!(pnvmTokenIsValid(token))) {
        setError(ErrorParsingSymbol);
    }
    return token;
}

static PNVMTupleHead * parseSymbols(PNVMStringIter & i) {
    PNVMItemIterator iter;
    PNVMTupleHead *res;
    PNVMTupleIter ti;

    if (((res = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple for symbols")
        return NULL;
    }
    ti = pnvmValueIterator(res);
    iter = pnvmIterAsItemIterator(ti);
    if (!(parseCollectionstartingWithendingWithtoallowNetInst(i, '(', ')', iter, 0))) {
        pnvmValueDelete(res);
        setError(ErrorParsingTemplateSymbols);
        return NULL;
    }
    return res;
}


/*	
    Parse serialized token. This includes numbers, strings, tuples, arrays and net instances.
    Net templates should be sent as embedded strings.
     */

static PNVMToken parseToken(PNVMStringHead *str) {
    PNVMStringIter iter;
    PNVMToken res;

    /* assert(interpreterProxy->isKindOf(str,'PNVMStringHead')); */
	LOG4CXX_DEBUG(exlog, "entering parseToken:")
    if ((pnvmValueItemCount(str)) < 1) {
		LOG4CXX_ERROR(parselog, "invalid token received")
        setError(ErrorParsingToken);
        return pnvmNewToken();
    }
    iter = pnvmValueIterator(str);
    res = parseSymbolallowNetInst(iter, 1);
	LOG4CXX_DEBUG(exlog, "leaving parseToken: with result=" << res)
    if (!(pnvmTokenIsValid(res))) {
        setError(ErrorParsingToken);
    }
    return res;
}

static int parseTransitionto(PNVMStringIter & i, char **outptr) {
    char *out;
    int res;
    char **outacc;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    outacc = &out;
    if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected (")
        setError(ErrorParsingTransition);
        return -1;
    }
    if ((parseExpCharfromto('T', i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected 'T'")
        setError(ErrorParsingTransition);
        return -1;
    }
    if ((parseNameto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse transition name")
        setError(ErrorParsingTransition);
        return -1;
    }
    if (((res = parseNamesto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse variables")
        setError(ErrorParsingTransition);
        return -1;
    }
    if (((res = parseCodeto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse code")
        setError(ErrorParsingTransitionCode);
        return -1;
    }
    if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected )")
        setError(ErrorParsingTransition);
        return -1;
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static int parseTransitionsto(PNVMStringIter & i, char **outptr) {
    char *out;
    char **outacc;
    PNVMStringIter iterTmp;
    char *outTmp;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    parseSkipBlanksuntilOneOf(i, "()");
    while ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) != ')')) {
        iterTmp = i;
        outTmp = out;
        outacc = makePointer(outTmp);
        if ((parseTransitionto(iterTmp, outacc)) < 0) {
            if (!(parseSkipBlanksuntil(iterTmp, ')'))) {
				LOG4CXX_ERROR(exlog, "expected ')', not: '" << pnvmIterValue(iterTmp) << "'")
                setError(ErrorParsingTransitions);
                return -1;
            }
            return parseStoreOffsettoPtr(out, outptr);
        } else {
            pnvmIterAssign(i, iterTmp);
            out = outTmp;
            parseSkipBlanksuntilOneOf(i, "()");
        }
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static PNVMTupleHead * parseTupleallowNetInst(PNVMStringIter & i, int allowNetInst) {
    PNVMItemIterator iter;
    PNVMTupleHead *res;
    PNVMTupleIter ti;

    /* assert(interpreterProxy->isKindOf(allowNetInst,'Boolean')); */
    if (((res = pnvmTupleNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate tuple for parsed tuple")
        return NULL;
    }
    ti = pnvmValueIterator(res);
    iter = pnvmIterAsItemIterator(ti);
    if (!(parseCollectionstartingWithendingWithtoallowNetInst(i, '[', ']', iter, allowNetInst))) {
        pnvmValueDelete(res);
        setError(ErrorParsingCollection);
        return NULL;
    }
    return res;
}

static int parseUplinkto(PNVMStringIter & i, char **outptr) {
    char *out;
    int res;
    char **outacc;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    outacc = &out;
    if ((parseSkipBlanksLBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected (")
        setError(ErrorParsingUplink);
        return -1;
    }
    if ((parseExpCharfromto('U', i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected 'U'")
        setError(ErrorParsingUplink);
        return -1;
    }
    if (((res = parseNameto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse name")
        setError(ErrorParsingUplink);
        return -1;
    }
    if (((res = parseNamesto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse arguments")
        setError(ErrorParsingUplink);
        return -1;
    }
    if (((res = parseNamesto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse variables")
        setError(ErrorParsingUplink);
        return -1;
    }
    if (((res = parseCodeto(i, outacc))) < 0) {
		LOG4CXX_ERROR(parselog, "failed to parse code")
        setError(ErrorParsingUplink);
        return -1;
    }
    if ((parseSkipBlanksRBto(i, outacc)) < 0) {
		LOG4CXX_ERROR(parselog, "expected )")
        setError(ErrorParsingUplink);
        return -1;
    }
    return parseStoreOffsettoPtr(out, outptr);
}

static int parseUplinksto(PNVMStringIter & i, char **outptr) {
    char *out;
    PNVMStringIter ii;
    char **outacc;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    out = *outptr;
    outacc = &out;
    parseSkipBlanksuntilOneOf(i, "()");
    while ((!(pnvmIterAtEnd(i))) && ((pnvmIterValue(i)) != ')')) {
        ii = i;
        pnvmIterNext(ii);
        if ((pnvmIterValue(ii)) == 'U') {
            if ((parseUplinkto(i, outacc)) < 0) {
				LOG4CXX_ERROR(parselog, "failed to parse uplinks")
                setError(ErrorParsingUplinks);
                return -1;
            }
            parseSkipBlanksuntilOneOf(i, "()");
        } else {
            return parseStoreOffsettoPtr(out, outptr);
        }
    }
    return parseStoreOffsettoPtr(out, outptr);
}


/*	
    Parse parameter of transition element or value of expression.
    It consists of value symbol (one of {$S, $I, $V)) and integer.
    Meaning of value symbols:
        $S following number points to the symbols of net template -> the result is a symbol
        $I following number is integer value
        $V following number points to the transition variables array
     */

static int parseValueto(PNVMStringIter & i, char **outptr) {
    char *out;
    char **outacc;
    int c;

    out = *outptr;
    outacc = &out;
    if (!(parseSkipBlanksuntilOneOf(i, "SIV"))) {
		LOG4CXX_ERROR(parselog, "expected one of ")
        return -1;
    }
    c = ((int)(pnvmIterNext(i)));
    out[0] = c;
    out++;
    if (c == (((int)'I'))) {
        if ((parseIntegerto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "failed to parse integer")
            return -1;
        }
    } else {
        if ((parsePosIntegerto(i, outacc)) < 0) {
			LOG4CXX_ERROR(parselog, "failed to parse positive integer")
            return -1;
        }
    }
    parseStoreOffsettoPtr(out, outptr);
    return 3;
}

static int placeIndexin(PNVMStringHead const *name, PNVMTemplate const *tmpl) {
    PNVMTupleIter i;
    int index;

    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    /* assert(interpreterProxy->isKindOf(name,'PNVMStringHead')); */
    i = pnvmValueIterator(((PNVMTupleHead *) (pnvmTemplatePlaces(tmpl))));
    index = 0;
    while (!(pnvmIterAtEnd(i))) {
        if ((cmpStringwith(name, ((PNVMStringHead *) (pnvmTokenPointer(pnvmIterValue(i)))))) == 0) {
            return index;
        }
        index += 1;
        pnvmIterNext(i);
    }
	LOG4CXX_ERROR(exlog, "could not find place with name " << asPlainString(name) << " in template " << dereference(tmpl))
    return -1;
}

PNVMEvent * primitiveCalFront(void) {
    /* begin calFront */
    unlessdieWithmsg(!(calendarHead == NULL), ErrorCalendarEmpty, "calendar is empty");
    return calendarHead;
}

bool primitiveCalIsEmpty(void) {
    return calendarHead == NULL;
}


/*	
    Deallocates all resources.
     */

void primitiveCleanup(void) {
    ;
}


/*	
    Deallocates all resources.
     */

void primitiveCleanupModule(void) {
    pnvmValueDelete(inputBuffer);
    pnvmValueDelete(outputBuffer);
    inputBuffer = NULL;
    outputBuffer = NULL;
    ;
    stepCounter = 0;
    currentTime = 0;
    cleanupOMModule();
}

char * primitiveCodeIteratorAt(int pos) {
    return getCodeIteratorAt(pos);
}


/*	
    Gets the number of bytes occupied in net template code array.
     */

CodeLength_t primitiveCodeSize(void) {
    return getCodeSize();
}

Time_t primitiveCurrentTime(void) {
    return currentTime;
}


/*	Returns Boolean saying, whether serious error occured. */

bool primitiveFailed(void) {
    return error != ErrorSuccess;
}

bool primitiveInputCStr(char const *msg) {
    return inputMessage(msg);
}

bool primitiveInputString(PNVMStringHead *msg) {
    return inputString(msg);
}

PNVMNetInstHead * primitiveInstantiateTemplate(int tmplId) {
    return instantiateTemplate(tmplId);
}

int primitiveLoadNetTemplate(char const *msg) {
    int tmp;

    return loadNetTemplate(msg);
}


/*	
    This is supposed to be used by main program at initialization.
    Code for this template must already be filled in netTemplateCode.
    
    :param places: array of pointers to string with names of places of plcCount length
     */

Error_t primitiveMakePlatformTemplateplaceCountplacessymbolscodeLengthtransitions(char const *name, int plcCount, char const * const *places, char const *symbols, CodeLength_t codeLength, CodeLength_t transitions) {
    int i;
    PNVMTemplate *tmpl;
    PNVMStringHead *tmpStr;
    PNVMStringIter strIter;
    PNVMTupleHead *tuple;
    PNVMToken token;
    PNVMTupleIter tupiter;

    assert(transitions < codeLength);
    assert(plcCount >= 0);
    if (((tmpl = pnvmTemplateNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate net template")
        return setError(ErrorNoMemory);
    }
    if (((tmpStr = cstrToString(name))) == NULL) {
        pnvmValueDelete(tmpl);
		LOG4CXX_ERROR(exlog, "failed to create string for template name of out c-string")
        return setError(ErrorNoMemory);
    }
    pnvmTemplateSetName(tmpl, tmpStr);
    if (((tuple = pnvmTupleNew())) == NULL) {
        pnvmValueDelete(pnvmTemplateName(tmpl));
        pnvmValueDelete(tmpl);
        return setError(ErrorNoMemory);
    }
    tupiter = pnvmValueIterator(tuple);
    for (i = 0; i <= (plcCount - 1); i += 1) {
        if (((tmpStr = cstrToString(places[i]))) == NULL) {
            pnvmValueDelete(pnvmTemplateName(tmpl));
            pnvmValueDelete(tmpl);
			LOG4CXX_ERROR(exlog, "failed to create string of out c-string")
            return setError(ErrorNoMemory);
        }
        token = pnvmNewPointer(tmpStr);
        pnvmIterWrite(tupiter, token);
        pnvmTokenMakeInvalid(token);
    }
    pnvmTemplateSetPlaces(tmpl, tuple);
    if (((tmpStr = cstrToString(symbols))) == NULL) {
        pnvmValueDelete(pnvmTemplateName(tmpl));
        pnvmValueDelete(pnvmTemplatePlaces(tmpl));
        pnvmValueDelete(tmpl);
		LOG4CXX_ERROR(exlog, "failed to make string out of platform's symbols")
        return setError(ErrorNoMemory);
    }
    strIter = pnvmValueIterator(tmpStr);
    if (((tuple = parseTupleallowNetInst(strIter, 0))) == NULL) {
        pnvmValueDelete(tmpStr);
        pnvmValueDelete(pnvmTemplateName(tmpl));
        pnvmValueDelete(pnvmTemplatePlaces(tmpl));
        pnvmValueDelete(tmpl);
		LOG4CXX_ERROR(parselog, "failed to parse platform symbols")
        return setError(ErrorParsingCollection);
    }
    pnvmValueDelete(tmpStr);
    pnvmTemplateSetSymbols(tmpl, tuple);
    pnvmTemplateSetPlaceCount(tmpl, plcCount);
    pnvmTemplateSetCodeOffset(tmpl, 0);
    pnvmTemplateSetCodeLength(tmpl, codeLength);
    pnvmTemplateSetTransitions(tmpl, transitions);
    if ((appendNetTemplate(tmpl)) < 0) {
		LOG4CXX_ERROR(exlog, "failed to append platform template")
        return setError(ErrorUnspecified);
    }
    return error;
}

PNVMTemplate * primitiveNetTemplateAt(int index) {
    unlessdieWithmsgwith((index > 0) && (index < numberOfNetTemplates), ErrorOutOfRange, "index to net template table is out of range: ", index);
    return netTemplateTable[index];
}

int primitiveNothingChanged(void) {
    return nothingChanged;
}

int primitiveNumberOfNetTemplates(void) {
    return numberOfNetTemplates;
}


/*	
    Returns serialized token from input buffer as String object.
    Caller should deallocate it with pnvmValueDelete()
     */

bool primitiveOutputBufferEmpty(void) {
    return (pnvmValueItemCount(outputBuffer)) == 0;
}


/*	
    This allocates new buffer and puts the output serialized token into it.
    Caller should deallocate it with free().
    
    In smalltalk this returns String instance.
     */

char * primitiveOutputPopCStr(void) {
    char *res;
    PNVMStringHead *str;

    str = outputPopMessage();
    res = stringToCStr(str);
    pnvmValueDelete(str);
    return res;
}


/*	
    Returns serialized token from input buffer as String object.
    Caller should deallocate it with pnvmValueDelete()
     */

PNVMStringHead * primitiveOutputPopMessage(void) {
    return outputPopMessage();
}


/*	
    just for testing purposes
    
    should be deleted, when parsing works perfectly
     */

PNVMTemplate * primitiveParseNetTemplate(PNVMStringHead *strBlock) {
    PNVMStringIter iter;

    iter = pnvmValueIterator(strBlock);
    return parseNetTemplate(iter);
}

PNVMStringHead * primitiveRenderAsString(PNVMStringHead const *value) {
    return renderAsString(value);
}


/*	
    Returns number of characters written, -1 on error.
     */

int primitiveSerializeTokento(PNVMToken const & token, PNVMStringIter & o) {
    return serializeTokento(token, o);
}


/*	
    Return number of characters written or -1 on error.
     */

int primitiveSerializeValueto(PNVMHeaderBlock const *value, PNVMStringIter & o) {
    return serializeValueto(value, o);
}


/*	
    Do a single step.
    Return number of steps executed until now.
     */

int primitiveStep(void) {
    step();
    return stepCounter;
}

int primitiveStepsExecuted(void) {
    return stepCounter;
}


/*	
    Converts String object to NULL-terminated c string.
    Caller has to call free on it to release it.
     */

char * primitiveStringToCStr(PNVMStringHead const *str) {
    return stringToCStr(str);
}


/*	
    This method iterates over transitions of template, which are tried
    to be executed for every instance.
    
    Return Success if no serious error occured during execution.
     */

static Error_t processTemplateInstances(PNVMTemplate *tmpl) {
    PNVMTupleHead *vars;
    char const *codeptr;
    PNVMStringHead *trName;
    PNVMStringIter s;
    Error_t err;

    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
	LOG4CXX_DEBUG(exlog, "entering processTemplateInstances:")
    if (((pnvmTemplateInstances(tmpl)) == NULL) || ((pnvmValueItemCount(pnvmTemplateInstances(tmpl))) < 1)) {

        /* 
        Array of instances is allocated when it's needed.
        That's why we check it.
         */

		LOG4CXX_DEBUG(exlog, "leaving processTemplateInstances:")
    } else {
        codeptr = getCodeIteratorAt(pnvmTemplateTransitions(tmpl));
        if (((vars = pnvmTupleNew())) == NULL) {
			LOG4CXX_ERROR(exlog, "failed to allocate tuple for variables")
            return setError(ErrorNoMemory);
        }
        while (!(((codeptr[0]) == (((int)')'))) || (error != ErrorSuccess))) {
            codeptr++;
            codeptr++;
            
#if !defined(TARGET_ARDUINO) && DEBUG
            if (((trName = pnvmStringNew())) == NULL) {
				LOG4CXX_ERROR(exlog, "failed to allocate temporary string for serialization of token")
                return setError(ErrorNoMemory);
            }
            s = pnvmValueIterator(trName);
            while (!((codeptr[0]) == (((int)'(')))) {
                pnvmIterWrite(s, *codeptr++);
            }
			LOG4CXX_INFO(exlog, "running transaction '" << asPlainString(trName) << "' on instances of template " << dereference(tmpl))
            pnvmValueDelete(trName);
            
#else
            while (!((codeptr[0]) == (((int)'(')))) {
                codeptr++;
            }
            
#endif
            changeBlockSizeOfto(vars, codeGetVariableCount(codeptr));
            if (!(((err = processTemplateInstancesonTransitionwithVariables(pnvmTemplateInstances(tmpl), codeptr, vars))) == ErrorSuccess)) {
                pnvmValueDelete(vars);
                return err;
            }
            codeSeekSkipTransitionElements(codeptr);
            codeptr++;
        }
        pnvmValueDelete(vars);
    }
	LOG4CXX_DEBUG(exlog, "leaving processTemplateInstances:")
    return ErrorSuccess;
}


/*	
    Process all instances of template for particular transition.
    
    :param codeptr: points at the opening bracket of the first transition element.
        It is not modified by this function.
        
    Return ErrorSuccess if there was no serious error.
     */

static Error_t processTemplateInstancesonTransitionwithVariables(PNVMArrayHead *instances, char const *codeptr, PNVMTupleHead *vars) {
    PNVMArrayIter i;
    PNVMToken inst;
    PNVMTupleIter vi;

    /* assert(interpreterProxy->isKindOf(instances,'PNVMArrayHead')); */
	LOG4CXX_DEBUG(exlog, "entering processTemplateInstances:onTransition:withVariables:")
    i = pnvmValueIterator(instances);
    vi = pnvmValueIterator(vars);
    while (!((pnvmIterAtEnd(i)) || (error != ErrorSuccess))) {

        /* let's free all binded variables */

        pnvmIterSeekStart(vi);
        while (!(pnvmIterAtEnd(vi))) {
            pnvmTokenMakeInvalid(pnvmIterNext(vi));
        }

        /* codeptr does not get modified */

        inst = pnvmNewNetRef(pnvmTokenNetRef(pnvmIterNext(i)));
        processTransitiononNetInstwithVariables(codeptr, pnvmTokenNetRef(inst), vars);
        pnvmTokenMakeInvalid(inst);
    }
	LOG4CXX_DEBUG(exlog, "leaving processTemplateInstances:onTransition:withVariables:")
    return error;
}


/*	
    Try to fire transition on particular net instance.
    This function modifies 'nothingChanged' if the transition succeeds.
    
    :param codeptr: points at the opening bracket of the first transition element.
        It is not modified by this function.
     */

static Error_t processTransitiononNetInstwithVariables(char const *codeptr, PNVMNetInstHead *inst, PNVMTupleHead *vars) {
    PNVMArrayHead *arrtmp;
    PNVMArrayIter lastAttempt;
    PNVMArrayIter history;
    char const *tmpptr;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
	LOG4CXX_DEBUG(exlog, "entering processTransition:onNetInst:withVariables:")
    if (((arrtmp = pnvmArrayNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate array for lastAttempt")
        return setError(ErrorNoMemory);
    }
    lastAttempt = pnvmValueIterator(arrtmp);
    if (((arrtmp = pnvmArrayNew())) == NULL) {
        pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
		LOG4CXX_ERROR(exlog, "failed to allocate array for history")
        return setError(ErrorNoMemory);
    }

    /* ensure that codeptr does not get modified */

    history = pnvmValueIterator(arrtmp);
    tmpptr = codeptr + 0;
    if (executeTransitionElementsAtonwithVariableslastAttempthistory(tmpptr, inst, vars, lastAttempt, history)) {
        nothingChanged = 0;
    } else {
        unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(lastAttempt))) == 0, ErrorExecutionUnspecified, "lastAttempts must be cleared for failed transition");
        unlessdieWithmsg((pnvmValueItemCount(pnvmIterHeaderBlock(history))) == 0, ErrorExecutionUnspecified, "history must be cleared for failed transition");
    }
    pnvmValueDelete(pnvmIterHeaderBlock(lastAttempt));
    releaseHistory(pnvmIterHeaderBlock(history));
	LOG4CXX_DEBUG(exlog, "leaving processTransition:onNetInst:withVariables:")
    return error;
}


/*	
    Puts number of tokens into particular place of net instance.
    Returns number of occurences of this token in place after insertion.
     */

static int putNtokenstoPlaceofNetInst(int number, PNVMToken & token, int placeId, PNVMNetInstHead *inst) {
    PNVMPlaceHead *place;
    PNVMNetInstIter ni;
    int res;
    PNVMPlaceIter pi;
    PNVMPlaceItem plcItem;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
	LOG4CXX_INFO(exlog, "put " << number << " of tokens " << token << " to place " << placeId << " of instance " << dereference(inst))
    ni = pnvmValueIterator(inst);
    pnvmIterSeek(ni, placeId);
    place = pnvmIterValue(ni);
    pi = pnvmValueIterator(place);
    while ((!(pnvmIterAtEnd(pi))) && ((cmpTokenwith(token, pnvmPlaceItemToken(pnvmIterValue(pi)))) != 0)) {
        pnvmIterNext(pi);
    }
    if (pnvmIterAtEnd(pi)) {

        /* token not yet present in place */

        plcItem = pnvmPlaceItemNewof(number, token);
        pnvmIterWrite(pi, plcItem);
        pnvmPlaceItemMakeInvalid(plcItem);
        res = number;
    } else {

        /* token already present in place -> just increase the number */

        res = pnvmPlaceItemIncBy(pnvmIterValue(pi), number);
    }
    return res;
}


/*	
    Some items in history need a post-processing before it can be released upon
    successful execution of transition. This post-processing sets in effect actions
    like removal of net template etc.
    
    This iterates over history, makes permanent changes for actions that need it
    and then releases them all together with history array.
     */

static void releaseHistory(PNVMArrayHead *history) {
    PNVMArrayIter i;
    PNVMTemplate *tmpl;
    PNVMTupleIter ai;
    int index;
    PNVMTupleHead *action;

    /* assert(interpreterProxy->isKindOf(history,'PNVMArrayHead')); */
	LOG4CXX_DEBUG(exlog, "releasing history")
    i = pnvmValueIterator(history);
    while (!(pnvmIterAtEnd(i))) {

        /* check if action needs any post-processing and if not, release it */

        assert((pnvmTokenType(pnvmIterValue(i))) == TOKEN_TYPE_POINTER);
        /* assert(interpreterProxy->isKindOf((pnvmTokenPointer(pnvmIterValue(i))),'PNVMTupleHead')); */
        action = ((PNVMTupleHead *) (pnvmTokenPointer(pnvmIterValue(i))));
        assert((signature(action)) == SIGN_TUPLE);
        assert((pnvmValueItemCount(action)) > 0);
        ai = pnvmValueIterator(action);
        assert((pnvmTokenType(pnvmIterValue(ai))) == TOKEN_TYPE_INTEGER);
        if ((pnvmTokenInteger(pnvmIterNext(ai))) == (((int)'u'))) {

            /* unload net template */

            index = pnvmTokenInteger(pnvmIterNext(ai));
            tmpl = ((PNVMTemplate *) (pnvmTokenPointer(pnvmIterValue(ai))));
            removeNetTemplateonIndex(tmpl, index);
        }
        pnvmTokenMakeInvalid(pnvmIterNext(i));
    }
    pnvmValueDelete(history);
}


/*	
    This only deallocates any object on particular position in indexable value.
    It does not modify item count of affected value.
     */

static void releaseItemAtPos(PNVMItemIterator & i) {
    PNVMPlaceHead *place;
    PNVMHeaderBlock *hb;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    assert(!(pnvmIterAtEnd(i)));
    hb = pnvmIterHeaderBlock(i);
    if ((signature(hb)) == SIGN_ARRAY) {
        pnvmTokenMakeInvalid(pnvmIterValue(pnvmIterArray(i)));
    } else {
        if ((signature(hb)) == SIGN_TUPLE) {
            pnvmTokenMakeInvalid(pnvmIterValue(pnvmIterTuple(i)));
        } else {
            if ((signature(hb)) == SIGN_PLACE) {
                pnvmPlaceItemMakeInvalid(pnvmIterValue(pnvmIterPlace(i)));
            } else {
                if ((signature(hb)) == SIGN_NET_INSTANCE) {
                    place = NULL;
                    pnvmValueDelete(pnvmIterValue(pnvmIterNetInst(i)));
                    pnvmIterSetItem(pnvmIterNetInst(i), place);
                } else {
                    if ((signature(hb)) == SIGN_STRING) {
                        pnvmIterSetItem(pnvmIterString(i), ((char) 0));
                    } else {
                        dieWithmsgwith(ErrorExecutionUnhandledSignature, "can not release item for ", dereference(hb));
                    }
                }
            }
        }
    }
}


/*	
    Release all items from current position of iterator until the collection end.
    Empty blocks are removed as well.
    
    :param i: Iterator pointing at the first item of collection to release.
    
    Return valid iterator to current position (at end).
     */

static PNVMItemIterator releaseItemsFromPos(PNVMItemIterator & i) {
    int totalCapacity;
    int destIndex;
    int offset;
    PNVMItemIterator backIter;
    int bc;
    PNVMItemIterator ii;
    PNVMTailBlock *srcBlock;
    int offsetLimiT;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    ii = i;
    while (!((pnvmIterAtEnd(ii)) || (pnvmIterAtBlockEnd(ii)))) {

        /* first let's clean the current block */

        releaseItemAtPos(ii);
        pnvmIterNext(ii);
    }
    if (!(pnvmIterAtEnd(ii))) {

        /* we are at block end -> let's delete last item of block */

        releaseItemAtPos(ii);
        backIter = ii;
        pnvmIterNext(ii);
        if (!(pnvmIterAtEnd(ii))) {

            /* let's delete all following blocks */

            releaseItemsWithBlocksFromPos(ii);
            pnvmBlockSetTail(((PNVMHeaderBlock *) (pnvmIterCurrentBlock(backIter))), ((PNVMTailBlock *) NULL));
        }
    }

    /* total capacity of all blocks preceding current one */

    bc = pnvmValueIndexOfBlockAtItem(pnvmIterHeaderBlock(i), pnvmIterBlockIndex(i));
    totalCapacity = pnvmValueTotalCapacityAt(pnvmIterHeaderBlock(i), bc - 1);
    pnvmValueSetItemCount(pnvmIterHeaderBlock(i), pnvmIterIndex(i));
    if ((pnvmValueBlockCount(pnvmIterHeaderBlock(i))) <= (((unsigned) bc))) {

        /* let's move them to the previous block */


        /* current block is the source */

        srcBlock = ((PNVMTailBlock *) (pnvmIterCurrentBlock(i)));
        pnvmIterSeekStart(ii);
        pnvmIterSeek(ii, totalCapacity - 1);
        pnvmBlockSetTail(((PNVMHeaderBlock *) (pnvmIterCurrentBlock(ii))), ((PNVMTailBlock *) NULL));
        if ((pnvmIterCurrentBlock(ii)) == (pnvmIterHeaderBlock(i))) {
            destIndex = pnvmTypeNotLastCapacity(pnvmIterHeaderBlock(i));
        } else {
            destIndex = pnvmTypeTailNotLastCapacity(pnvmIterHeaderBlock(i));
        }
        for (offset = 0, offsetLimiT = ((pnvmIterIndex(i)) - totalCapacity); offset <= offsetLimiT; offset += 1) {

            /* move by swapping them */

            swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(destIndex + offset, pnvmIterCurrentBlock(ii), offset, srcBlock, signature(pnvmIterHeaderBlock(ii)), (pnvmIterHeaderBlock(i)) == (pnvmIterCurrentBlock(ii)));
        }
        pnvmBlockDelete(srcBlock);
        pnvmIterAssign(i, ii);
        pnvmIterSeekEnd(i);
    }
    return i;
}


/*	
    This is supposed to be called only from releaseItemsFromPos().
    It iteratively releases all items with blocks until the last one.
     */

static void releaseItemsWithBlocksFromPos(PNVMItemIterator & i) {
    PNVMTailBlock *prevBlock;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    while (!(pnvmIterAtEnd(i))) {
        while (!((pnvmIterAtEnd(i)) || (pnvmIterAtBlockEnd(i)))) {

            /* first let's clean the current block */

            releaseItemAtPos(i);
            pnvmIterNext(i);
        }
        if (!(pnvmIterAtEnd(i))) {

            /* we are at block end -> let's delete last item of block */

            releaseItemAtPos(i);

            /* move to the next block */

            prevBlock = ((PNVMTailBlock *) (pnvmIterCurrentBlock(i)));
            pnvmIterNext(i);
            pnvmBlockDelete(prevBlock);
        }
    }
}


/*	
    Removes item from any position of any indexable value.
    
    :param i: iterator pointing at the item to remove
    
    Return iterator to original position. Since removing an item may invalidate
    any iterators of its value.
     */

static PNVMItemIterator removeItemFromBlockAt(PNVMItemIterator & i) {
    int notLastCapacity;
    PNVMTailBlock *lb;
    int j;
    PNVMItemIterator src;
    void *lbo;
    int bc;
    PNVMHeaderBlock *fb;
    int lastCapacity;
    PNVMItemIterator dest;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    assert(!(pnvmIterAtEnd(i)));
    dest = i;
    src = i;
    releaseItemAtPos(dest);
    pnvmIterNext(src);
    while (!(pnvmIterAtEnd(src))) {
        swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(pnvmIterBlockIndex(dest), pnvmIterCurrentBlock(dest), pnvmIterBlockIndex(src), pnvmIterCurrentBlock(src), signature(pnvmIterHeaderBlock(dest)), (pnvmIterHeaderBlock(dest)) == (pnvmIterCurrentBlock(dest)));
        pnvmIterNext(src);
        pnvmIterNext(dest);
    }

    /* last but one block - it can be either header or tail block */

    fb = pnvmIterHeaderBlock(i);
    lbo = NULL;
    bc = pnvmValueBlockCount(fb);
    if (pnvmIterAtLastBlock(dest)) {
        lb = ((PNVMTailBlock *) (pnvmIterCurrentBlock(dest)));
    } else {

        /* if we are at convenient position, let's cache lbo before we need it for sure */

        pnvmIterSeek(dest, pnvmValueTotalCapacityAt(fb, bc - 3));
        assert(pnvmIterAtBlockStart(dest));
        lbo = pnvmIterCurrentBlock(dest);
        pnvmIterNextBlock(dest);
        lb = ((PNVMTailBlock *) (pnvmIterCurrentBlock(dest)));
    }
    pnvmValueSetItemCount(fb, (pnvmValueItemCount(fb)) - 1);
    if ((pnvmValueBlockCount(fb)) < (((unsigned int) bc))) {

        /* we must delete last block */

        if (lbo == NULL) {

            /* get last but one block */

            pnvmIterSeekStart(dest);
            pnvmIterSeek(dest, pnvmValueTotalCapacityAt(fb, bc - 3));
            lbo = pnvmIterCurrentBlock(dest);
            assert((pnvmIterAtBlockStart(dest)) && (pnvmIterAtLastBlock(dest)));
        }
        assert((pnvmBlockTail(((PNVMTailBlock *) lbo))) == lb);
        pnvmBlockSetTail(((PNVMTailBlock *) lbo), ((PNVMTailBlock *) NULL));
        if (lbo == fb) {

            /* we are assigning to header block */

            notLastCapacity = pnvmTypeNotLastCapacity(fb);
            lastCapacity = pnvmTypeLastCapacity(fb);
        } else {

            /* we are assigning to tail block */

            notLastCapacity = pnvmTypeTailNotLastCapacity(fb);
            lastCapacity = pnvmTypeTailLastCapacity(fb);
        }
        for (j = notLastCapacity; j <= (lastCapacity - 1); j += 1) {

            /* let's move items from last block to tail place of last but one block */
            /* we don't need to deallocate here */

            swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(j, lbo, j - notLastCapacity, lb, signature(fb), lbo == fb);
        }
        pnvmBlockDelete(lb);
        if ((((unsigned int) (pnvmIterIndex(i)))) >= (pnvmValueItemCount(fb))) {
            pnvmIterSeekEnd(dest);
            pnvmIterAssign(i, dest);
        }
    }
    return i;
}


/*	
    Returns number of net templates loaded after removal.
    At least one of arguments must be given. This can set codeWithHoles flag
    if there is a net template pointing to netTemlateCode after this one.
    
    :param index: points to the netTemplateTable to template to remove.
        If negative, index is found by tmpl address. If >=0 and tmpl is given
        and netTemplateTable contains nil at the index, template is deleted,
        but numberOfNetTemplates stays the same.
    :param tmpl: Net template address to remove. If not given, it's found in
        netTemplateTable by index.
     */

static int removeNetTemplateonIndex(PNVMTemplate *tmpl, int index) {
    PNVMTemplate *ptr;
    int tableIndex;

    assert((tmpl != NULL) || (index >= 0));
    /* assert((tmpl == NULL) || (interpreterProxy->isKindOf(tmpl,'PNVMTemplate'))); */
    assert((index < 0) || (index < MaxNetTemplates));
    if ((index >= 0) && (tmpl == NULL)) {
        tableIndex = index;
        ptr = netTemplateTable[index];
        assert(tmpl == ptr);
    } else {
        if ((tmpl != NULL) && (index < 0)) {
            tableIndex = 0;
            ptr = netTemplateTable[tableIndex];
            while (tmpl != ptr) {
                tableIndex += 1;
            }
        } else {
            tableIndex = index;
            ptr = tmpl;
            assert(((netTemplateTable[tableIndex]) == NULL) || (tmpl == (netTemplateTable[tableIndex])));
        }
    }
	LOG4CXX_INFO(exlog, "removing net template: " << dereference(tmpl))
    if (!((netTemplateTable[tableIndex]) == NULL)) {
        numberOfNetTemplates -= 1;
        netTemplateTable[tableIndex] = NULL;
    }
    if ((getCodeSize()) > ((pnvmTemplateCodeOffset(tmpl)) + (pnvmTemplateCodeLength(tmpl)))) {
        codeWithHoles = 1;
    }
    pnvmValueDelete(pnvmTemplateName(tmpl));
    pnvmValueDelete(pnvmTemplatePlaces(tmpl));
    pnvmValueDelete(pnvmTemplateSymbols(tmpl));
    if (!((pnvmTemplateInstances(tmpl)) == NULL)) {
        pnvmValueDelete(pnvmTemplateInstances(tmpl));
    }
    pnvmValueDelete(tmpl);
    return numberOfNetTemplates;
}


/*	
    Wraps input string in double quotes and escapes any double quote and back-slash
    in it.
    
    :param str is a string block
    Return new string or NULL on error
     */

static PNVMStringHead * renderAsString(PNVMStringHead const *str) {
    PNVMStringHead *res;
    PNVMStringIter o;

    /* assert(interpreterProxy->isKindOf(str,'PNVMStringHead')); */
    if (((res = pnvmStringNew())) == NULL) {
		LOG4CXX_ERROR(exlog, "failed to allocate string for serialization of string object")
        return NULL;
    }
    o = pnvmValueIterator(res);
    if ((renderAsStringto(str, o)) < 0) {
        pnvmValueDelete(res);
        return NULL;
    }
    return res;
}


/*	
    Wraps input string in double quotes and escapes any double quote and back-slash
    in it.
    
    :param str: A String block
    :param o: An output String iterator
    Return number of items written or -1 on error.
     */

static int renderAsStringto(PNVMStringHead const *str, PNVMStringIter & o) {
    PNVMStringIter i;
    int origWritePosition;

    /* assert(interpreterProxy->isKindOf(str,'PNVMStringHead')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf((pnvmIterHeaderBlock(o)),'PNVMStringHead')); */
    i = pnvmValueIterator(((PNVMStringHead *) str));
    origWritePosition = pnvmIterIndex(o);
    if (pnvmIterCanAppend(o)) {
        pnvmIterWrite(o, '"');
        while ((!(pnvmIterAtEnd(i))) && (pnvmIterCanAppend(o))) {
            if (((pnvmIterValue(i)) == '"') || ((pnvmIterValue(i)) == ('\\'))) {
                pnvmIterWrite(o, '\\');
                if (pnvmIterCanAppend(o)) {
                    pnvmIterWrite(o, pnvmIterNext(i));
                }
            } else {
                if (((pnvmIterValue(i)) == ('\n')) || (((pnvmIterValue(i)) == ('\t')) || ((pnvmIterValue(i)) == ('\r')))) {
                    pnvmIterWrite(o, '\\');
                    if (pnvmIterCanAppend(o)) {
                        pnvmIterWrite(o, ((pnvmIterValue(i)) == ('\n')
                            ? 'n'
                            : ((pnvmIterValue(i)) == ('\t')
    ? 't'
    : 'r')));
                    }
                    pnvmIterNext(i);
                } else {
                    pnvmIterWrite(o, pnvmIterNext(i));
                }
            }
        }
    }
    if (pnvmIterCanAppend(o)) {
        pnvmIterWrite(o, '"');
    } else {
		LOG4CXX_ERROR(exlog, "reached the max capacity of string, while rendering: " << asPlainString(str))
        setError(ErrorCollectionFull);
        return -1;
    }
    return (pnvmIterIndex(o)) - origWritePosition;
}


/*	
    Restore action 'assign'. It's generated by : expression operator.
    
    Action contains following elements:
        [$:, variableId]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionAssignwithVariables(PNVMTupleIter ai, PNVMTupleHead *vars) {
    int variableId;
    PNVMTupleIter vi;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)':')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
    vi = pnvmValueIterator(vars);
    variableId = pnvmTokenInteger(pnvmIterNext(ai));
	LOG4CXX_INFO(exlog, "clearing assignment to variable " << variableId)
    pnvmIterSeek(vi, variableId);
    pnvmTokenMakeInvalid(pnvmIterValue(vi));
}


/*	
    Restore action creation of net instance. It's generated by $i or $c expression
    operators.
    
    Action contains following elements:
        [$l, instance]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionCreateInstance(PNVMTupleIter ai) {
    PNVMArrayIter iter;
    PNVMTemplate *tmpl;
    PNVMNetInstHead *inst;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert(((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'i'))) || ((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'c'))));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
    assert((pnvmTokenType(pnvmIterValue(ai))) == TOKEN_TYPE_NET_REF);
    inst = ((PNVMNetInstHead *) (pnvmTokenPointer(pnvmIterValue(ai))));
    if ((pnvmTemplateInstances(pnvmNetInstTemplate(inst))) == NULL) {
		LOG4CXX_ERROR(exlog, "can not remove instance from template with no alive instances")
    } else {
        tmpl = pnvmNetInstTemplate(inst);
        iter = pnvmValueIterator(pnvmTemplateInstances(tmpl));
        while ((!(pnvmIterAtEnd(iter))) && ((pnvmTokenNetRef(pnvmIterValue(iter))) != inst)) {
            pnvmIterNext(iter);
        }
        if (pnvmIterAtEnd(iter)) {
			LOG4CXX_ERROR(exlog, "can not remove not present instance from template")
        } else {

            /* let the garbage collector do the rest */

            removeItemFromBlockAt(pnvmIterAsItemIterator(iter));
			LOG4CXX_INFO(exlog, "removed instance from net template" << tmpl)
        }
    }
}


/*	
    Restore action 'load template'. It's generated by l expression operator.
    
    Action contains following elements:
        [$l, index, template]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionLoadTemplate(PNVMTupleIter ai) {
    PNVMTemplate *tmpl;
    int index;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'l')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 3);
    index = pnvmTokenInteger(pnvmIterNext(ai));
    tmpl = ((PNVMTemplate *) (pnvmTokenPointer(pnvmIterNext(ai))));
    removeNetTemplateonIndex(tmpl, index);
	LOG4CXX_INFO(exlog, "restored action load template")
}


/*	
    Restore action 'push back'. It's generated by $a expression operator.
    
    Action contains following elements:
        [$a, array]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionPushBack(PNVMTupleIter ai) {
    PNVMArrayHead *array;
    PNVMArrayIter arrayIter;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'a')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
    array = ((PNVMArrayHead *) (pnvmTokenPointer(pnvmIterNext(ai))));
    arrayIter = pnvmValueIterator(array);
    pnvmIterSeek(arrayIter, (pnvmValueItemCount(array)) - 1);
	LOG4CXX_INFO(exlog, "removing last added item from collection " << array)
    removeItemFromBlockAt(pnvmIterAsItemIterator(arrayIter));
}


/*	
    Restore action put. It's generated by O transition element.
    
    Action contains following elements:
        [$O, inst, placeId, number, token]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionPut(PNVMTupleIter ai) {
    PNVMPlaceHead *place;
    PNVMNetInstIter ni;
    PNVMPlaceIter pi;
    int placeId;
    PNVMNetInstHead *inst;
    PNVMToken token;
    int found;
    int number;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'O')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 5);
    inst = pnvmTokenNetRef(pnvmIterNext(ai));
    placeId = pnvmTokenInteger(pnvmIterNext(ai));
    number = pnvmTokenInteger(pnvmIterNext(ai));
    token = pnvmIterNext(ai);
    ni = pnvmValueIterator(inst);
    pnvmIterSeek(ni, placeId);
    place = pnvmIterValue(ni);
    pi = pnvmValueIterator(place);
    found = 0;
    while (!((pnvmIterAtEnd(pi)) && (!found))) {

        /* try to find token in place and restore its number */

        if ((cmpTokenwith(token, pnvmPlaceItemToken(pnvmIterValue(pi)))) == 0) {

            /* token found */

			LOG4CXX_INFO(exlog, "taking back " << number << " of tokens: " << token << " to place " << placeId << " of instance " << inst)
            pnvmPlaceItemSetNumber(pnvmIterValue(pi), (pnvmPlaceItemNumber(pnvmIterValue(pi))) - number);
            found = 1;
        }
        pnvmIterNext(pi);
    }
    if (!(found)) {

        /* this must not happed for $O */

        dieWithmsgwithwith(ErrorExecutionUnspecified, "written token [1] not found in place [2] of instance ", token, placeId);
    }
}


/*	
    Restore action 'schedule put'. It's generated by $Y transition element.
    
    Action contains following elements:
        [$Y, event]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionSchedulePut(PNVMTupleIter ai) {
    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'Y')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
	LOG4CXX_INFO(exlog, "removing last added event from calendar")
    calRemoveEvent(((PNVMEvent *) (pnvmTokenPointer(pnvmIterNext(ai)))));
}


/*	
    Restore action 'send'. It's generated by $s expression operator.
    
    Action contains following elements:
        [$s, token]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionSend(PNVMTupleIter ai) {
    PNVMArrayIter bufIter;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'s')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 2);
    bufIter = pnvmValueIterator(outputBuffer);
    pnvmIterSeek(bufIter, (pnvmValueItemCount(outputBuffer)) - 1);
    unlessdieWithmsg((cmpTokenwith(pnvmIterValue(bufIter), pnvmIterNext(ai))) == 0, ErrorExecutionUnspecified, "token appended to output buffer does not match");
	LOG4CXX_INFO(exlog, "removing last added token from output buffer")
    removeItemFromBlockAt(pnvmIterAsItemIterator(bufIter));
}


/*	
    Restore action take. It's generated by P transition element.
    
    Action contains following elements:
        [$P, inst, placeId, position, number, token]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionTake(PNVMTupleIter ai) {
    PNVMPlaceIter pi;
    PNVMPlaceHead *place;
    PNVMNetInstHead *inst;
    PNVMNetInstIter ni;
    PNVMToken token;
    int number;
    PNVMPlaceItem plcItem;
    PNVMPlaceIter src;
    int position;
    int placeId;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'P')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 6);
    inst = pnvmTokenNetRef(pnvmIterNext(ai));
    placeId = pnvmTokenInteger(pnvmIterNext(ai));
    position = pnvmTokenInteger(pnvmIterNext(ai));
    number = pnvmTokenInteger(pnvmIterNext(ai));
    token = pnvmIterNext(ai);
    ni = pnvmValueIterator(inst);
    pnvmIterSeek(ni, placeId);
    place = pnvmIterValue(ni);
    pi = pnvmValueIterator(place);
    if (position > (((int) (pnvmValueItemCount(place))))) {

        /* something wrong is going on */

        dieWithmsgwith(ErrorOutOfRange, "can not put back token on position > ", pnvmValueItemCount(place));
    }
    pnvmIterSeek(pi, position);
    if ((pnvmIterAtEnd(pi)) || ((cmpTokenwith(token, pnvmPlaceItemToken(pnvmIterValue(pi)))) != 0)) {

        /* token not found -> it has been deleted by current action; let's add it again */

		LOG4CXX_INFO(exlog, "writing back " << number << " of tokens: " << token << " to place " << placeId << " of instance " << dereference(inst))
        if (pnvmIterAtEnd(pi)) {
            plcItem = pnvmPlaceItemNewof(number, token);
            pnvmIterSetItem(pi, plcItem);
            pnvmPlaceItemMakeInvalid(plcItem);
        } else {

            /* we need to shift all the other tokens by one to the right */
            /* so we have space for our token on its original position */

            src = pi;
            pnvmIterSeekStart(pi);
            pnvmIterSeekEnd(src);
            plcItem = pnvmPlaceItemNewof(number, token);
            pnvmIterSetItem(src, plcItem);
            pnvmPlaceItemMakeInvalid(plcItem);
            pnvmIterSeek(pi, (pnvmIterIndex(src)) - 1);
            while ((pnvmIterIndex(pi)) >= position) {

                /* shift them by swaping neighboring items from the rear */

                swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(pnvmIterBlockIndex(pi), pnvmIterCurrentBlock(pi), pnvmIterBlockIndex(src), pnvmIterCurrentBlock(src), SIGN_PLACE, (pnvmIterHeaderBlock(pi)) == (pnvmIterCurrentBlock(pi)));
                pnvmIterAssign(src, pi);
                pnvmIterSeek(pi, (pnvmIterIndex(pi)) - 1);
            }
        }
    } else {
		LOG4CXX_INFO(exlog, "putting back " << number << " of tokens: " << token << " to place " << placeId << " of instance " << dereference(inst) << " at position " << position)
        pnvmPlaceItemSetNumber(pnvmIterValue(pi), (pnvmPlaceItemNumber(pnvmIterValue(pi))) + number);
    }
}


/*	
    Restore action 'send'. It's generated by $u expression operator.
    
    Action contains following elements:
        [$s, index, template]
    
    :param ai: is action iterator pointing at the second element of action
     */

static void restoreActionUnload(PNVMTupleIter ai) {
    PNVMTemplate *tmpl;
    int index;

    /* assert(interpreterProxy->isKindOf(ai,'PNVMItemIterator')); */
    assert((pnvmTokenInteger((dereference(pnvmIterHeaderBlock(ai)))[0])) == (((int)'u')));
    assert((pnvmValueItemCount(pnvmIterHeaderBlock(ai))) == 3);
    index = pnvmTokenInteger(pnvmIterNext(ai));
    tmpl = ((PNVMTemplate *) (pnvmTokenPointer(pnvmIterNext(ai))));
    netTemplateTable[index] = tmpl;
    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    numberOfNetTemplates += 1;
	LOG4CXX_INFO(exlog, "put back template " << dereference(tmpl) << " at index=" << index)
}


/*	
    History of actions made during transition execution needs to be restored any time
    one transition element fails. History is an array containing notes about modification
    of interpreter state in chronological order. This function reverts any action from
    the position of iterator (including current position) to the end of history array and
    releases allocated space.
    
    :param i: iterator to action in history. After the function completes, it will point at history
        end.
        
    Return iterator to current position (pointing at end).
     */

static PNVMArrayIter restoreHistoryFromPoswithVariables(PNVMArrayIter & i, PNVMTupleHead *vars) {
    int bc;
    PNVMArrayIter ii;

    /* assert(interpreterProxy->isKindOf(i,'PNVMItemIterator')); */
    /* assert(interpreterProxy->isKindOf(vars,'PNVMTupleHead')); */
	LOG4CXX_DEBUG(exlog, "entering restoreHistoryFromPos: " << pnvmIterIndex(i) << " withVariables:")
    if (pnvmIterAtEnd(i)) {
		LOG4CXX_DEBUG(exlog, "leaving restoreHistoryFromPos:withVariables: (at end)")
    } else {
        if (!((((ItemCount_t) (pnvmIterIndex(i)))) == ((pnvmValueItemCount(pnvmIterHeaderBlock(i))) - 1))) {

            /* first restore the latest actions made */

            bc = pnvmValueBlockCount(pnvmIterHeaderBlock(i));
            ii = i;
            pnvmIterNext(ii);
            restoreHistoryFromPoswithVariables(ii, vars);
            if (bc > (((int) (pnvmValueBlockCount(pnvmIterHeaderBlock(i)))))) {
                pnvmIterSeekStart(i);
                pnvmIterSeek(i, (pnvmIterIndex(ii)) - 1);
            }
        }
        restoreTransactionActionwithVariables(((PNVMTupleHead *) (pnvmTokenPointer(pnvmIterValue(i)))), vars);
        removeItemFromBlockAt(pnvmIterAsItemIterator(i));
		LOG4CXX_DEBUG(exlog, "leaving restoreHistoryFromPos:withVariables:")
    }
    return i;
}

static void restoreTransactionActionwithVariables(PNVMTupleHead *a, PNVMTupleHead *vars) {
    PNVMTupleIter ai;
    char kind;

    /* assert(interpreterProxy->isKindOf(a,'PNVMTupleHead')); */
    ai = pnvmValueIterator(a);
    kind = pnvmTokenInteger(pnvmIterNext(ai));
    if (kind == (((int)'P'))) {
        restoreActionTake(ai);
    } else {
        if (kind == (((int)'O'))) {
            restoreActionPut(ai);
        } else {
            if (kind == (((int)'l'))) {
                restoreActionLoadTemplate(ai);
            } else {
                if ((kind == (((int)'i'))) || (kind == (((int)'c')))) {
                    restoreActionCreateInstance(ai);
                } else {
                    if (kind == (((int)':'))) {
                        restoreActionAssignwithVariables(ai, vars);
                    } else {
                        if (kind == (((int)'a'))) {
                            restoreActionPushBack(ai);
                        } else {
                            if (kind == (((int)'Y'))) {
                                restoreActionSchedulePut(ai);
                            } else {
                                if (kind == (((int)'u'))) {
                                    restoreActionUnload(ai);
                                } else {
                                    if (kind == (((int)'s'))) {
                                        restoreActionSend(ai);
                                    } else {
                                        dieWithmsgwith(ErrorExecutionUnhandledOperator, "unhandled action ro revert: ", kind);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


/*	Return number of written characters, -1 on error. */

static int serializeNameto(PNVMStringHead const *name, PNVMStringIter & o) {
    PNVMStringIter si;

    /* assert(interpreterProxy->isKindOf(name,'PNVMStringHead')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    si = pnvmValueIterator(((PNVMStringHead *) name));
    while ((!(pnvmIterAtEnd(si))) && (pnvmIterCanAppend(o))) {
        pnvmIterWrite(o, pnvmIterNext(si));
    }
    if (!(pnvmIterAtEnd(si))) {
        setError(ErrorCollectionFull);
        return -1;
    }
    return pnvmValueItemCount(name);
}


/*	Return number of written characters or -1 on error. */

static int serializeNetInstto(PNVMNetInstHead const *inst, PNVMStringIter & o) {
    PNVMTemplate *tmpl;
    PNVMNetInstIter ni;
    int origWritePosition;
    PNVMPlaceIter pi;
    PNVMPlaceItem placeItem;
    PNVMTupleIter pni;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    origWritePosition = pnvmIterIndex(o);
    if (!(pnvmIterCanAppend(o))) {
        setError(ErrorCollectionFull);
        return -1;
    }
    pnvmIterWrite(o, '(');
    if (!(pnvmIterCanAppend(o))) {
        setError(ErrorCollectionFull);
        return -1;
    }
    pnvmIterWrite(o, 'n');
    tmpl = pnvmNetInstTemplate(inst);
    if ((serializeNameto(pnvmTemplateName(tmpl), o)) < 0) {
        return -1;
    }
    ni = pnvmValueIterator(((PNVMNetInstHead *) inst));
    pni = pnvmValueIterator(pnvmTemplatePlaces(tmpl));
    while ((!(pnvmIterAtEnd(ni))) && (pnvmIterCanAppend(o))) {
        pnvmIterWrite(o, '(');
        if (!(pnvmIterCanAppend(o))) {
            setError(ErrorCollectionFull);
            return -1;
        }
        pnvmIterWrite(o, 'p');
        if (!(pnvmIterCanAppend(o))) {
            setError(ErrorCollectionFull);
            return -1;
        }
        if ((serializeNameto(((PNVMStringHead *) (pnvmTokenPointer(pnvmIterNext(pni)))), o)) < 0) {
            return -1;
        }
        pi = pnvmValueIterator(pnvmIterNext(ni));
        while (!(pnvmIterAtEnd(pi))) {
            placeItem = pnvmIterNext(pi);
            if (!(pnvmIterCanAppend(o))) {
                setError(ErrorCollectionFull);
                return -1;
            }
            pnvmIterWrite(o, '(');
            if (!(pnvmIterCanAppend(o))) {
                setError(ErrorCollectionFull);
                return -1;
            }
            pnvmIterWrite(o, 't');
            if ((serializeNumberto(pnvmPlaceItemNumber(placeItem), o)) < 0) {
                return -1;
            }
            if (!(pnvmIterCanAppend(o))) {
                setError(ErrorCollectionFull);
                return -1;
            }
            pnvmIterWrite(o, ',');
            if ((serializeNetInstValueofTemplateto(pnvmPlaceItemToken(placeItem), tmpl, o)) < 0) {
                return -1;
            }
            if (!(pnvmIterCanAppend(o))) {
                setError(ErrorCollectionFull);
                return -1;
            }
            pnvmIterWrite(o, ')');
        }
        if (!(pnvmIterCanAppend(o))) {
            setError(ErrorCollectionFull);
            return -1;
        }
        pnvmIterWrite(o, ')');
    }
    if (pnvmIterCanAppend(o)) {
        pnvmIterWrite(o, ')');
        return (pnvmIterIndex(o)) - origWritePosition;
    } else {
        setError(ErrorCollectionFull);
        return -1;
    }
}


/*	Return number of written characters or -1 on error. */

static int serializeNetInstValueofTemplateto(PNVMToken const & token, PNVMTemplate *tmpl, PNVMStringIter & o) {
    PNVMTupleIter si;
    int origWritePosition;
    PNVMTupleHead const *symbols;

    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(tmpl,'PNVMTemplate')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    origWritePosition = pnvmIterIndex(o);
    if ((pnvmTokenType(token)) == TOKEN_TYPE_INTEGER) {
        return serializeNumberto(pnvmTokenInteger(token), o);
    } else {
        if ((pnvmTokenType(token)) == TOKEN_TYPE_NET_REF) {
            return serializeNetInstto(pnvmTokenNetRef(token), o);
        } else {

            /* try to find, whether token value does not belong to template symbols to save space */

            symbols = pnvmTemplateSymbols(tmpl);
            si = pnvmValueIterator(((PNVMTupleHead *) symbols));
            while ((!(pnvmIterAtEnd(si))) && (((pnvmTokenType(pnvmIterValue(si))) != TOKEN_TYPE_POINTER) || ((pnvmTokenPointer(pnvmIterValue(si))) != (pnvmTokenPointer(token))))) {
                pnvmIterNext(si);
            }
            if (pnvmIterAtEnd(si)) {

                /* token not found among net template's symbols */

                return serializeValueto(pnvmTokenPointer(token), o);
            } else {

                /*  token found among symbols */

                if (pnvmIterCanAppend(o)) {
                    pnvmIterWrite(o, 'S');
                    serializeNumberto(pnvmIterIndex(si), o);
                } else {
                    setError(ErrorCollectionFull);
                    return -1;
                }
            }
        }
    }
    return (pnvmIterIndex(o)) - origWritePosition;
}

static int serializeNumberto(int num, PNVMStringIter & o) {
    char buf[15];
    long tmp;
    int i;
    int origWritePosition;
    int n;

    /* assert(interpreterProxy->isKindOf(num,'Number')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    origWritePosition = pnvmIterIndex(o);
    if (!(pnvmIterCanAppend(o))) {
        setError(ErrorCollectionFull);
        return -1;
    }
    if (num < 0) {
        pnvmIterWrite(o, '-');
    }
    tmp = abs(num);
    if (!(pnvmIterCanAppend(o))) {
        setError(ErrorCollectionFull);
        return -1;
    }
    if (tmp < 10) {
        pnvmIterWrite(o, (((int)'0')) + tmp);
    } else {
        n = 0;
        ;
        while (tmp > 0) {
            buf[n] = ((((int)'0')) + (tmp % 10));
            tmp = tmp / 10;
            n += 1;
        }
        for (i = 1; i <= n; i += 1) {
            if (!(pnvmIterCanAppend(o))) {
                setError(ErrorCollectionFull);
                return -1;
            }
            pnvmIterWrite(o, buf[n - i]);
        }
    }
    return (pnvmIterIndex(o)) - origWritePosition;
}


/*	Return number of characters written or -1 on error. */

static int serializeTokento(PNVMToken const & token, PNVMStringIter & o) {
    /* assert(interpreterProxy->isKindOf(token,'PNVMToken')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    if ((pnvmTokenType(token)) == TOKEN_TYPE_INTEGER) {
        return serializeNumberto(pnvmTokenInteger(token), o);
    } else {
        if ((pnvmTokenType(token)) == TOKEN_TYPE_NET_REF) {
            return serializeNetInstto(pnvmTokenNetRef(token), o);
        } else {
            return serializeValueto(pnvmTokenPointer(token), o);
        }
    }
}


/*	
    Return number of characters written or -1 on error.
     */

static int serializeValueto(PNVMHeaderBlock const *block, PNVMStringIter & o) {
    PNVMArrayIter ai;
    int origWritePosition;
    PNVMTupleIter ti;

    /* assert(interpreterProxy->isKindOf(block,'PNVMHeaderBlock')); */
    /* assert(interpreterProxy->isKindOf(o,'PNVMItemIterator')); */
    origWritePosition = pnvmIterIndex(o);
    if ((signature(block)) == SIGN_STRING) {
        return renderAsStringto(((PNVMStringHead const *) block), o);
    } else {
        if ((signature(block)) == SIGN_ARRAY) {
            ai = pnvmValueIterator(((PNVMArrayHead *) block));
            if (pnvmIterCanAppend(o)) {
                pnvmIterWrite(o, '{');
                while ((!(pnvmIterAtEnd(ai))) && (pnvmIterCanAppend(o))) {
                    if ((serializeTokento(pnvmIterNext(ai), o)) < 0) {
                        return -1;
                    }
                    if ((!(pnvmIterAtEnd(ai))) && (pnvmIterCanAppend(o))) {
                        pnvmIterWrite(o, ',');
                    }
                }
            }
            if (pnvmIterCanAppend(o)) {
                pnvmIterWrite(o, '}');
            } else {
				LOG4CXX_ERROR(exlog, "failed to serialize array: output buffer full")
                setError(ErrorCollectionFull);
                return -1;
            }
        } else {
            if ((signature(block)) == SIGN_TUPLE) {
                ti = pnvmValueIterator(((PNVMTupleHead *) block));
                if (pnvmIterCanAppend(o)) {
                    pnvmIterWrite(o, '[');
                    while ((!(pnvmIterAtEnd(ti))) && (pnvmIterCanAppend(o))) {
                        if ((serializeTokento(pnvmIterNext(ti), o)) < 0) {
                            return -1;
                        }
                        if ((!(pnvmIterAtEnd(ti))) && (pnvmIterCanAppend(o))) {
                            pnvmIterWrite(o, ',');
                        }
                    }
                }
                if (pnvmIterCanAppend(o)) {
                    pnvmIterWrite(o, ']');
                } else {
					LOG4CXX_ERROR(exlog, "failed to serialize tuple: output buffer full")
                    setError(ErrorCollectionFull);
                    return -1;
                }
            } else {
                if ((signature(block)) == SIGN_NET_INSTANCE) {
                    return serializeNetInstto(((PNVMNetInstHead const *) block), o);
                } else {
                    dieWithmsgwith(ErrorExecutionUnhandledSignature, "don't know how to serialize ", dereference(block));
                }
            }
        }
    }
    return (pnvmIterIndex(o)) - origWritePosition;
}


/*	
    This sets the error code to 'err' only if the current error code is Success.
    This is done to prevent overriding specific error by more general one by caller function,
    which failed due to a failure of called function (which set the specific error code).
    
    Note that this flag is reset to Success at the beginning of each step. Error code should
    be handled in the main loop.
    
    Return saved error code after assignment.
     */

Error_t setError(Error_t err) {
    ;
    if ((err == ErrorSuccess) || (error == ErrorSuccess)) {
        error = err;
    }
    return error;
}


/*	Note: This is coded so that is can be run from Squeak. */


static bool setInvalidResult(PNVMToken & result) {
    /* assert(interpreterProxy->isKindOf(result,'PNVMToken')); */
    pnvmTokenMakeInvalid(result);
    return 0;
}


/*	
    Utility function for writing item to generic iterator.
    It does type checking and retypes iterator to correct one.
    Token or placeitem values must be referenced with 'makePointer()'.
     */

static void setValueItemat(void *item, PNVMItemIterator & i) {
    PNVMPlaceHead *place;

    /* assert(((signature(pnvmIterHeaderBlock(i))) != SIGN_STRING) || ((interpreterProxy->isKindOf(item,'Character')) || (interpreterProxy->isKindOf(item,'Number')))); */
    /* assert(((signature(pnvmIterHeaderBlock(i))) != SIGN_ARRAY) || (interpreterProxy->isKindOf(item,'PNVMToken'))); */
    /* assert(((signature(pnvmIterHeaderBlock(i))) != SIGN_TUPLE) || (interpreterProxy->isKindOf(item,'PNVMToken'))); */
    /* assert(((signature(pnvmIterHeaderBlock(i))) != SIGN_NET_INSTANCE) || (interpreterProxy->isKindOf(item,'PNVMPlaceHead'))); */
    /* assert(((signature(pnvmIterHeaderBlock(i))) != SIGN_PLACE) || (interpreterProxy->isKindOf(item,'PNVMPlaceItem'))); */
    if ((signature(pnvmIterHeaderBlock(i))) == SIGN_STRING) {
        pnvmIterSetItem(pnvmIterString(i), dereference(((char const *) item)));
    } else {
        if ((signature(pnvmIterHeaderBlock(i))) == SIGN_ARRAY) {
            pnvmIterSetItem(pnvmIterArray(i), dereference(((PNVMToken *) item)));
        } else {
            if ((signature(pnvmIterHeaderBlock(i))) == SIGN_TUPLE) {
                pnvmIterSetItem(pnvmIterTuple(i), dereference(((PNVMToken *) item)));
            } else {
                if ((signature(pnvmIterHeaderBlock(i))) == SIGN_NET_INSTANCE) {
                    place = ((PNVMPlaceHead *) item);
                    pnvmIterSetItem(pnvmIterNetInst(i), place);
                } else {
                    if ((signature(pnvmIterHeaderBlock(i))) == SIGN_PLACE) {
                        pnvmIterSetItem(pnvmIterPlace(i), dereference(((PNVMPlaceItem *) item)));
                    } else {
                        dieWithmsgwith(ErrorExecutionUnhandledSignature, "unhandled block type ", dereference(pnvmIterHeaderBlock(i)));
                    }
                }
            }
        }
    }
}


/*	
    Make one step of interpreter.
        1st		- check input buffer and output of platform
        2nd		- process calendar events
        3rd		- try to fire any transition of all net instances
        4th		- if any holes in code or net template table arised, squash them
                - prevent code fragmentation and keep the loop swift
     */

static Error_t step(void) {
    bool templateTableHoley;
    int tmplId;
    int i;
    int src;
    int dest;

	LOG4CXX_INFO(exlog, "------------ STEP " << stepCounter << " ------------")

    /* reset error flag */

    nothingChanged = 1;
    setError(ErrorSuccess);
    if (!((inputOutput()) == ErrorSuccess)) {
		LOG4CXX_ERROR(exlog, "input output failed")
        return error;
    }
    updateTime();
    calendarEvent();
    templateTableHoley = 0;
    tmplId = 0;
    while ((tmplId < numberOfNetTemplates) && ((tmplId < MaxNetTemplates) && (!(error != ErrorSuccess)))) {

        /* for every template: process its instances */

        if ((netTemplateTable[tmplId]) == NULL) {
            templateTableHoley = 1;
        } else {

            /* 
            template could be unloaded during this step
            that's why we need to check for nil
             */

            processTemplateInstances(netTemplateTable[tmplId]);
        }
        tmplId += 1;
    }
    if (codeWithHoles) {

        /* squash code blocks together */

        fillCodeHoles();
    }
    if (templateTableHoley) {

        /* squash net templates together */

        /* begin squashNetTemplateTable */
        dest = 0;
        src = 0;
        for (i = 0; i <= (numberOfNetTemplates - 1); i += 1) {
            while ((netTemplateTable[src]) == NULL) {
                src += 1;
            }
            if (!(dest == src)) {
                netTemplateTable[dest] = (netTemplateTable[src]);
                netTemplateTable[src] = NULL;
            }
            dest += 1;
            src += 1;
        }
    }
    stepCounter += 1;
	LOG4CXX_DEBUG(exlog, "leaving step")
    return error;
}


/*	
    Gets the error description for error code.
    Arduino can not have this much error messages compiled in binary - they occupy
    data segment (SRAM), which is precious. Arduino will just send error code over
    serial line.
     */

char const * strError(Error_t err) {
    char const * arr[ErrorGenericLast + (ErrorParsingLast - ErrorParsingFirst) + (ErrorExecutionLast - ErrorExecutionFirst) + (ErrorIOLast - ErrorIOFirst)] = { NULL };
    int offset;
    char const *res;

    /* assert(interpreterProxy->isKindOf(err,'Number')); */
    res = NULL;
    
# ifndef TARGET_ARDUINO
    ;
    arr[ErrorUnspecified] = "unspecified error";
    arr[ErrorNoMemory] = "not memory";
    arr[ErrorOutOfRange] = "index out of range";
    arr[ErrorCollectionFull] = "collection full";
    offset = ErrorGenericLast - ErrorParsingFirst;
    arr[offset + ErrorParsingTemplate] = "failed to parse net template";
    arr[offset + ErrorParsingTemplateSymbols] = "failed to parse template symbols";
    arr[offset + ErrorParsingNames] = "failed to parse names";
    arr[offset + ErrorParsingUplinks] = "failed to parse uplinks";
    arr[offset + ErrorParsingInit] = "failed to parse init transition";
    arr[offset + ErrorParsingTransitions] = "failed to parse transitions";
    arr[offset + ErrorParsingUplink] = "failed to parse uplink transition";
    arr[offset + ErrorParsingTransition] = "failed to parse transition";
    arr[offset + ErrorParsingTransitionCode] = "failed to parse transition elements";
    arr[offset + ErrorParsingExpression] = "failed to expression";
    arr[offset + ErrorParsingSymbol] = "failed to parse symbol";
    arr[offset + ErrorParsingToken] = "failed to parse token";
    arr[offset + ErrorParsingCollection] = "failed to parse collection";
    arr[offset + ErrorParsingString] = "failed to parse string";
    arr[offset + ErrorParsingNetInst] = "failed to parse net instance";
    arr[offset + ErrorParsingPlace] = "failed to parse net instance place";
    arr[offset + ErrorParsingNetInstValue] = "failed to parse value of net instance";
    arr[offset + ErrorNoSuchPlace] = "no such place in net template of instance";
    offset = (ErrorGenericLast + (ErrorParsingLast - ErrorParsingFirst)) - ErrorExecutionFirst;
    arr[offset + ErrorExecutionUnspecified] = "generic execution error";
    arr[offset + ErrorTemplatesDatabaseFull] = "net template database full";
    arr[offset + ErrorNoSuchUplink] = "no such uplink in given net template";
    arr[offset + ErrorNoSuchTemplate] = "no such template in database";
    arr[offset + ErrorCalendarEmpty] = "calendar empty";
    arr[offset + ErrorExecutionUnhandledOperator] = "requested operator not missing implementation";
    arr[offset + ErrorExecutionUnhandledTransitionElement] = "unexpected transition element";
    arr[offset + ErrorInitFailed] = "failed to execute init transition";
    offset = (((ErrorGenericLast + (ErrorParsingLast - ErrorParsingFirst)) + (ErrorExecutionLast - ErrorExecutionFirst)) + (ErrorIOLast - ErrorIOFirst)) - ErrorIOLast;
    res = arr[err];
    
# endif
    return res;
}

static char * stringToCStr(PNVMStringHead const *str) {
    char *res;

    /* assert(interpreterProxy->isKindOf(str,'PNVMStringHead')); */
    res = ((char *) (malloc(pnvmValueItemCount(str) + 1)));
    PNVMStringIter i = pnvmValueIterator((PNVMStringHead *) str);
    while (!pnvmIterAtEnd(i)) {res[pnvmIterIndex(i)] = pnvmIterNext(i);}
    res[pnvmIterIndex(i)] = 0;
    return res;
}


/*	
    Swap two items of two blocks without any change to reference counts.
    First block may be identical with second one. In case, that they are no identical,
    the second block must be tail.
    
    :param i1: Index to the item of block b1.
    :param i2: Index to the item of block b2.
    :param isFirstBlockHead: Whether the first block is header block.
    
    *Note* this code treats both blocks as last tail blocks.
     */

static void swapItemAtofBlockwithofBlockwithSignatureisFirstBlockHead(int i1, void *b1, int i2, void *b2, int sig, int isHead) {
    void *item;

    ;
    
#define swapWithCorrectTypes(block1Type, block2Type, itemType, i1, b1, i2, b2) \
        itemType item = dereference((block1Type *) b1)[i1]; \
        dereference((block1Type *) b1)[i1] = dereference((block2Type *) b2)[i2]; \
        dereference((block2Type *) b2)[i2] = item
    
#define swapHeadOrTailTypes(type, itemType) \
        if (b1 == b2) { \
            if (isHead) { \
                swapWithCorrectTypes(PNVM ## type ##Head, PNVM ## type ##Head, itemType, i1, b1, i2, b2); \
            } else { \
                swapWithCorrectTypes(PNVM ## type ##Tail, PNVM ## type ##Tail, itemType, i1, b1, i2, b2); \
            } \
        } else { \
            if (isHead) { \
                swapWithCorrectTypes(PNVM ## type ##Head, PNVM ## type ##Tail, itemType, i1, b1, i2, b2); \
            } else { \
                swapWithCorrectTypes(PNVM ## type ##Tail, PNVM ## type ##Tail, itemType, i1, b1, i2, b2); \
            } \
        }
    switch (sig) {
        case SIGN_ARRAY:	swapHeadOrTailTypes(Array, PNVMToken); break;
#ifndef TARGET_ARDUINO		
        case SIGN_TUPLE:	swapHeadOrTailTypes(Tuple, PNVMToken); break;
#endif
        case SIGN_STRING:	swapHeadOrTailTypes(String, char); break;
        case SIGN_NET_INSTANCE:	swapHeadOrTailTypes(NetInst, PNVMPlaceHead*); break;
        case SIGN_PLACE:	swapHeadOrTailTypes(Place, PNVMPlaceItem); break;
    }
}


/*	
    Remove instance from array of template instances.
     */

void unmanageNetInstance(PNVMNetInstHead *inst) {
    PNVMArrayIter i;
    PNVMTemplate *tmpl;

    /* assert(interpreterProxy->isKindOf(inst,'PNVMNetInstHead')); */

    /* we may be in the cleanup procedure -> instances array may already be freed */

    tmpl = pnvmNetInstTemplate(inst);
    if (!((pnvmTemplateInstances(tmpl)) == NULL)) {
        i = pnvmValueIterator(pnvmTemplateInstances(tmpl));
        while ((!(pnvmIterAtEnd(i))) && ((pnvmTokenNetRef(pnvmIterValue(i))) != inst)) {
            pnvmIterNext(i);
        }
        if (pnvmIterAtEnd(i)) {
			LOG4CXX_ERROR(exlog, "could not find net instance in template instances of '" << asPlainString(pnvmTemplateName(tmpl)) << "'")
        } else {
            removeItemFromBlockAt(pnvmIterAsItemIterator(i));
        }
    }
}


/*	time is set to current unix time in milliseconds */

static void updateTime(void) {
    int dt;

    currentTime = millis();
}


/*	
    Utility function for writing item to generic iterator.
    It does type checking and retypes iterator to correct one.
    Token or placeitem values must be referenced with 'makePointer()'.
     */

static void writeValueItemat(void *item, PNVMItemIterator & i) {
    setValueItemat(item, i);
    pnvmIterNext(i);
}



